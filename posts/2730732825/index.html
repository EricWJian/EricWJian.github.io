<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java多线程 | Eric</title><meta name="author" content="Eric"><meta name="copyright" content="Eric"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java多线程、并发编程和源码分析1、线程是什么、并发与并行、为什么需要线程1、线程和进程  进程：简单的说，在系统中运行的一个应用程序就是一个进程。 线程：也被称为轻量级进程，是大多数操作系统进行时序调度的基本单元。 轻量级的含义(线程和进程最主要的区别):  就是线程耗费的资源比进程要少，运行"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://ericwjian.github.io/posts/2730732825/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4dfa2c883c8c4c23f4866185de932236";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java多线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-05 15:19:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Eric"><span class="site-name">Eric</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-13T16:00:00.000Z" title="发表于 2022-12-14 00:00:00">2022-12-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-05T07:19:25.433Z" title="更新于 2024-07-05 15:19:25">2024-07-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java多线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><hr>
<h1 id="Java多线程、并发编程和源码分析"><a href="#Java多线程、并发编程和源码分析" class="headerlink" title="Java多线程、并发编程和源码分析"></a>Java多线程、并发编程和源码分析</h1><h2 id="1、线程是什么、并发与并行、为什么需要线程"><a href="#1、线程是什么、并发与并行、为什么需要线程" class="headerlink" title="1、线程是什么、并发与并行、为什么需要线程"></a>1、线程是什么、并发与并行、为什么需要线程</h2><h3 id="1、线程和进程"><a href="#1、线程和进程" class="headerlink" title="1、线程和进程"></a>1、线程和进程</h3><img src="/posts/2730732825/image-20231011143859729.png" class="" title="image-20231011143859729">

<p><strong>进程</strong>：简单的说，在系统中运行的一个应用程序就是一个进程。</p>
<p><strong>线程</strong>：也被称为<code>轻量级进程</code>，是大多数操作系统进行<code>时序调度</code>的基本单元。</p>
<p><strong>轻量级的含义</strong>(线程和进程最主要的区别):</p>
<ol>
<li>就是线程耗费的资源比进程要少，运行速度相对更快。<ul>
<li>进程之间是相互独立的，资源是不共享的。</li>
<li>同一个进程内的线程是共享资源的。</li>
</ul>
</li>
<li>线程的切换速度更快，而进程切换很耗费资源，相对代价更高。</li>
</ol>
<p><strong>时序调度的含义</strong>：就是操作系统对任务按照时间先后进行调度的过程。</p>
<ol>
<li>时序调度的基本单元就是线程。</li>
<li>基本的调度方式：就是抢占式(抢占的是 CPU 的时间片)。</li>
</ol>
<blockquote>
<p>举例：</p>
<p>1、打开一个浏览器、一个聊天窗口分别是一个进程。进程可以有多个子任务，如聊天工具接收消息、发送消息，这些子任务成为线程。</p>
<p>2、Tomcat是一个进程，当用户访问的时候，会为每个用户创建一个线程来进行访问。</p>
</blockquote>
<h3 id="2、相关概念"><a href="#2、相关概念" class="headerlink" title="2、相关概念"></a>2、相关概念</h3><h4 id="1、并发"><a href="#1、并发" class="headerlink" title="1、并发"></a>1、并发</h4><p>一个时间段多个线程在单个核心运行，同一时间只能一个线程运行，系统不停切换线程，看起来像同时运行实际上是线程不停切换。</p>
<img src="/posts/2730732825/image-20231113154255962.png" class="" title="image-20231113154255962">

<h4 id="2、并行"><a href="#2、并行" class="headerlink" title="2、并行"></a>2、并行</h4><p>一个时间段内每个线程分配给独立的核心，线程同时运行。</p>
<img src="/posts/2730732825/image-20231113154242687.png" class="" title="image-20231113154242687">

<h4 id="3、串行"><a href="#3、串行" class="headerlink" title="3、串行"></a>3、串行</h4><p>一个时间段内多个任务执行时一个任务执行完才能执行另一个。</p>
<img src="/posts/2730732825/image-20231113154222883.png" class="" title="image-20231113154222883">

<h4 id="4、并发和并行区别"><a href="#4、并发和并行区别" class="headerlink" title="4、并发和并行区别"></a>4、并发和并行区别</h4><ol>
<li>并发是指两个或多个事件在同一时间间隔内<code>交替发生</code>(同一时刻只有一个事件在发生)。</li>
<li>并发是在一台处理器上<code>同时</code>处理多个任务。</li>
<li>并行是指两个或多个事件在同一时刻同时发生。</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。 </li>
<li>并行是在多台处理器上同时处理多个任务。</li>
</ol>
<h4 id="5、同步和异步"><a href="#5、同步和异步" class="headerlink" title="5、同步和异步"></a>5、同步和异步</h4><ul>
<li><p>同步指的是任务按照一定的顺序依次执行，每个任务必须等待前一个任务完成。</p>
</li>
<li><p>异步则是指任务可以独立于其他任务执行，不需要等待其他任务的完成。</p>
</li>
</ul>
<p>同步和异步关注的是<strong>消息通信机制</strong></p>
<p>同步：同步是指一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去。</p>
<p>异步：异步是指进程不需要一直等待下去，而是继续执行下面的操作，不管其他进程的状态，当有信息返回的时候会通知进程进行处理，这样就可以提高执行的效率了，即异步是我们发出的一个请求，该请求会在后台自动发出并获取数据，然后对数据进行处理，在此过程中，我们可以继续做其他操作，不管它怎么发出请求，不关心它怎么处理数据。</p>
<h4 id="6、单线程和多线程"><a href="#6、单线程和多线程" class="headerlink" title="6、单线程和多线程"></a>6、单线程和多线程</h4><p>单线程是指程序只有一个执行线程，所有任务都在该线程中依次执行。多线程是指程序创建了多个执行线程，不同的任务可以同时在不同的线程中执行。</p>
<blockquote>
<p>在Java中，可以通过多线程实现并发和并行处理，同时也可以实现同步和异步的机制。需要注意的是，并发和并行、同步和异步、单线程和多线程是不同的概念，它们可以独立使用，也可以组合使用，具体取决于应用程序的需求。</p>
</blockquote>
<h3 id="3、为什么需要多线程"><a href="#3、为什么需要多线程" class="headerlink" title="3、为什么需要多线程"></a>3、为什么需要多线程</h3><ul>
<li>充分利用多核处理器  </li>
<li>提高程序性能 </li>
<li>提高程序吞吐量。</li>
</ul>
<h3 id="4、线程的风险"><a href="#4、线程的风险" class="headerlink" title="4、线程的风险"></a>4、线程的风险</h3><p>1、线程安全性问题</p>
<ul>
<li>就是多线程环境下，程序运行的结果与预期不符合。</li>
</ul>
<p>2、线程的活跃度问题 </p>
<ul>
<li>死锁 </li>
<li>饥饿：就是某个线程 较长时间 或者 很难得到执行。</li>
<li>活锁：线程拿到了锁，却又相互释放 不去执行功能。</li>
</ul>
<p>3、线程的性能问题</p>
<ul>
<li>主要是线程间切换上下文的开销。</li>
<li>切换上下文的时候，线程 A 需要保存它当前的状态；下次线程 A 抢到 CPU 时间片，切换回来继续运行，需要先恢复状态，然后再继续向下执行。</li>
</ul>
<h2 id="2、创建线程的方式"><a href="#2、创建线程的方式" class="headerlink" title="2、创建线程的方式"></a>2、创建线程的方式</h2><p>创建线程的方式很多，这里只讲几种最常用的，其它创建线程的形式基本上就是这些基本形式的变形使用。</p>
<blockquote>
<p>继承 Thread 和实现 Runnable 接口，归根到底都是通过 Thread 这个类来创建多线程，只不过继承Thread这种方式已经创建了。</p>
<p>而实现Runnable接口这种方式，需要重新 new 一个 Thread，并将 Runnable 的实现类传入进去。</p>
</blockquote>
<h3 id="1、实现Runnable"><a href="#1、实现Runnable" class="headerlink" title="1、实现Runnable"></a>1、实现Runnable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口，重写run方法</span></span><br><span class="line"><span class="comment"> * 通过自定义一个类（这里起名为：ImplRunnable）实现Runnable接口，重写run方法，</span></span><br><span class="line"><span class="comment"> * 最后在 main方法 new 出 ImplRunnable 实例和Thread实例，最后通过start方法创建并启动线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Create01ImplRunnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ImplRunnable</span> <span class="variable">implRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImplRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(implRunnable);</span><br><span class="line">        <span class="comment">// t.run(); 这种方式代码也可以运行，但是不是多线程的，就是正常的调用对象的方法</span></span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------这是主线程:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程中：</span></span><br><span class="line"><span class="comment"> * 1、并不是优先级高的就一定会抢占到CPU的时间片。</span></span><br><span class="line"><span class="comment"> * 2、优先级高，只是表示抢占到CPU的时间片的机率比较大。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImplRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现Runnable接口，重写run方法&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id=&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Priority(优先级)=&quot;</span> + Thread.currentThread().getPriority());</span><br><span class="line">        System.out.println(<span class="string">&quot;StackTrace(调用栈的链路[倒着看])=&quot;</span> + Arrays.toString(Thread.currentThread().getStackTrace()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、继承Thread"><a href="#2、继承Thread" class="headerlink" title="2、继承Thread"></a>2、继承Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承Thread，重写run方法</span></span><br><span class="line"><span class="comment"> * 通过自定义一个类（这里起名为：ExtendsThread），继承Thread类，重写run方法，最后在main方法中new出 ExtendsThread 实例，</span></span><br><span class="line"><span class="comment"> * 调用这个实例的继承的Thread类的start方法创建一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Create02ExtendsThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;，这是主线程&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExtendsThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExtendsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;，继承Thread，重写run方法创建线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、匿名内部类"><a href="#3、匿名内部类" class="headerlink" title="3、匿名内部类"></a>3、匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用匿名内部类创建多线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Create04InnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;new Thread1111==&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;new Thread2222==&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;new Thread3333==&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;new Thread4444==&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;箭头函数啊&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、callable，带返回值"><a href="#4、callable，带返回值" class="headerlink" title="4、callable，带返回值"></a>4、callable，带返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Callable接口</span></span><br><span class="line"><span class="comment"> * 通过自定义类（这里起名为：ImplCallable），实现Callable接口，重写call方法（call方法可以理解为线程需要执行的任务），</span></span><br><span class="line"><span class="comment"> * 并且带有返回值，这个返回表示一个计算结果，如果无法计算结果，则引发Exception异常，接着创建Callable实例，</span></span><br><span class="line"><span class="comment"> * 使用FutrueTast类包装Callable对象，FutureTask是一个包装器，需要接收Callable实例来创建，并且有两个构造函数，</span></span><br><span class="line"><span class="comment"> * 一个参数只有Callable对象，另一个参数不仅有Callable对象，还有一个泛型的result参数，最后使用FutureTask对象作为Thread的构造参数，通过start方法创建并启动线程；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Create03ImplCallable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException， InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ImplCallable</span>()); <span class="comment">// 创建一个未来的任务</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);<span class="comment">// 创建一个线程，来执行未来任务</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task.get();<span class="comment">// 阻塞式</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取子线程的返回值 = &quot;</span> + result);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;，这是主线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * callable 是含有返回值的&lt;泛型&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImplCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;，实现callable接口，重写call方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、线程的状态"><a href="#3、线程的状态" class="headerlink" title="3、线程的状态"></a>3、线程的状态</h2><p>1、<code>NEW</code>：初始状态，实例化了一个线程对象，但还没调用 start 方法。</p>
<p>2、<code>RUNNABLE</code>：运行状态，将<code>就绪</code>和<code>运行</code>中的两种状态称为运行状态。</p>
<p>3、<code>BLOCKED</code>：阻塞状态</p>
<p>4、<code>WAITING</code>：等待状态</p>
<p>5、<code>TIMED_WAITING</code>：限时等待状态</p>
<p>6、<code>TERMINATED</code>：终止状态</p>
<img src="/posts/2730732825/image-20231113150206544.png" class="" title="image-20231113150206544">

<h2 id="4、线程基本操作"><a href="#4、线程基本操作" class="headerlink" title="4、线程基本操作"></a>4、线程基本操作</h2><h3 id="1、sleep-、yield-、wait-方法"><a href="#1、sleep-、yield-、wait-方法" class="headerlink" title="1、sleep()、yield()、wait() 方法"></a>1、sleep()、yield()、wait() 方法</h3><ol>
<li>sleep 是 Thread 的静态方法；sleep 不会释放锁，它也不需要占用锁；调用 sleep 方法过后，线程进入到 time_waiting 状态。</li>
<li>yield()方法作用是放弃当前CPU资源，让给其他线程去使用，但是放弃时间不确定，<strong>不会释放对象锁</strong>;调用 yield 方法后，线程是进入 ready 状态。</li>
<li>wait 是 Object 的方法，任何对象实例都能调用；wait 会释放锁，但调用它的前提是当前线程占有锁(即代码要在 synchronized 中);</li>
</ol>
<p>共同点：让当前线程释放cpu资源，让其它线程来运行。</p>
<p>不同点：，而</p>
<h3 id="2、notify-、notifyAll"><a href="#2、notify-、notifyAll" class="headerlink" title="2、notify()、notifyAll()"></a>2、notify()、notifyAll()</h3><h3 id="3、join"><a href="#3、join" class="headerlink" title="3、join()"></a>3、join()</h3><ol>
<li>让当前线程插队执行。</li>
</ol>
<h3 id="4、interrupted"><a href="#4、interrupted" class="headerlink" title="4、interrupted()"></a>4、interrupted()</h3><ol>
<li> 终止当前线程，需要当前线程配合处理中断逻辑。</li>
</ol>
<h2 id="5、线程的安全性问题"><a href="#5、线程的安全性问题" class="headerlink" title="5、线程的安全性问题"></a>5、线程的安全性问题</h2><p><strong>线程安全性问题发生的条件</strong></p>
<ol>
<li>多线程环境。</li>
<li>存在临界资源 (就是多个线程会去共享访问的资源)。</li>
<li>存在并发写临界资源的情况。</li>
</ol>
<h2 id="6、synchronized关键字"><a href="#6、synchronized关键字" class="headerlink" title="6、synchronized关键字"></a>6、synchronized关键字</h2><ol>
<li><p>并发编程三大特性：<code>原子性</code>，<code>可见性</code>，<code>有序性</code>。</p>
</li>
<li><p>原子性：不可分割，意思就是一个线程在执行这段代码的时候，中间不会插入其它的线程来执行这段代码。也就是同一时刻，只有一个线程在执行这段代码。</p>
</li>
<li><p>synchronized 通过加锁的方式，保证了方法操作的原子性。</p>
</li>
<li><p>隐式锁(内置锁)：</p>
<ul>
<li>synchronized 修饰<code>类、静态方法</code>时，锁的是当前类的 Class 对象，也就是给所有的对象都加了同一把锁。</li>
<li>synchronized 修饰<code>普通方法</code>时，作用对象是该类的当前对象，不同对象会持有不同的锁。</li>
<li>synchronized 修饰<code>代码块</code>，可以锁任意的对象，比如: this(当前对象)，num转换成的Integer对象，abc.class(该类的所有对象)。</li>
</ul>
</li>
<li><p>显示锁：</p>
<ul>
<li>java.util.concurrent.locks 包中的锁是<strong>显示锁</strong>，需要进行lock和unlock。</li>
</ul>
</li>
<li><p>synchronized 不能被继承，不能使用 Synchronized 关键字修饰接口方法；构造方法也不能用 Synchronized 修饰。</p>
</li>
<li><p><code>互斥性</code>：保证了同时只能有一个线程持有锁，其它线程跟这个持有锁的线程互斥就处于等待中 。(跟当前持有锁的对象有关，对象一致持有的锁是同一把锁）。</p>
</li>
<li><p>synchronized 的<code>可重入性</code>：当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁，请求就会成功，否则阻塞。</p>
</li>
</ol>
<h2 id="7、monitor机制"><a href="#7、monitor机制" class="headerlink" title="7、monitor机制"></a>7、monitor机制</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p><code>每一个对象都有一个与之关联的 Monitor</code>，Monitor 机制是一种多线程同步机制，它可以保证多个线程之间互斥访问，从而避免线程之间的冲突和竞争。Monitor是一个同步工具，或者说是一种同步机制。</p>
<p><strong>特点</strong></p>
<ol>
<li>互斥</li>
<li>singnal机制</li>
</ol>
<p><strong>实现</strong></p>
<ol>
<li>Monitor是依赖于底层操作系统的 Mutex Lock 实现</li>
</ol>
<p><strong>数据方面</strong></p>
<p>monitor是线程私有的数据结构。</p>
<p>在Java虚拟机(HotSpot)中，monitor是由 ObjectMonitor 实现的，主要的属性是：</p>
<ol>
<li>_count：记录 owner 线程获取锁的次数。</li>
<li>_owner：_owner 指向持有 ObjectMonitor对象的线程。</li>
<li>_WaitSet：处于_wait 状态的线程，会被加入到 _WaitSet。</li>
<li>_EntryList：处于等待锁 block 状态的线程，会被加入到该队列。</li>
<li>_recursions：锁的重入次数。</li>
</ol>
<h3 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h3><img src="/posts/2730732825/image-20231016104817763.png" class="" title="image-20231016104817763">

<ol>
<li>想要获取 monitor 的线程，首先会进入 <code>_EntryList</code> 队列。</li>
<li>当某个线程获取到对象的 monitor 后，进入<code>_Owner</code>区域，设置为当前线程，同时计数器 <code>_count</code> 加1。</li>
<li>如果线程调用了 wait() 方法，则会进入 _WaitSet 队列。它会释放 monitor 锁，即将 _owner 赋值为 null，_count自减1，进入 _WaitSet 队列阻塞等待。</li>
<li>如果其他线程调用 notify() / notifyAll() ，会唤醒 _WaitSet 中的某个线程，该线程再次尝试获取 monitor 锁，成功即进入 _Owner 区域。</li>
<li>同步方法执行完毕了，线程退出临界区，会将 monitor 的 owner 设为 null，并释放监视锁。</li>
</ol>
<p><strong>指令方面，class 文件</strong></p>
<ol>
<li><p>ACC_SYNCHRONIZED：添加了synchronized关键字的方法，代码反编译后多了 ACC_SYNCHRONIZED 标记。</p>
</li>
<li><p>monitorenter：进入</p>
</li>
<li><p>monitorexit：离开</p>
</li>
</ol>
<h3 id="3、synchronized-的-monitor-机制"><a href="#3、synchronized-的-monitor-机制" class="headerlink" title="3、synchronized 的 monitor 机制"></a>3、synchronized 的 monitor 机制</h3><p>synchronized 是 JVM 的内置锁，基于 Monitor 机制实现。</p>
<p>每一个对象都有一个与之关联的监视器 (Monitor)，这个监视器充当了一种互斥锁的角色。当一个线程想要访问某个对象的 synchronized 代码块，首先需要获取该对象的 Monitor。如果该 Monitor 已经被其他线程持有，则当前线程将会被阻塞，直至 Monitor 变为可用状态。当线程完成 synchronized 块的代码执行后，它会释放 Monitor，并把 Monitor 返还给对象池，这样其他线程才能获取 Monitor 并进入 synchronized 代码块。</p>
<p>synchronized可以修饰类、方法（实例方法和静态方法）和代码块（修饰代码块实现同步），区别就是作用范围的不同：</p>
<ul>
<li>修饰类的时候和修饰静态方法是一样的，都是给所有的对象加了同一把锁；</li>
<li>修饰实例方法时作用范围就是整个函数，给当前实例加锁；</li>
<li>修饰代码块时作用范围就是大括号内的内容，对给定的对象加锁。</li>
</ul>
<h2 id="8、锁信息存放"><a href="#8、锁信息存放" class="headerlink" title="8、锁信息存放"></a>8、锁信息存放</h2><img src="/posts/2730732825/image-20231113165826321.png" class="" title="image-20231113165826321">

<h3 id="1、对象的内存布局"><a href="#1、对象的内存布局" class="headerlink" title="1、对象的内存布局"></a>1、对象的内存布局</h3><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：</p>
<p>对象头（Header），实例数据（Instance Data）和对象填充（Padding）。</p>
<img src="/posts/2730732825/image-20231113170342892.png" class="" title="image-20231113170342892">

<ul>
<li><strong>对象头</strong>：Hotspot 虚拟机的对象头主要包括：Mark Word（标记字段）、Class Pointer（类型指针）、数组长度（只有数组才有）。</li>
<li><strong>实例数据</strong>：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息；</li>
<li><strong>对齐填充</strong>：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</li>
</ul>
<h3 id="3、对象头"><a href="#3、对象头" class="headerlink" title="3、对象头"></a>3、对象头</h3><p>对象头主要包括两部分数据：Mark Word（标记字段）、Class Pointer（类型指针）。</p>
<img src="/posts/2730732825/image-20231113171451325.png" class="" title="image-20231113171451325">

<ul>
<li><strong>Mark Word</strong> : 用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。</li>
<li><strong>Class Pointer</strong>:是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
</ul>
<h3 id="4、Mark-word"><a href="#4、Mark-word" class="headerlink" title="4、Mark word"></a>4、Mark word</h3><p>Mark Word 用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。</p>
<p>在32位的 HotSpot 虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间里的25位用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，表示非偏向锁。</p>
<p>其他状态如下图所示：</p>
<img src="/posts/2730732825/image-20231113172402673.png" class="" title="image-20231113172402673">

<h2 id="9、锁的状态"><a href="#9、锁的状态" class="headerlink" title="9、锁的状态"></a>9、锁的状态</h2><blockquote>
<p>当前状态下 MarkWord 会记录的内容：</p>
</blockquote>
<p><strong>无锁状态</strong></p>
<ul>
<li>对象的Hashcode、分代年龄、是否偏向锁、锁标志位</li>
</ul>
<p><strong>偏向锁状态</strong></p>
<ul>
<li>线程ID、Epoch(偏向锁的时间戳)、分代年龄、是否偏向锁、锁标志位</li>
</ul>
<p><strong>轻量级状态</strong></p>
<ul>
<li>指向栈中锁记录的指针、锁标志位</li>
</ul>
<p><strong>重量级锁状态</strong></p>
<ul>
<li>指向重量级锁的指针、锁标志位</li>
</ul>
<p>三种锁：偏向锁、轻量级锁、重量级锁</p>
<h3 id="1、偏向锁"><a href="#1、偏向锁" class="headerlink" title="1、偏向锁"></a>1、偏向锁</h3><p>适用于只有一个线程访问同步块的场景。</p>
<img src="/posts/2730732825/image-20231016192452104.png" class="" title="image-20231016192452104">

<p><strong>锁的重入</strong>：</p>
<p>是锁的功能，锁是否支持可重入。</p>
<img src="/posts/2730732825/image-20231016192811289.png" class="" title="image-20231016192811289">



<h3 id="2、轻量级锁"><a href="#2、轻量级锁" class="headerlink" title="2、轻量级锁"></a>2、轻量级锁</h3><p>每个线程都会创建锁记录(Lock Record)对象，每个线程都会包括一个锁记录的结构。</p>
<p>Lock Record：存储来自于 MarkWord 中的数据；</p>
<p>CAS：Compare And Swap(乐观锁的机制)。</p>
<ul>
<li>CAS操作 MarkWord 成功，表示线程1获取到同步块的锁</li>
<li>CAS操作 MarkWord 失败，表示有竞争，锁被别的线程获取到了</li>
<li>失败的时候，线程1 就自旋来等待获取锁</li>
</ul>
<p><strong>自旋锁</strong></p>
<ul>
<li>让一个线程执行一个无意义的循环，自旋就是消耗CPU的时间，</li>
<li>目的就是为了等待自旋结束之后，重新去竞争锁。</li>
</ul>
<blockquote>
<p>JVM虚拟机 对锁的选择</p>
</blockquote>
<p>先从 偏向锁—–&gt;升级为 轻量级锁 ——–&gt; 最终为重量级锁</p>
<h3 id="3、重量级锁"><a href="#3、重量级锁" class="headerlink" title="3、重量级锁"></a>3、重量级锁</h3><p>monitor 机制就是重量级锁的实现。</p>
<h3 id="4、对比"><a href="#4、对比" class="headerlink" title="4、对比"></a>4、对比</h3><img src="/posts/2730732825/image-20231016204959258.png" class="" title="image-20231016204959258">

<ul>
<li>重量级锁：消耗的是 操作系统的 互斥量。</li>
</ul>
<p><code>synchronized 关键字具体使用哪一种锁，是由虚拟机来控制的，首先使用 偏向锁，然后依次升级</code></p>
<h2 id="10、锁的使用流程"><a href="#10、锁的使用流程" class="headerlink" title="10、锁的使用流程"></a>10、锁的使用流程</h2><p><strong>偏向锁</strong></p>
<img src="/posts/2730732825/image-20231016210328900.png" class="" title="image-20231016210328900">

<p><strong>轻量级锁</strong></p>
<img src="/posts/2730732825/image-20231016211446669.png" class="" title="image-20231016211446669">

<p><strong>重量级锁</strong></p>
<h2 id="11、锁重入、自旋、死锁和synchronized"><a href="#11、锁重入、自旋、死锁和synchronized" class="headerlink" title="11、锁重入、自旋、死锁和synchronized"></a>11、锁重入、自旋、死锁和synchronized</h2><blockquote>
<p>代码演示</p>
</blockquote>
<h2 id="12、wait、notify，notifyAll"><a href="#12、wait、notify，notifyAll" class="headerlink" title="12、wait、notify，notifyAll"></a>12、wait、notify，notifyAll</h2><ol>
<li>wait、notify 机制是在 java 的 Object 对象里面的。</li>
<li>wait：就是让当前线程释放锁，保存运行状态，然后进入等待状态。</li>
<li>notify：就是唤醒当前处于等待状态的一个线程。</li>
<li>notifyAll：就是唤醒当前所有处于等待状态的线程。</li>
<li>wait：线程被唤醒过后，是需要先恢复到前面 wait 的时候 所保存的状态，然后接着向下运行，而不是重新运行。</li>
</ol>
<blockquote>
<p>小结：</p>
</blockquote>
<ol>
<li>wait、notify/notifyAll 必须放到同步块或者同步方法里面去执行。</li>
<li>一定要注意，应该用锁的对象来调用 wait、notify/notifyAll。</li>
<li>底层是使用的 Monitor 机制，wait 过后进入 monitor 对象对应的 _WaitSet 队列中。</li>
<li>调用 wait 方法后，就会释放锁。</li>
<li>调用notify /notifyAll方法后，并不会立即获得锁，等待CUP的轮转。</li>
</ol>
<h2 id="13、生产者消费者模型"><a href="#13、生产者消费者模型" class="headerlink" title="13、生产者消费者模型"></a>13、生产者消费者模型</h2><h2 id="14、wait、notify机制实现生产者和消费者"><a href="#14、wait、notify机制实现生产者和消费者" class="headerlink" title="14、wait、notify机制实现生产者和消费者"></a>14、wait、notify机制实现生产者和消费者</h2><h2 id="15、JMM：Java内存模型"><a href="#15、JMM：Java内存模型" class="headerlink" title="15、JMM：Java内存模型"></a>15、JMM：Java内存模型</h2><p>JCP定义了一种Java内存模型，以前是在JVM规范中，后来独立出来成为JSR-133(Java内存模型和线程规范修订)</p>
<p><strong>内存模型</strong>：在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。</p>
<p>Java内存模型主要关注JVM中把变量值存储到内存和从内存中取出变量值这样的底层细节。</p>
<img src="/posts/2730732825/image-20231018103016246.png" class="" title="image-20231018103016246">

<p><strong>Java内存模型</strong></p>
<ul>
<li>Java中<code>所有变量都存储在主内存中</code>，对所有的线程都是共享的。</li>
<li>每个线程都有自己的工作内存，工作内存中保存该线程使用到的变量是主内存变量的拷贝。</li>
<li>线程对变量的所有操作（读、写）都应该在工作内存中完成。 </li>
<li>不同线程不能相互访问工作内存，交互数据要通过主内存来完成。</li>
</ul>
<p><strong>内存间的交互操作</strong></p>
<p>Java内存模型规定了一些操作来实现内存间交互，JVM会保证它们是原子的 </p>
<ul>
<li><p>lock：锁定，把变量标识为线程独占，作用于主内存变量。</p>
</li>
<li><p>unlock：解锁，把锁定的变量释放，别的线程才能使用，作用于主内存变量。</p>
</li>
<li><p>read：读取，把变量值从主内存读取到工作内存。 </p>
</li>
<li><p>load：载入，把read读取到的值放入工作内存的变量副本中。</p>
</li>
<li><p>use：使用，把工作内存中一个变量的值传递给执行引擎 。</p>
</li>
<li><p>assign：赋值，把从执行引擎接收到的值赋给工作内存里面的变量。 </p>
</li>
<li><p>store：存储，把工作内存中一个变量的值传递到主内存中 。</p>
</li>
<li><p>write：写入，把 store 进来的数据存放入主内存的变量中。</p>
</li>
</ul>
<img src="/posts/2730732825/image-20231017201414205.png" class="" title="image-20231017201414205">

<p><strong>内存间交互操作的规则</strong></p>
<ul>
<li>不允许 read 和 load、store 和 write 操作之一单独出现，以上两个操作必须按顺序执行，但不保证连续执行，也就是说，read 与 load 之间、store 与 write 之间是可插入其他指令的。</li>
<li>不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因的(没有发生过任何assign操作)把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化的变量，也就是对一个变量实施 use和store操作之前，必须先执行过了load和assign操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其执行lock操作， 但lock操作可以被同一个条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load。</li>
<li>如果一个变量没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不能 unlock 一个被其他线程锁定的变量。</li>
<li>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存（执行store和write操作）。</li>
</ul>
<h2 id="16、并发编程三大特性"><a href="#16、并发编程三大特性" class="headerlink" title="16、并发编程三大特性"></a>16、并发编程三大特性</h2><h3 id="1、原子性"><a href="#1、原子性" class="headerlink" title="1、原子性"></a>1、原子性</h3><p>就是把一个或多个操作看成是一个原子操作，在 CPU 执行过程中，不会被中断，这样的特性就称为<code>原子性</code>。</p>
<ol>
<li>是对多线程而言的，对于单线程，原子性没有意义。</li>
<li>主要针对的、或者说要保护的是临界资源，是对临界资源的操作，尤其是写操作。</li>
<li>原子操作，不可分割。</li>
</ol>
<h3 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h3><p>一个线程对临界资源 (共享变量)的修改，另一个线程能够立即看到。</p>
<h3 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h3><p>在Java 程序中</p>
<p>1、一个线程内部，所有操作都可以视为是有序的(保证单线程内，串行语义执行的一致性)。</p>
<p>2、如果是多线程环境下，从一个线程去观察另外一个线程，所有操作都是无序的(指令重排现象，也有可能是工作内存和主内存同步延迟的现象)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2023/11/1 15:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 双重检查锁的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 这个地方要用 volatile 修饰，否则可能会发生指令重排。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>new 一个对象的基本步骤：</p>
</blockquote>
<ol>
<li>分配内存空间。</li>
<li>初始化实例对象，主要是初始化实例对象属性的值</li>
<li>设置内存空间地址给变量</li>
</ol>
<h2 id="17、理解重排序"><a href="#17、理解重排序" class="headerlink" title="17、理解重排序"></a>17、理解重排序</h2><p>重排序：编译器或者处理器为了优化程序的性能，对指令得等执行顺序进行重新排列的一种手段。</p>
<p>目的：为了优化程序的执行性能。</p>
<p>重排序的分类：</p>
<ol>
<li>编译器优化的重排序</li>
<li>指令级并行的重排序</li>
<li>内存系统的重排序 </li>
</ol>
<img src="/posts/2730732825/image-20231101154417158.png" class="" title="image-20231101154417158">

<p>一、<code>编译器优化的重排序</code>：编译器在不改变程序在单线环境下运行的语前提下，可以重新安排语句的执行顺序。</p>
<p>目的：尽可能减少寄存器的读取，存储次数，复用寄存器存储的数据。</p>
<p>二、<code>指令级并行的重排序</code>：处理器将多条指令并行执行，如果不存在数据依赖处理器可以改变语句对应的指令的执行顺序。</p>
<p>三、<code>内存系统的重排序</code>：处理器使用缓存和读写缓冲区，使得数据的加载、存储操作，看上去是乱序执行的。</p>
<p><code>并发编程里面的一个重要原则: 不要假设指令执行的顺序</code>。</p>
<p>数据依赖：如果两个操作访问同一个共享变量，而且，这两个操作里面有一个为写操作，那么这两个操作之间就存在数据依赖性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b=a+<span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>数据依赖的分类：</p>
<ol>
<li><p>读后写：读一个变量过后，再写一个变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=b;</span><br><span class="line">b=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>写后写：写一个变量过后，再写一个变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">5</span>;</span><br><span class="line">a=<span class="number">6</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>写后读：写一个变量过后，再读这个变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">5</span>;</span><br><span class="line">b=a;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>具有数据依赖性的指令是不会被重排的。</p>
<p><code>as-if-serial 语义</code></p>
<ul>
<li>不管有没有重排序，也不关心如何进行的重排序，单线程环境下，程序的执行结果不会被改变。</li>
</ul>
<h2 id="18、理解-happens-before"><a href="#18、理解-happens-before" class="headerlink" title="18、理解 happens-before"></a>18、理解 happens-before</h2><p>JMM happens-before: 用来保障两个操作之间的可见性。</p>
<p><strong>说明</strong>：这里的两个操作，既可以在一个线程，也可以在不同的线程之间。</p>
<p><strong>具体定义：</strong></p>
<ol>
<li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果，将对第二个操作可见。(保障可见性)。而且第一个操作的执行顺序排在第二个操作之前。(JMM 对程序员做出的一个逻辑保障，并不是代码指令真正的执行保障)。</li>
<li>即使两个操作之间存在 happens-before 关系，并不意味着 Java 平台的实现必须要按照 happens-before 关系指定的顺序来执行。</li>
</ol>
<p><strong>因此</strong>，第一条是 JMM 对程序员做出的一个逻辑保障。第二条是 JMM 对编译器、处理器进行重排序的约束原则。</p>
<p> 程序的执行结果(不管是多线程还是单线程)，编译期，处理器怎么优化都可以。</p>
<p><strong>happens-before 规则</strong></p>
<ol>
<li>程序顺序规则：一个线程中的每个操作 happens-before 该线程中任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁操作 happens-before 随后对这个锁的加锁。</li>
<li>volatile 变量规则：对一个 volatile 修饰的字段进行的写操作 happens-before 任意后续对这个 volatile 修饰的字段进行的读操作。</li>
<li>传递性规则</li>
<li>start 规则：如果在线程 A 里面去执行了线程 B 的 start，那么在线程 A 里面的 B start 操作 happens-before 线程B中的意操作。</li>
<li>join 规则：如果线程A执行了线程 B join()，那么 线程B中的任意操作 happens-before 线程A执行了线程B Join()之后的操作。</li>
</ol>
<h2 id="19、理解内存屏障"><a href="#19、理解内存屏障" class="headerlink" title="19、理解内存屏障"></a>19、理解内存屏障</h2><p><strong>什么是内存屏障：</strong></p>
<p>内存屏障：是一种 屏障指令，它使得 CPU 或编译器对屏障指令的前和后所发出的内存操作 执行一个排序的约束，也叫内存栅栏 或 栅栏指令。</p>
<p><strong>内存屏障的目的：</strong></p>
<p>每个CPU都会有自己的缓存（有的甚至L1，L2，L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同</p>
<p><strong>内存屏障的能力:</strong></p>
<ol>
<li>阻止屏障两边的指令重排序。</li>
<li>写数据的时候加了屏障的话，强制把写缓冲区的数据刷回到主内存中。</li>
<li>读数据的时候加了屏障的话，让工作内存/CPU 高速缓存当中缓存的数据失效，重新到主内存中获取新的数据</li>
</ol>
<p><strong>基本分类:</strong></p>
<ol>
<li>读屏障：Load Barrier，在读指令之前插入读屏障，让工作内存/CPU 高速缓存当中缓存的数据失效，重新到主内存中获取新的数据</li>
<li>写屏障：Store Barrier，在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中。</li>
</ol>
<p><strong>重排序和内存屏障</strong></p>
<ol>
<li>重排序可能会给程序带来问题，因此，有些时候，我们希望告诉JVM，这里不需要排序。</li>
<li>对于编译器的重排序，JMM 会根据重排序的规则，禁止特定类型的编译器重排序。</li>
<li>对于处理器的重排序，Java 编译器在生成指令序列的 适当位置，插入内存屏障指令，来禁止特定类型的处理器排序。</li>
</ol>
<p><strong>JMM中的内存屏障：</strong></p>
<p>内存屏障可以被分为以下几种类型:</p>
<p>LoadLoad Barriers ：Load1;LoadLoad; Load2</p>
<ul>
<li>在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
</ul>
<p>LoadStore Barriers：Load1;LoadStore; Store2。</p>
<ul>
<li>在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
</ul>
<p>StoreStore Barriers：Store1;StoreStore;Store2。</p>
<ul>
<li>在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
</ul>
<p>StoreLoad Barriers：Store1;StoreLoad; Load2。</p>
<ul>
<li>在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li>
<li>它的开销是四种屏障中最大的(跟内存交互次数多，交互延迟较大，消耗资源较多)。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li>
</ul>
<p>这些内存屏障指令，在不同的硬件平台上，可能会做一些优化，从而只支持部分的JMM 的内存屏障指令。</p>
<p>在x86机器上，就只有 StoreLoadBarriers 是有效的，其它的都不支持，被替换成nop，也就是空操作。</p>
<h2 id="20、volatile关键字使用"><a href="#20、volatile关键字使用" class="headerlink" title="20、volatile关键字使用"></a>20、volatile关键字使用</h2><p>volatile关键字在JVM中，相当于是一种轻量级同步机制。</p>
<p>volatile修饰的变量，有如下特点:</p>
<ol>
<li>保证可见性。</li>
<li><code>不保证原子性。</code></li>
<li>禁止指令重排。</li>
</ol>
<p>Volatile 关键字保证可见性，意味着 :</p>
<ol>
<li>对一个 volatile 修饰的变量进行读操作的话，总是能够读到这个变量的最新的值，也就是这个变量最后被修改的值。</li>
<li>一个线程修改了 volatile 修饰的变量的值的时候，那么这个变量的新的值，会立即刷新回到主内存中。</li>
<li>一个线程去读取 volatile 修饰的变量的值的时候，该变量在工作内存中的数据无效，需要重新到主内存去读取最新的数据。</li>
</ol>
<p><code>volatile关键字的典型使用场景</code></p>
<ul>
<li>多个线程间的状态通信，比如:一个线程要等待另一个线程去完成一定的工作过后，这个线程才能开始工作。</li>
</ul>
<h2 id="21、volatile-关键字的实现原理"><a href="#21、volatile-关键字的实现原理" class="headerlink" title="21、volatile 关键字的实现原理"></a>21、volatile 关键字的实现原理</h2><h3 id="1、被volatile修饰的变量，具有如下特性。"><a href="#1、被volatile修饰的变量，具有如下特性。" class="headerlink" title="1、被volatile修饰的变量，具有如下特性。"></a>1、被volatile修饰的变量，具有如下特性。</h3><blockquote>
<p>1、Volatile 关键字保证可见性，意味着 :</p>
</blockquote>
<ol>
<li>对一个 volatile 修饰的变量进行读操作的话，总是能够读到这个变量的最新的值，也就是这个变量最后被修改的值。</li>
<li>一个线程修改了 volatile 修饰的变量的值的时候，那么这个变量的新的值，会立即刷新回到主内存中。</li>
<li>一个线程去读取 volatile 修饰的变量的值的时候，该变量在工作内存中的数据无效，需要重新到主内存去读取最新的数据。</li>
</ol>
<blockquote>
<p>2、禁止指令重排</p>
</blockquote>
<p>要求维护 happens-before 的关系。</p>
<ol>
<li><p>对 volatile 变量的写入，不能重排到 <code>写入之前的操作</code> 之前</p>
<img src="/posts/2730732825/image-20231101175154552.png" class="" title="image-20231101175154552"></li>
<li><p>对 volatile 变量的读取，不能重排到 <code>读取操作的后续操作</code> 之后</p>
<img src="/posts/2730732825/image-20231101175209579.png" class="" title="image-20231101175209579"></li>
</ol>
<h3 id="2、volatile-内存语义"><a href="#2、volatile-内存语义" class="headerlink" title="2、volatile 内存语义"></a>2、volatile 内存语义</h3><p>volatile 写的内存语义 </p>
<ul>
<li>写一个 volatile 变量时，JMM 会把该线程对应的工作内存中的共享变量的值 刷新到 主内存中。</li>
</ul>
<p>volatile 读的内存语义 </p>
<ul>
<li>读一个 volatile 变量时，JMM 会把线程对应的工作内存中的共享变量数据设置为无效的，然后会从主内存中去 读取共享变量 最新的数据。</li>
</ul>
<p><strong>volatile内存语义的实现</strong></p>
<blockquote>
<p>1、字节码层面</p>
</blockquote>
<p><code>javap -v -p class文件地址</code>。</p>
<p>它影响的是 Class 内的 Field 的 flags，添加了一个 <code>ACC_VOLATILE</code>。</p>
<p>JVM 在把字节码 生成 为 机器码 的时候，发现操作是 volatile 的变量的话，就会根据JMM 要求，在相应的位置去插入 存屏障指令。</p>
<blockquote>
<p>2、JMM层面：插入内存屏障</p>
</blockquote>
<ul>
<li>volatile 写之前的操作，都禁止重排序到 volatile 之后</li>
<li>volatile 读之后的操作，都禁止重排序到 volatile 之前</li>
<li>volatile 写之后 volatile 读，禁止重排序的</li>
</ul>
<p>为了实现 volatile 内存语义，按如下方式来插入内存屏障：</p>
<ol>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障</li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障</li>
<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障</li>
</ol>
<blockquote>
<p>3、处理器层面</p>
</blockquote>
<p>cpu 执行机器码指令的时候，是使用 lock 前级指令 来实现 volatile 的功能的。</p>
<p>Lock 指令，相当于内存屏障，功能也类似内存屏障的功能:</p>
<ol>
<li>首先对总线/缓存加锁，然后去执行后面的指令，最后，释放锁，同时把高速缓存的数据刷新回到主内存。</li>
<li>在 lock 锁住总线/缓存的时候，其它 cpu 的读写请求就会被阻塞，直到锁释放。Lock过后的写操作，会让其它 cpu 的高速缓存中相应的数据失效，这样后续这些cpu 在读取数据的时候，就会从主内存去加载最新的数据。</li>
</ol>
<h2 id="22、认识lock接口和-lock-体系"><a href="#22、认识lock接口和-lock-体系" class="headerlink" title="22、认识lock接口和 lock 体系"></a>22、认识lock接口和 lock 体系</h2><h3 id="1、lock接口中的方法"><a href="#1、lock接口中的方法" class="headerlink" title="1、lock接口中的方法"></a>1、lock接口中的方法</h3><blockquote>
<p>void lock();</p>
</blockquote>
<p>获取锁：</p>
<ul>
<li><p>如果当前资源空闲可用，则获取锁资源返回。</p>
</li>
<li><p>如果当前资源不可用，则阻塞等待，不断竞争锁资源，直至获取到锁返回。</p>
</li>
</ul>
<blockquote>
<p>void unlock();</p>
</blockquote>
<p>释放锁：</p>
<ul>
<li>当前资源执行完成业务后将锁资源的状态由占用改为可用，并通知阻塞线程。</li>
</ul>
<blockquote>
<p>void lockInterruptibly() throws InterruptedException;</p>
</blockquote>
<p>获取锁：(与lock方法不同的在于可响应中断操作，即在获取锁过程中可中断)   </p>
<ul>
<li>如果当前锁资源可用则获取锁返回。     </li>
<li>如果当前锁资源不可用则阻塞直至出现如下两种情况：   <ol>
<li>当前线程获取到锁资源。</li>
<li>接收到中断命令，当前线程中断获取锁操作。</li>
</ol>
</li>
</ul>
<blockquote>
<p>boolean tryLock();</p>
</blockquote>
<p>非阻塞式获取锁：</p>
<ul>
<li>尝试非阻塞式获取锁，调用该方法获取锁立即返回获取结果。</li>
<li>如果获取到了锁则返回 true，反之返回 flase。</li>
</ul>
<blockquote>
<p>boolean tryLock(long time， TimeUnit unit) throws InterruptedException;</p>
</blockquote>
<p>非阻塞式获取锁:</p>
<ul>
<li>根据传入的时间获取锁，如果线程在该时间段内未获取到锁返回 flase。</li>
<li>如果当前线程在该时间段内获取到了锁并未被中断则返回true。</li>
</ul>
<blockquote>
<p>Condition newCondition();</p>
</blockquote>
<p>获取等待通知组件（该组件与当前锁资源绑定）：</p>
<ul>
<li>当前线程只有获取到了锁资源之后才能调用该组件的wait()方法，</li>
<li>当前线程调用await()方法后，当前线程将会释放锁。</li>
</ul>
<h3 id="2、lock体系"><a href="#2、lock体系" class="headerlink" title="2、lock体系"></a>2、lock体系</h3><p>package java.util.concurrent.locks; 包下：</p>
<ul>
<li>ReentrantLock：可重入锁</li>
<li>ReentrantReadWriteLock：可重入读写锁</li>
<li>StampedLock：读写锁的改进版本</li>
<li>Condition</li>
<li>LockSupport</li>
<li>AbstractQueuedSynchronizer =  AQS</li>
<li>AbstractQueuedLongSynchronizer</li>
</ul>
<h3 id="3、Lock-和-Synchronized区别"><a href="#3、Lock-和-Synchronized区别" class="headerlink" title="3、Lock 和 Synchronized区别"></a>3、Lock 和 Synchronized区别</h3><ol>
<li>synchronized 是 Java 的关键字，是JVM 层面，内置功能和实现；Lock 是一个接口，是代码层面的实现。</li>
<li>synchronized 可以隐式的获取、释放锁， 更简洁；lock 是显示的来获取、释放锁 ，代码上稍微麻烦一些，但更灵活。</li>
<li>synchronized 在发生异常的时候，会自动释放锁；lock 在发生异常的时候，不会自动释放锁，必须要调用 unlock 方法才会释放锁，否则会发生死锁。</li>
<li>Lock 可以尝试非阻塞获取锁、可中断获取锁、超时获取锁，这么几种强大的功能，synchronized 都没有。</li>
</ol>
<h2 id="23、LockSupport使用"><a href="#23、LockSupport使用" class="headerlink" title="23、LockSupport使用"></a>23、LockSupport使用</h2><p><strong>认识LockSupport</strong></p>
<p>LockSupport 是编程的工具类，主要是实现线程的<code>阻塞</code>(park)和<code>唤醒</code>(unpark)。</p>
<p>设计原理的核心：<code>许可</code></p>
<ul>
<li>park：挂起当前线程，等待一个许可</li>
<li>unpark：为某个线程提供一个许可，唤醒指定的线程。</li>
</ul>
<p>和 wait/notify 很类似，park/unpark 具有这样的优点:</p>
<ol>
<li><p>park/unpark 是以 thread 为操作对象， 语义更直观</p>
</li>
<li><p>操作更为精准、灵活，可以准确的去唤醒某一个线程</p>
</li>
<li><p>wait/notify 和 synchronized 联系在一起的，wait 过后，线程是进入 Blocked 状态;park 方法使当前线程挂起，进入到 waiting 状态。</p>
</li>
</ol>
<h2 id="24、理解CAS"><a href="#24、理解CAS" class="headerlink" title="24、理解CAS"></a>24、理解CAS</h2><p>乐观派：无锁 —-&gt; CAS</p>
<p>悲观派：有锁—–&gt; Synchronized(悲观锁) </p>
<p><strong>CAS</strong>：Compare And Swap 比较并替换</p>
<p><strong>基本的实现方式</strong></p>
<p>1、CAS 中有3个基本的操作数: V-内存地址的值，A-旧的预期的值，B-要修改的新的值。</p>
<p>2、CAS方式去更新一个变量的时候，只有变量的旧的预期的值A 跟 内存地址的值V 相同的时候，才会将 V 修改成为要修改的新的值 B。</p>
<h2 id="25、认识-AQS"><a href="#25、认识-AQS" class="headerlink" title="25、认识 AQS"></a>25、认识 AQS</h2><p><strong>1、AQS 是什么</strong></p>
<p><code>AQS</code>(AbstractQueuedSynchronizer):是构建锁和其他同步组件的 基础框架。</p>
<p>AQS：就是各种锁、同步组件实现的  公共基础部分的 抽象 实现。</p>
<p><strong>2、AQS能干什么</strong></p>
<ul>
<li>同步队列的管理和维护</li>
<li>同步状态的管理</li>
<li>线程的阻塞和唤醒的管理</li>
</ul>
<p><code>独占锁</code>：也叫互斥锁、或者 排他锁，就是一个线程获得了锁，那么其它想要获取这把锁的线程就得等待。</p>
<p><code>共享锁</code>：是可以有多个线程来获取同一把锁，典型的如：读写锁里面的读锁。</p>
<p><strong>3、AQS 基本的设计思路</strong></p>
<p>1、把来竞争的线程 及其 等待状态，封装成为 Node 对象。</p>
<p>2、把这些 Node，放到一个同步队列中去，这个同步队列是一个 FIFO 的一个双向队列，又是 基于CLH 队列来实现的。</p>
<img src="/posts/2730732825/image-20231109161847110.png" class="" title="image-20231109161847110">

<p>3、使用一个 int state 来表示同步状态，比如;是否有线程获得锁，锁的重入次数等等。具体的含义由具体的子类来实现，修改同步状态成功即为获得锁，修改 state 值时通过 CAS 机制来保证修改的原子性。</p>
<p>4、至于线程的唤醒和阻塞，伴随着同步队列的维护，使用 LockSupport 来实现对线程的唤醒和阻塞。</p>
<p><strong>4、如何把AQS的基础功能提供出去呢？</strong></p>
<ul>
<li>AQS使用<code>模板方法模式</code>来实现的。</li>
<li>钩子方法。</li>
</ul>
<p>引申出两个问题：</p>
<p><strong>5、AQS可重写的方法</strong></p>
<ol>
<li><p><code>protected boolean tryAcquire(int arg)</code> ：尝试获取独占锁，获取成功返回 true，失败返回false</p>
</li>
<li><p><code>protected boolean tryRelease(int arg)</code>：尝试释放独占锁，释放成功返回true，失败返回false</p>
</li>
<li><p><code>protected int tryAcquireShared(int arg)</code>：尝试以共享方式获取锁，失败返回负数，只能获取一次返回0，否则返回个数</p>
</li>
<li><p><code>protected boolean tryReleaseShared(int arg)</code>：尝试释放共享锁，释放成功返回true，失败返回false</p>
</li>
<li><p><code>protected boolean isHeldExclusively()</code>:判断线程是否独占资源。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/index.html">Overview (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://doc.qzxdp.cn/jdk/17/zh/api/index.html">https://doc.qzxdp.cn/jdk/17/zh/api/index.html</a></p>
<p><strong>6、AQS 提供的其他方法。</strong></p>
<ol>
<li><p><code>void acquire(int arg)</code>：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用重写的 tyAcquire(int arg)方法</p>
</li>
<li><p><code>void acquirelnterruptibly(int arg)</code>：与acquire(int arg)相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException 并返回。</p>
</li>
<li><p><code>boolean tryAcquireNanos(int arg， long nanos)</code>：在 acquireInterruptibly(int arg)基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，那么将会返回 false，如果获取到了返回 true。</p>
</li>
<li><p><code>void acquireShared(int arg)</code>：共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态。</p>
</li>
<li><p><code>void acquireSharedInterruptibly(int arg)</code>：与acquireShared(int arg)相同，该方法响应中断。</p>
</li>
<li><p><code>boolean tryAcquireSharedNanos(intarg，long nanos)</code>：在acquireSharedInterruptibly(int arg)基础上增加了超时限制。</p>
</li>
<li><p><code>boolean release(int arg)</code>：独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中第个节点包含的线程唤醒。</p>
</li>
<li><p><code>boolean releaseShared(int arg)</code>：共享式的释放同步状态。</p>
</li>
<li><p><code>Collection&lt;Thread&gt; getQueuedThreads()</code>：获取等待在同步队列上的线程集合。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903601538596877">AQS 使用原理</a></p>
<h2 id="26、使用-AQS-来实现锁"><a href="#26、使用-AQS-来实现锁" class="headerlink" title="26、使用 AQS 来实现锁"></a>26、使用 AQS 来实现锁</h2><p>1、锁</p>
<p>2、可重入锁</p>
<p>3、独占锁</p>
<p><code>可重入锁和共享锁的区别</code></p>
<p>可重入锁（也称为重入锁）和共享锁是两个不同的概念。</p>
<p>可重入锁是指当一个线程获取了锁之后，可以再次获取相同的锁而不会产生死锁。这种锁允许同一个线程多次获取锁，并且每次获取锁都必须释放相同次数的锁。这种机制可以防止同一个线程在嵌套调用中因为锁的获取而造成死锁。</p>
<p>共享锁是指多个线程可以同时获取相同的锁。这种锁允许多个线程并发地执行特定的代码块，提供了一种并发执行的机制。多个线程可以同时持有共享锁，并且不会相互阻塞。只有当没有任何线程持有共享锁时，其他线程才能获取该锁。</p>
<p>因此，可重入锁关注的是同一个线程是否可以重复获取锁，而共享锁关注的是是否允许多个线程同时获取相同的锁。</p>
<h2 id="27、AQS-源码解析"><a href="#27、AQS-源码解析" class="headerlink" title="27、AQS 源码解析"></a>27、AQS 源码解析</h2><h2 id="28、ReentrantLock"><a href="#28、ReentrantLock" class="headerlink" title="28、ReentrantLock"></a>28、ReentrantLock</h2><p>1、认识 ReentrantLock</p>
<ul>
<li>是 Lock 接口的一个实现</li>
<li>主要实现了 可重入 的 独占锁 的功能</li>
<li>类似与 synchronized 关键字的功能</li>
</ul>
<p>2、ReentrantLock 和 synchronized 对比</p>
<p>ReentrantLock 功能更强大，使用更为灵活</p>
<ol>
<li>可尝试非中断的获取锁</li>
<li>可中断式的获取锁</li>
<li>超时 获取锁</li>
<li>公平锁和非公平锁</li>
</ol>
<p>3、公平锁 和 非公平锁</p>
<p>主要体现在:获取锁的方式上</p>
<ul>
<li>公平锁:是多个线程按照申请获取锁的 时间先后 顺序 来获取锁</li>
<li>非公平锁: 是多个线程按照申请获取锁的顺序不是按照时间先后来获取锁。</li>
</ul>
<h2 id="29、ReentrantReadWriteLock"><a href="#29、ReentrantReadWriteLock" class="headerlink" title="29、ReentrantReadWriteLock"></a>29、ReentrantReadWriteLock</h2><p>1、读锁 和 写锁</p>
<ul>
<li><p>读锁：用在读取数据的地方</p>
</li>
<li><p>写锁：用在更新数据的地方</p>
</li>
<li><p>数据：这里的数据是 临界资源</p>
</li>
</ul>
<p>读锁、写锁的互斥规则</p>
<ol>
<li>读-读：共享，意味着他们都可以拿到锁，也就是共享锁。</li>
<li>读-写：互斥</li>
<li>写-读：互斥</li>
<li>写-写：互斥</li>
</ol>
<p>提升的是 读-读 这种场景的性能。</p>
<p>2、认识 ReentrantReadWriteLock 类</p>
<p>读写锁 ReadWriteLock 的实现类.</p>
<ol>
<li>支持读锁 和 写锁</li>
<li>支持 公平锁 和非公平锁</li>
<li>支持可重入</li>
<li>支持锁降级<ul>
<li>锁降级：写锁的降级成为读锁。</li>
<li>如果一个线程持有写锁，在不释放写锁的情况下，它还可以继续持有读锁，这就是 写锁的降级。这里指定是同一个线程。</li>
<li>规则遵循：先获取写锁，然后获取读锁，在释放写锁的 次序。</li>
<li>如果完全释放了写锁，那么就完全转换为读锁。</li>
</ul>
</li>
<li><code>不支持锁升级</code>。</li>
</ol>
<h2 id="30、ReentrantReadWriteLock-源码"><a href="#30、ReentrantReadWriteLock-源码" class="headerlink" title="30、ReentrantReadWriteLock 源码"></a>30、ReentrantReadWriteLock 源码</h2><p>读写锁状态的存储机制：</p>
<p>AQS 里面的 state 是一个 int 值。</p>
<p>可是现在需要保存哪些状态？</p>
<ol>
<li>写锁的重入次数。</li>
<li>读锁的个数。</li>
<li>每个读锁重入的次数。</li>
</ol>
<blockquote>
<p>解决办法？</p>
</blockquote>
<p>int state =32 位，表示成二进制，前面 16位表示读锁的个数，后面16位表示写锁的同步状态。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1的表示 </span><br><span class="line"><span class="code">	0000 0000 0000 0000 0000 0000 0000 0001</span></span><br><span class="line"><span class="code">1 左移 16 位（2^16=65536）</span></span><br><span class="line"><span class="code">	0000 0000 0000 0001 0000 0000 0000 0000</span></span><br><span class="line"><span class="code">(1&lt;&lt;16)-1</span></span><br><span class="line"><span class="code">	0000 0000 0000 0000 1111 1111 1111 1111</span></span><br><span class="line"><span class="code">(65536&gt;&gt;16)</span></span><br><span class="line"><span class="code">	0000 0000 0000 0000 0000 0000 0000 0001</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>





<h2 id="31、StampedLock使用"><a href="#31、StampedLock使用" class="headerlink" title="31、StampedLock使用"></a>31、StampedLock使用</h2><p>1、在 RenentrantReadWritelock里面，存在的问题：</p>
<ol>
<li>写线程的 <code>饥饿</code>问题。</li>
<li>如果有线程在读，那么写线程是无法获取写锁的，是一种悲观锁的策略。</li>
</ol>
<p>java8 引入 StampedLock：</p>
<p>对 RRWLock 进行增强，优化了读锁、写锁的访问，使读写锁之间可以相互转换，因此可以更细粒度的控制并发。</p>
<p>2、StampedLock 明显的问题</p>
<ol>
<li>设计初衷：是作为一个内部工具类，用于辅助开发其它的线程安全组件。用不好：容易产生死锁，甚至莫名其妙的问题。</li>
<li>不支持重入，在实际使用过程中，场景非常受限。</li>
</ol>
<p>3、特点</p>
<ol>
<li>所有获取锁的方法，都会返回一个 stamp。</li>
<li>所有释放锁的方法，都需要一个 stamp。</li>
<li>是不可重入的。</li>
<li>有三中访问方式<ul>
<li>reading 读模式：</li>
<li>writing 写模式：</li>
<li>optimistic reading 乐观读模式。</li>
</ul>
</li>
</ol>
<h2 id="32、Condition-理解使用"><a href="#32、Condition-理解使用" class="headerlink" title="32、Condition 理解使用"></a>32、Condition 理解使用</h2><p>1、Condition 接口：</p>
<p>位于 JUC 包下，用来对原生的 wait、notify/notifyAll 这些方法进行增强。</p>
<p>2、使用 condition 实现生产者和消费者</p>
<h2 id="33、Condition-源码解析"><a href="#33、Condition-源码解析" class="headerlink" title="33、Condition 源码解析"></a>33、Condition 源码解析</h2><p>AQS 中 的是等待队列。</p>
<p>Condition 中的是条件队列，使用AQS的独占锁来实现的。</p>
<ul>
<li>主要是 控制什么时候 进行 await/single</li>
<li>包含两个节点： Node firstWaiter; Node lastWaiter;</li>
<li></li>
</ul>
<h2 id="34、ThreadLocal-使用和源码解析"><a href="#34、ThreadLocal-使用和源码解析" class="headerlink" title="34、ThreadLocal 使用和源码解析"></a>34、ThreadLocal 使用和源码解析</h2><p>ThreadLocal：用来存放线程自身相关的数据的这么一个容器</p>
<p>提供线程本地变量，那么访问这个变量的每个线程都会有这个变量的一个副本线程操作数据的时候，就是操作的线程本地的数据，自然是线程安全的。</p>
<h2 id="35、并发容器-CopyOnWriteArrayList-使用"><a href="#35、并发容器-CopyOnWriteArrayList-使用" class="headerlink" title="35、并发容器 CopyOnWriteArrayList 使用"></a>35、并发容器 CopyOnWriteArrayList 使用</h2><h3 id="1、同步容器"><a href="#1、同步容器" class="headerlink" title="1、同步容器"></a>1、同步容器</h3><p>vector、stack、hashtable</p>
<ul>
<li>vector 是 list 接口的线程安全实现，ArrayList 是线程不安全的</li>
<li>Stack 是 Vector 的子类，是一个先进后出的栈，入栈和出栈方法都是同步的</li>
<li>hashtable 是 Map 接口的线程安全实现，HashMap 是线程不安全的</li>
</ul>
<blockquote>
<p>同步容器</p>
</blockquote>
<p>就把这些通过 synchronized 关键字来实现线程安全的容器，称为同步容器。</p>
<p>还有一种：就是通过 Collections 这个工具类的 synchronizedXXX 方法创建的容器，也是同步容器。</p>
<h3 id="2、并发容器"><a href="#2、并发容器" class="headerlink" title="2、并发容器"></a>2、并发容器</h3><p>同步容器的性能比较差。</p>
<p>并发容器:允许多线程同时使用容器，并能报称线程安全 的 容器实现。</p>
<h3 id="3、有哪些并发容器"><a href="#3、有哪些并发容器" class="headerlink" title="3、有哪些并发容器"></a>3、有哪些并发容器</h3><p>两个接口：</p>
<ul>
<li>ConcurrentMap</li>
<li>BlockingQueue</li>
</ul>
<p>主要的实现：<br>1、 CopyOnWrite 容器</p>
<ul>
<li>CopyOnWriteArrayList</li>
<li>CopyOnWriteArraySet</li>
</ul>
<p>2、ConcurrentMap 的实现类</p>
<ul>
<li>ConcurrentHashMap</li>
<li>ConcurrentSkipListMap：支持排序</li>
</ul>
<p>3、阻塞队列的实现</p>
<ul>
<li>ArrayBlockingQueue：使用数组实现的有界阻塞队列</li>
<li>LinkedBlockingQueue：使用链表实现的有界阻塞队列</li>
<li>PriorityBlockingQueue：支持优先级的无界阻塞队列</li>
<li>DelatQueue：持延时获取元素的无界阻塞队列</li>
<li>SyncronousQueue：不存储元素的阻塞队列</li>
<li>LinkedTransferQueue：使用链表实现的无界阻塞队列</li>
<li>LinkedBlockingDeque：使用链表实现的双向阻塞队列</li>
</ul>
<p> 4、非阻塞的</p>
<ul>
<li>ConcurrentLinkedQueue：使用链表实现的无界 非阻塞 队列，用CAS 的方式来保证线程安全。</li>
<li>ConcurrentLinkedDeque： 使用链表实现的双向 非阻塞队列</li>
</ul>
<h3 id="4、CopyOnWriteArrayList"><a href="#4、CopyOnWriteArrayList" class="headerlink" title="4、CopyOnWriteArrayList"></a>4、CopyOnWriteArrayList</h3><p>1、概述</p>
<p>2、使用</p>
<h3 id="5、CopyOnWriteArrayList基本的设计思想"><a href="#5、CopyOnWriteArrayList基本的设计思想" class="headerlink" title="5、CopyOnWriteArrayList基本的设计思想"></a>5、CopyOnWriteArrayList基本的设计思想</h3><p>内部还是使用数组来存放数据</p>
<p>CopyOnWrite ：写时复制(写的时候，再复制一份)</p>
<img src="/posts/2730732825/image-20231108172447470.png" class="" title="image-20231108172447470">

<p>写线程过来了，比如:要新加一个 5 这个元素进来。</p>
<ol>
<li>copy 原来的 数组</li>
</ol>
<img src="/posts/2730732825/image-20231108172517987-1699435519258-1.png" class="" title="image-20231108172517987">

<ol start="2">
<li>去添加上一个元素的位置，然后把新的元素放进来。 这个时候，内存里面是两个数组 <code>同时存在</code>。</li>
<li>把原来的变量指向 新的数组。</li>
</ol>
<p><code>缺点</code></p>
<ol>
<li>每次写的时候，都去 copy 一份数据出来，如果数据量比较大的话，比较耗费内存。<ul>
<li>适用场景: 读多写少</li>
</ul>
</li>
<li>数据一致性:只能保证数据最终一致，不能保证实时一致，当数据在修改的时候，读取到的数据是<code>旧</code>的值。</li>
</ol>
<h2 id="36、ConcurrentHashMap-源码分析"><a href="#36、ConcurrentHashMap-源码分析" class="headerlink" title="36、ConcurrentHashMap 源码分析"></a>36、ConcurrentHashMap 源码分析</h2><p>ConcurrentHashMap:</p>
<p>是一个实现 Map 功能的并发容器，也可以认为是一个线程安全的 HashMap，使用上，和使用集合的 Map 差不多。</p>
<p><strong>注意:</strong></p>
<ol>
<li>不同版本的JDK里面的 ConcurrentHashMap，内部实现机制是不一样的。</li>
<li>类非常大，具体实现上，应用了较多的数据结构和算法的知识，比如:链表、红黑树等。</li>
</ol>
<p>AbstractMap：</p>
<ul>
<li>实现了 Map 接口。</li>
<li>提供 Map 接口的骨干实现，减少自己实现 Map 这类数据结构所需要的工作</li>
</ul>
<p>ConcurrentMap接口:</p>
<ul>
<li>是在JDK1.5，随着J.U.C 引入的。</li>
<li>提供一些针对 Map 的原子操作。</li>
</ul>
<h2 id="37、ArrayBlockingQueue使用和源码分析"><a href="#37、ArrayBlockingQueue使用和源码分析" class="headerlink" title="37、ArrayBlockingQueue使用和源码分析"></a>37、ArrayBlockingQueue使用和源码分析</h2><h3 id="1、ArrayBlockingQueue"><a href="#1、ArrayBlockingQueue" class="headerlink" title="1、ArrayBlockingQueue:"></a>1、ArrayBlockingQueue:</h3><p>​    是BlockingQueue 接口的一个典型实现</p>
<p><strong>阻塞队列</strong>:</p>
<p>就是在并发环境下，调用队列的过程中，会根据情况去阻塞调用线程，实现这样带阻塞线程功能的队列。</p>
<p>通过“锁”来实现的，主要用在生产者-消费者 模式，用于线程建的数据交换和系统解耦。</p>
<h3 id="2、BlockingQueue-接口"><a href="#2、BlockingQueue-接口" class="headerlink" title="2、BlockingQueue 接口"></a>2、BlockingQueue 接口</h3><p>JDK1.5引入，继承了 Queue 接口，主要提供一些阻塞方法。</p>
<p>主要作用:</p>
<ol>
<li>如果线程向队列插入元素，而这个时候，队列满了，就会阻塞这个线程，直到队列有空闲.</li>
<li>如果线程从队列获取元素，而这个时候，队列为空，就会阻塞这个线程，直到队列里面有数据.</li>
</ol>
<h2 id="37、ConcurrentLinkedQueue使用和源码分析"><a href="#37、ConcurrentLinkedQueue使用和源码分析" class="headerlink" title="37、ConcurrentLinkedQueue使用和源码分析"></a>37、ConcurrentLinkedQueue使用和源码分析</h2><h2 id="38、Atomic-框架使用和源码分析"><a href="#38、Atomic-框架使用和源码分析" class="headerlink" title="38、Atomic 框架使用和源码分析"></a>38、Atomic 框架使用和源码分析</h2><p><strong>Atomic 框架包概述</strong></p>
<p>原子操作包，里面放着所有支持线程安全的原子类</p>
<h2 id="39、CountDownLatch-使用和源码分析"><a href="#39、CountDownLatch-使用和源码分析" class="headerlink" title="39、CountDownLatch 使用和源码分析"></a>39、CountDownLatch 使用和源码分析</h2><p>1、CountDownLatch 概述</p>
<ul>
<li>CountDownLatch 是一个辅助同步器类。</li>
<li>所谓同步器框架:就是用来辅助实现同步功能的一些类，统称叫做同步器框架。比如 : CountDownLatch、CyclicBarrier、Semaphore、Exchanger等。</li>
<li>CountDownLatch 是用来计数用的，类似于倒数计时器。</li>
</ul>
<h2 id="40、CyclicBarrier的使用和源码分析"><a href="#40、CyclicBarrier的使用和源码分析" class="headerlink" title="40、CyclicBarrier的使用和源码分析"></a>40、CyclicBarrier的使用和源码分析</h2><p><strong>CyclicBarrier 概述</strong></p>
<ul>
<li>是一个辅助同步器类，功能和 CountDownLatch 类似</li>
<li>从名称上看: CyclicBarrier 是 循环栅栏 或 循环屏障 的意思</li>
</ul>
<img src="/posts/2730732825/image-20231110094139586.png" class="" title="image-20231110094139586">



<h2 id="41、Semaphore的使用和源码分析"><a href="#41、Semaphore的使用和源码分析" class="headerlink" title="41、Semaphore的使用和源码分析"></a>41、Semaphore的使用和源码分析</h2><p><strong>Semaphore概述</strong></p>
<ul>
<li>Semaphore 的意思就是信号量，也是一个辅助同步器类</li>
<li>Semaphore 维护了<code>一定数量</code>的“许可证”。当有线程想要访问共享资源的时候，首先就要去获得许可，如果许可证不够了，线程就一直等待，直到获得许可证。</li>
<li>当然，线程使用完共享资源过后，应该归还许可证，以供其它的线程来获得许可证。</li>
</ul>
<h2 id="42、Exchange的使用和源码分析"><a href="#42、Exchange的使用和源码分析" class="headerlink" title="42、Exchange的使用和源码分析"></a>42、Exchange的使用和源码分析</h2><h3 id="1、Exchanger-概述"><a href="#1、Exchanger-概述" class="headerlink" title="1、Exchanger 概述"></a>1、Exchanger 概述</h3><p>Exchanger 是交换器的意思，也是一个辅助同步器类。</p>
<p>主要作用:就是在线程间交换数据。</p>
<img src="/posts/2730732825/image-20231110095230064.png" class="" title="image-20231110095230064">



<h2 id="43、Executors框架详解"><a href="#43、Executors框架详解" class="headerlink" title="43、Executors框架详解"></a>43、Executors框架详解</h2><h3 id="1、Executors-框架概述"><a href="#1、Executors-框架概述" class="headerlink" title="1、Executors 框架概述"></a>1、Executors 框架概述</h3><p>Executors 框架是用来对多个线程，按照一定的策略，进行调度、执行 和 控制 的框架。</p>
<p>这里主要指的是线程池的管理。</p>
<h3 id="2、Executor-接口"><a href="#2、Executor-接口" class="headerlink" title="2、Executor 接口"></a>2、Executor 接口</h3><p>就是用来 在 <code>任务创建</code> 和 <code>任务执行</code> 之间进行解藕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以前的做法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableTask</span>()).start():</span><br><span class="line"><span class="comment">// 有了这个 Executor 接口过后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExecutorlmpl</span> <span class="keyword">implements</span> <span class="title class_">Executor</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>&#123;</span><br><span class="line">        <span class="comment">//同步执行</span></span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExecutorlmpl2</span> <span class="keyword">implements</span> <span class="title class_">Executor</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>&#123;</span><br><span class="line">        <span class="comment">// 异步执行</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"> 		<span class="comment">//       </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行任务</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">et</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyExecutorlmpl2</span>();</span><br><span class="line">et.execute(r1):</span><br></pre></td></tr></table></figure>

<h3 id="3、-ExecutorService-接口"><a href="#3、-ExecutorService-接口" class="headerlink" title="3、 ExecutorService 接口"></a>3、 ExecutorService 接口</h3><p>增强 Executor 接口，在 Executor 基础上，增加了几类实用的方法</p>
<ol>
<li>关闭执行器</li>
<li>监视执行器的状态</li>
<li>提供了对异步任务的支持</li>
<li>提供了对批处理任务的支持</li>
</ol>
<h3 id="4、ScheduledExecutorService-接口"><a href="#4、ScheduledExecutorService-接口" class="headerlink" title="4、ScheduledExecutorService 接口"></a>4、ScheduledExecutorService 接口</h3><p>希望能够定时执行 或 周期性执行 任务，使用 ScheduledExecutorService。</p>
<h3 id="5、小结三个接口"><a href="#5、小结三个接口" class="headerlink" title="5、小结三个接口"></a>5、小结三个接口</h3><ol>
<li>Executor : 提交可执行任务</li>
<li>ExecutorService : 提供对线程池生命周期的管理，增加了对异步任务、批处<br>理任务等的支持</li>
<li>ScheduledExecutorService提供对任务的延时执行、周期性执行 的支持</li>
</ol>
<h3 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h3><p>Executors: 用于辅助创建 Executor 接口实现类的实例Executors 就是一个简单工厂，大体有:</p>
<ol>
<li>创建固定线程数的线程池。</li>
<li>创建可缓存的线程池。</li>
<li>创建可延时、可周期执行的线程池。</li>
<li>创建单个线程数的线程池。</li>
<li>创建 Fork/join 线程池。</li>
</ol>
<h3 id="7、总结-Executors-框架"><a href="#7、总结-Executors-框架" class="headerlink" title="7、总结 Executors 框架"></a>7、总结 Executors 框架</h3><img src="/posts/2730732825/image-20231113105831293.png" class="" title="image-20231113105831293">

<h2 id="44、ThreadPoolExecutor使用和源码分析"><a href="#44、ThreadPoolExecutor使用和源码分析" class="headerlink" title="44、ThreadPoolExecutor使用和源码分析"></a>44、ThreadPoolExecutor使用和源码分析</h2><h3 id="1、ThreadPoolExecutor-概述"><a href="#1、ThreadPoolExecutor-概述" class="headerlink" title="1、ThreadPoolExecutor 概述"></a>1、ThreadPoolExecutor 概述</h3><ul>
<li>ThreadPoolExecutor 是一种线程池，是JDK1.5 引入的。</li>
<li>ThreadPoolExecutor 实 现了 ExecutorService 接口，是通过继承 AbstractExecutorService 来实现的。</li>
</ul>
<p>2、线程池基础<br>比如: 数据库连接池</p>
<img src="/posts/2730732825/image-20231113110843152.png" class="" title="image-20231113110843152">

<p>ThreadPoolExecutor</p>
<img src="/posts/2730732825/image-20231113110909395.png" class="" title="image-20231113110909395">

<p>为什么要引入线程池</p>
<ol>
<li>减少因为频繁创建和销毁线程所带来的开销</li>
<li>提高程序的响应速度</li>
<li>自动管理线程，调度任务的执行，使得调用方只关注于任务的创建</li>
</ol>
<h3 id="3、拒绝策略"><a href="#3、拒绝策略" class="headerlink" title="3、拒绝策略"></a>3、拒绝策略</h3><p>有两种情况，会执行拒绝策略</p>
<ol>
<li>核心线程池满了，任务队列也满了，同时呢，非核心线程池也满了，这个时候，再来新的任务，就会执行拒绝策略</li>
<li>提交任务的时候，线程池关闭了</li>
</ol>
<p>目前一共有四种拒绝策略</p>
<ol>
<li>AbortPolicy : 就是抛出例外</li>
<li>DiscardPolicy : 什么都不做，等任务自己被回收</li>
<li>DiscardOldestPolicy: 丢弃队列中最近的一个任务，并执行当前的任务</li>
<li>CallerRunsPolicy : 用调用者的线程来执行任务</li>
</ol>
<h3 id="4、线程池的状态"><a href="#4、线程池的状态" class="headerlink" title="4、线程池的状态"></a>4、线程池的状态</h3><p>用 ctl 变量来表示线程池的状态，这是一个 Atomiclnteger 类型的数据：</p>
<ul>
<li>高 3 位保存线程池的状态</li>
<li>低 29 位保存线程数</li>
</ul>
<p>线程池的五种状态</p>
<ol>
<li> RUNNING: 接受新任务，而且会处理已经进入阻塞对列的任务</li>
<li> SHUTDOWN : 不接受新任务，但 会处理已经进入阻塞对列的任务</li>
<li> STOP:不再接受新任务，而且不再处理已经进入阻塞对列的任务，同时会中断正在运行的任务</li>
<li> TIDYING : 所有任务都已经终止，工作线程数量为 0，准备调用 terminated 方法</li>
<li> TERMINATED : terminated 方法已经执行完成</li>
</ol>
<img src="/posts/2730732825/image-20231113111810856.png" class="" title="image-20231113111810856">



<h2 id="45、Future使用和源码分析"><a href="#45、Future使用和源码分析" class="headerlink" title="45、Future使用和源码分析"></a>45、Future使用和源码分析</h2><h3 id="1、Future-概述"><a href="#1、Future-概述" class="headerlink" title="1、Future 概述"></a>1、Future 概述</h3><p>Future 模式是多线程中一种常见的设计模式。<br>就是用来实现异步执行任务。<br>调用方拿到的仅仅是一个凭证-future 接口，具体实现类就是 FutureTask。</p>
<h3 id="2、FutureTask-核心方法的源码分析"><a href="#2、FutureTask-核心方法的源码分析" class="headerlink" title="2、FutureTask 核心方法的源码分析"></a>2、FutureTask 核心方法的源码分析</h3><p>FutureTask 代表一个可异步执行的任务。</p>
<blockquote>
<p>状态</p>
</blockquote>
<ul>
<li>NEW :任务的初始化状态</li>
<li>COMPLETING : 表示任务已经执行完成，属于中间状态</li>
<li>NORMAL : 表示任务正常完成，属于最终状态</li>
<li>EXCEPTIONAL: 表示任务异常完成，属于最终状态</li>
<li>CANCELLED : 表示任务还没开始执行就被取消了，非中断方式，属于最终状态</li>
<li>INTERRUPTING : 表示任务还没开始执行就被取消了，中断方式，属于中间状态</li>
<li>INTERRUPTED : 表示任务还没开始执行就被取消了，中断方式，且已经被中断，属于最终状态</li>
</ul>
<blockquote>
<p>状态变迁示意图</p>
</blockquote>
<img src="/posts/2730732825/image-20231113112513966.png" class="" title="image-20231113112513966">



<h2 id="46、ScheduledThreadPoolExecutor使用和源码分析"><a href="#46、ScheduledThreadPoolExecutor使用和源码分析" class="headerlink" title="46、ScheduledThreadPoolExecutor使用和源码分析"></a>46、ScheduledThreadPoolExecutor使用和源码分析</h2><h3 id="1、ScheduledThreadPoolExecutor-概述"><a href="#1、ScheduledThreadPoolExecutor-概述" class="headerlink" title="1、ScheduledThreadPoolExecutor 概述"></a>1、ScheduledThreadPoolExecutor 概述</h3><p>ScheduledThreadPoolExecutor 就是在 ThreadPoolExecutor 的基础上，增加了可以限时或周期性的调度任务的功能。</p>
<h2 id="47、Fork—Join框架详解"><a href="#47、Fork—Join框架详解" class="headerlink" title="47、Fork—Join框架详解"></a>47、Fork—Join框架详解</h2><h3 id="1、Fork-Join-框架概述"><a href="#1、Fork-Join-框架概述" class="headerlink" title="1、Fork/Join 框架概述"></a>1、Fork/Join 框架概述</h3><p>Fork/Join 就是用来实现:</p>
<p>将一个大任务分解成为一系列子任务 (fork)，当子任务执行完成后，会将他们各自执行的结果进行合并 (join) 成为一个大结果再把这些大结果合并成为更大的结果，直到得到最终的结果</p>
<p>实现这样功能的框架就是这里的 Fork/Join 框架。是JDK1.7 引入的</p>
<p>本质思想就是:分而治之</p>
<h3 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h3><blockquote>
<p>1.线程和队列</p>
</blockquote>
<p>​    如果每次都创建新的线程来运行任务，会非常耗资源，因此:Fork/Join 框架是利用线程池来调度任务。这个线程池叫做 : ForkJoinPool</p>
<p>​    为了提高效率，并减少线程竞争，Fork/Join 框架把这多个平行的任务，放到不同的队列中去，这样一来，Fork/Join 的线程池里面，就有了多个任务队列，这个跟以前不一样，前面学的线程池都是只有一个任务队列。</p>
<blockquote>
<p>2.工作窃取算法</p>
</blockquote>
<p>由于线程处理任务的速度不一样，就有可能出现某个线程先执行完自己对应的任务队列里面的任务，这时为了提升资源的利用率，并提高处理效率，就可以让已经完成自己任务处理的线程，去其它线程对应的任务队列里面“窃取”任务来执行。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io">Eric</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io/posts/2730732825/">https://ericwjian.github.io/posts/2730732825/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericwjian.github.io" target="_blank">Eric</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2024902247/" title="JSP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JSP</div></div></a></div><div class="next-post pull-right"><a href="/posts/2211149435/" title="SpringBoot集成xxl-job"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot集成xxl-job</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Eric</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/wangjian_uuid" target="_blank" title="Gitee"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:358070983@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=358070983&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">Java多线程、并发编程和源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B"><span class="toc-text">1、线程是什么、并发与并行、为什么需要线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">1、线程和进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">2、相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%B9%B6%E5%8F%91"><span class="toc-text">1、并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%B9%B6%E8%A1%8C"><span class="toc-text">2、并行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%B8%B2%E8%A1%8C"><span class="toc-text">3、串行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">4、并发和并行区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-text">5、同步和异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">6、单线程和多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">3、为什么需要多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="toc-text">4、线程的风险</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">2、创建线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%9E%E7%8E%B0Runnable"><span class="toc-text">1、实现Runnable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BB%A7%E6%89%BFThread"><span class="toc-text">2、继承Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">3、匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81callable%EF%BC%8C%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">4、callable，带返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">3、线程的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">4、线程基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81sleep-%E3%80%81yield-%E3%80%81wait-%E6%96%B9%E6%B3%95"><span class="toc-text">1、sleep()、yield()、wait() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81notify-%E3%80%81notifyAll"><span class="toc-text">2、notify()、notifyAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81join"><span class="toc-text">3、join()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81interrupted"><span class="toc-text">4、interrupted()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">5、线程的安全性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">6、synchronized关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81monitor%E6%9C%BA%E5%88%B6"><span class="toc-text">7、monitor机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2、工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81synchronized-%E7%9A%84-monitor-%E6%9C%BA%E5%88%B6"><span class="toc-text">3、synchronized 的 monitor 机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E9%94%81%E4%BF%A1%E6%81%AF%E5%AD%98%E6%94%BE"><span class="toc-text">8、锁信息存放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">1、对象的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-text">3、对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Mark-word"><span class="toc-text">4、Mark word</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">9、锁的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">1、偏向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">2、轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">3、重量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AF%B9%E6%AF%94"><span class="toc-text">4、对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">10、锁的使用流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E9%94%81%E9%87%8D%E5%85%A5%E3%80%81%E8%87%AA%E6%97%8B%E3%80%81%E6%AD%BB%E9%94%81%E5%92%8Csynchronized"><span class="toc-text">11、锁重入、自旋、死锁和synchronized</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81wait%E3%80%81notify%EF%BC%8CnotifyAll"><span class="toc-text">12、wait、notify，notifyAll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-text">13、生产者消费者模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81wait%E3%80%81notify%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">14、wait、notify机制实现生产者和消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81JMM%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">15、JMM：Java内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">16、并发编程三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">1、原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">2、可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">3、有序性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E7%90%86%E8%A7%A3%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-text">17、理解重排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E7%90%86%E8%A7%A3-happens-before"><span class="toc-text">18、理解 happens-before</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-text">19、理解内存屏障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8"><span class="toc-text">20、volatile关键字使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">21、volatile 关键字的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%A2%ABvolatile%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8C%E5%85%B7%E6%9C%89%E5%A6%82%E4%B8%8B%E7%89%B9%E6%80%A7%E3%80%82"><span class="toc-text">1、被volatile修饰的变量，具有如下特性。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81volatile-%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="toc-text">2、volatile 内存语义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E8%AE%A4%E8%AF%86lock%E6%8E%A5%E5%8F%A3%E5%92%8C-lock-%E4%BD%93%E7%B3%BB"><span class="toc-text">22、认识lock接口和 lock 体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81lock%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">1、lock接口中的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81lock%E4%BD%93%E7%B3%BB"><span class="toc-text">2、lock体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Lock-%E5%92%8C-Synchronized%E5%8C%BA%E5%88%AB"><span class="toc-text">3、Lock 和 Synchronized区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81LockSupport%E4%BD%BF%E7%94%A8"><span class="toc-text">23、LockSupport使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81%E7%90%86%E8%A7%A3CAS"><span class="toc-text">24、理解CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E8%AE%A4%E8%AF%86-AQS"><span class="toc-text">25、认识 AQS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E4%BD%BF%E7%94%A8-AQS-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%94%81"><span class="toc-text">26、使用 AQS 来实现锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81AQS-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">27、AQS 源码解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81ReentrantLock"><span class="toc-text">28、ReentrantLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81ReentrantReadWriteLock"><span class="toc-text">29、ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81ReentrantReadWriteLock-%E6%BA%90%E7%A0%81"><span class="toc-text">30、ReentrantReadWriteLock 源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81StampedLock%E4%BD%BF%E7%94%A8"><span class="toc-text">31、StampedLock使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81Condition-%E7%90%86%E8%A7%A3%E4%BD%BF%E7%94%A8"><span class="toc-text">32、Condition 理解使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81Condition-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">33、Condition 源码解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81ThreadLocal-%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">34、ThreadLocal 使用和源码解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-CopyOnWriteArrayList-%E4%BD%BF%E7%94%A8"><span class="toc-text">35、并发容器 CopyOnWriteArrayList 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8"><span class="toc-text">1、同步容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-text">2、并发容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-text">3、有哪些并发容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81CopyOnWriteArrayList"><span class="toc-text">4、CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81CopyOnWriteArrayList%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-text">5、CopyOnWriteArrayList基本的设计思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81ConcurrentHashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">36、ConcurrentHashMap 源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81ArrayBlockingQueue%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">37、ArrayBlockingQueue使用和源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81ArrayBlockingQueue"><span class="toc-text">1、ArrayBlockingQueue:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81BlockingQueue-%E6%8E%A5%E5%8F%A3"><span class="toc-text">2、BlockingQueue 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81ConcurrentLinkedQueue%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">37、ConcurrentLinkedQueue使用和源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38%E3%80%81Atomic-%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">38、Atomic 框架使用和源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39%E3%80%81CountDownLatch-%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">39、CountDownLatch 使用和源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40%E3%80%81CyclicBarrier%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">40、CyclicBarrier的使用和源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E3%80%81Semaphore%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">41、Semaphore的使用和源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E3%80%81Exchange%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">42、Exchange的使用和源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Exchanger-%E6%A6%82%E8%BF%B0"><span class="toc-text">1、Exchanger 概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43%E3%80%81Executors%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3"><span class="toc-text">43、Executors框架详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Executors-%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">1、Executors 框架概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Executor-%E6%8E%A5%E5%8F%A3"><span class="toc-text">2、Executor 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81-ExecutorService-%E6%8E%A5%E5%8F%A3"><span class="toc-text">3、 ExecutorService 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81ScheduledExecutorService-%E6%8E%A5%E5%8F%A3"><span class="toc-text">4、ScheduledExecutorService 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%B0%8F%E7%BB%93%E4%B8%89%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-text">5、小结三个接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">6、总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%80%BB%E7%BB%93-Executors-%E6%A1%86%E6%9E%B6"><span class="toc-text">7、总结 Executors 框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44%E3%80%81ThreadPoolExecutor%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">44、ThreadPoolExecutor使用和源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81ThreadPoolExecutor-%E6%A6%82%E8%BF%B0"><span class="toc-text">1、ThreadPoolExecutor 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-text">3、拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">4、线程池的状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45%E3%80%81Future%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">45、Future使用和源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Future-%E6%A6%82%E8%BF%B0"><span class="toc-text">1、Future 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81FutureTask-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">2、FutureTask 核心方法的源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46%E3%80%81ScheduledThreadPoolExecutor%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">46、ScheduledThreadPoolExecutor使用和源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81ScheduledThreadPoolExecutor-%E6%A6%82%E8%BF%B0"><span class="toc-text">1、ScheduledThreadPoolExecutor 概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47%E3%80%81Fork%E2%80%94Join%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3"><span class="toc-text">47、Fork—Join框架详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Fork-Join-%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">1、Fork&#x2F;Join 框架概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">2、基本概念</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148432/" title="MyBatis 拦截器">MyBatis 拦截器</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148434/" title="MyBatis 集成druid数据源">MyBatis 集成druid数据源</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1166366203/" title="SQL调优">SQL调优</a><time datetime="2024-07-16T16:00:00.000Z" title="发表于 2024-07-17 00:00:00">2024-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3109398172/" title="ContextHolder">ContextHolder</a><time datetime="2024-07-11T16:00:00.000Z" title="发表于 2024-07-12 00:00:00">2024-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2889834893/" title="SpringCloud Feign">SpringCloud Feign</a><time datetime="2024-07-01T16:00:00.000Z" title="发表于 2024-07-02 00:00:00">2024-07-02</time></div></div></div></div></div></div></main><footer id="footer" style="background: #47577e"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '2N3fEF3CzNAzKwVbFlhSTUuM-gzGzoHsz',
      appKey: '9m41Klhi8IgsrNrbyMnoCHrN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>