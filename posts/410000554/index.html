<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM虚拟机 | Eric</title><meta name="author" content="Eric"><meta name="copyright" content="Eric"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="视频地址： 前言1.Java虚拟机的家族1.虚拟机始祖Sun Classic   2.使用最广HotSpot VM：它是Sun&amp;#x2F;OracleJDK和OpenJDK中的默认Java虚拟机，也是目前使用范围最广的Java虚拟机。   一、认识 JVM1.JVM 架构图  2.JVM 体系结构  *注意"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://ericwjian.github.io/posts/410000554/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4dfa2c883c8c4c23f4866185de932236";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM虚拟机',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-03 11:12:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Eric"><span class="site-name">Eric</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JVM虚拟机</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-10-12T12:46:25.000Z" title="发表于 2019-10-12 20:46:25">2019-10-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-03T03:12:27.700Z" title="更新于 2023-11-03 11:12:27">2023-11-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM虚拟机"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><hr>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TJ411R75F">视频地址：</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="1-Java虚拟机的家族"><a href="#1-Java虚拟机的家族" class="headerlink" title="1.Java虚拟机的家族"></a>1.Java虚拟机的家族</h3><h4 id="1-虚拟机始祖"><a href="#1-虚拟机始祖" class="headerlink" title="1.虚拟机始祖"></a>1.虚拟机始祖</h4><p>Sun Classic</p>
<img src="/posts/410000554/image-20211217164200432.png" class="" title="image-20211217164200432">

<h4 id="2-使用最广"><a href="#2-使用最广" class="headerlink" title="2.使用最广"></a>2.使用最广</h4><p>HotSpot VM：它是Sun/OracleJDK和OpenJDK中的默认Java虚拟机，也是目前使用范围最广的Java虚拟机。</p>
<img src="/posts/410000554/image-20220325110443259.png" class="" title="image-20220325110443259">

<h2 id="一、认识-JVM"><a href="#一、认识-JVM" class="headerlink" title="一、认识 JVM"></a>一、认识 JVM</h2><h3 id="1-JVM-架构图"><a href="#1-JVM-架构图" class="headerlink" title="1.JVM 架构图"></a>1.JVM 架构图</h3><img src="/posts/410000554/4070621-bba54463485506eb.png" class="" title="img">

<h3 id="2-JVM-体系结构"><a href="#2-JVM-体系结构" class="headerlink" title="2.JVM 体系结构"></a>2.JVM 体系结构</h3><img src="/posts/410000554/20200721212525209.png" class="" title="在这里插入图片描述">

<p><code>*注意：</code></p>
<ul>
<li><p>平常我们说的栈是指的Java栈；Native Method stack(本地方法栈) 里面装的都是native方法，负责和调用底层C++。</p>
</li>
<li><p>方法区并不是存放方法的区域，它是存放类的描述信息(模板)的地方。</p>
</li>
<li><p>加载之前是 “小class”，加载之后就变成了“大Class”，这是安装 java.lang.Class 模板生成了一个实例。“大CLass”就装载在方法区，模板实例化之后就得到 n 个相同的对象。</p>
</li>
<li><p>JVM并不是通过检查文件后缀是不 .class 来判断是否需要加载的，而是通过打开文件开头的特定的文件标志。</p>
</li>
<li><p>Execution Engine 执行引擎：负责解释命令，提交操作系统执行。</p>
</li>
</ul>
<h2 id="二、类装载器"><a href="#二、类装载器" class="headerlink" title="二、类装载器"></a>二、类装载器</h2><h3 id="1、运行原理"><a href="#1、运行原理" class="headerlink" title="1、运行原理"></a>1、运行原理</h3><p>负责加载<code>class</code>文件的，将<code>class</code>文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构。<code>ClassLoader</code>只负责文件的加载，至于它是否可运行，则由<code>Execution Engine</code>决定。</p>
<p>在这里需要区分一下<code>class</code>与<code>Class</code>。小写的<code>class</code>，是指编译 Java 代码后所生成的以<code>.class</code>为后缀名的字节码文件。而大写的<code>Class</code>，是 JDK 提供的<code>java.lang.Class</code>，可以理解为封装类的模板。多用于反射场景，例如 JDBC 中的加载驱动，<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>;</p>
<p>接下来我们来观察下图，<code>Car.class</code>字节码文件被<code>ClassLoader</code>类装载器加载并初始化，在方法区中生成了一个<code>Car Class</code>的类模板，而我们平时所用到的实例化，就是在这个类模板的基础上，形成了一个个实例，即<code>car1，car2</code>。反过来讲，我们可以对某个具体的实例进行<code>getClass()</code>操作，就可以得到该实例的类模板，即<code>Car Class</code>。再接着，我们对这个类模板进行<code>getClassLoader()</code>操作，就可以得到这个类模板是由哪个类装载器进行加载的。</p>
<img src="/posts/410000554/20200721213332630-16361123021413.png" class="" title="在这里插入图片描述">

<blockquote>
<p>Tip：扩展一下，JVM并不仅仅只是通过检查文件后缀名是否是<code>.class</code>来判断是否加载，最主要的是通过<code>class</code>文件中特定的文件标示，即下图<code>test.class</code>文件中的<code>cafe babe</code>。</p>
</blockquote>
<img src="/posts/410000554/image-20211105164053931.png" class="" title="image-20211105164053931">

<h3 id="2、有哪些类装载器"><a href="#2、有哪些类装载器" class="headerlink" title="2、有哪些类装载器"></a>2、有哪些类装载器</h3><blockquote>
<p>虚拟机自带的加载器</p>
</blockquote>
<ul>
<li><code>启动类加载器</code>(Bootstrap ClassLoader)，C++所写，也叫根加载器，加载%JAVAHOME%/jre/lib/rt.jar。</li>
<li><code>扩展类加载器</code>(Ext ClassLoader)，java所写，加载%JAVAHOME%/jre/lib/ext/*.jar，例如javax.swing包。</li>
<li><code>应用程序类加载器</code>(App ClassLoader)，也叫系统类加载器，加载%CLASSPATH%的所有类。</li>
</ul>
<blockquote>
<p>用户自定义的加载器</p>
</blockquote>
<p>用户可以自定义类的加载方式，但必须是 Java.lang.ClassLoader 的子类。</p>
<img src="/posts/410000554/20200722134405251.png" class="" title="在这里插入图片描述">

<h3 id="3、双亲委派和沙箱安全"><a href="#3、双亲委派和沙箱安全" class="headerlink" title="3、双亲委派和沙箱安全"></a>3、双亲委派和沙箱安全</h3><p>接下来，我们通过下面代码来观察这几个类加载器。首先，我们先看自定义的<code>MyObject</code>，首先通过<code>getClassLoader()</code> 获取到的是<code>AppClassLoader</code>，然后·得到 ExtClassLoader，再<code>getParent()</code>竟然是<code>null</code>？可能大家会有疑惑，不应该是<code>Bootstrap</code>加载器么？这是因为，<code>BootstrapClassLoader</code>是使用C++语言编写的，Java在加载的时候就成了null。</p>
<p>我们再来看Java自带的<code>Object</code>，通过<code>getClassLoader()</code>获取到的加载器直接就是<code>BootstrapClassLoader</code>，如果要想<code>getParent()</code>的话，因为是null值，所以就会报<code>java.lang.NullPointerException</code>空指针异常。</p>
<img src="/posts/410000554/20200722131041957.png" class="" title="在这里插入图片描述">

<blockquote>
<p>输出中，<code>sun.misc.Launcher</code>是JVM相关调用的入口程序。</p>
</blockquote>
<p>那为什么会出现这个情况呢？这就需要我们来了解类加载器的加载顺序和机制了，即<code>双亲委派</code>和<code>沙箱安全 </code>。</p>
<p><strong>（1）双亲委派</strong>，当一个类收到了类加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，因此所有的加载请求都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的<code>Class</code>），子类加载器才会尝试自己去加载。</p>
<p><strong>优点</strong>：采用双亲委派的一个好处是，比如加载位于<code>rt.jar</code>包中的类<code>java.lang.Object</code>，不管是哪个加载器加载这个类，最终都是委派给顶层的启动类加载器进行加载，确保哪怕使用了不同的类加载器，最终得到的都是同样一个<code>Object</code>对象。</p>
<p>（<strong>2）沙箱安全机制</strong>，是基于双亲委派机制上采取的一种JVM的自我保护机制，假设你要写一个<code>java.lang.String</code>的类，由于双亲委派机制的原理，此请求会先交给<code>BootStrapClassLoader</code>试图进行加载，但是BootStrapClassLoader在加载类时首先通过包和类名查找<code>rt.jar</code>中有没有该类，有则优先加载<code>rt.jar</code>包中的类，<strong>因此就保证了java的运行机制不会被破坏，确保你的代码不会污染到Java的源码。</strong></p>
<blockquote>
<p>所以，类加载器的加载顺序如下：</p>
</blockquote>
<ol>
<li>当<code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li>
<li>当<code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</li>
<li>如果<code>BootStrapClassLoader</code>加载失败（例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该<code>class</code>），会使用<code>ExtClassLoader</code>来尝试加载。</li>
<li>若<code>ExtClassLoader</code>也加载失败，则会使用<code>AppClassLoader</code>来加载，如果<code>AppClassLoader</code>也加载失败，则会报出异常<code>ClassNotFoundException</code>。</li>
</ol>
<blockquote>
<p>Tip：rt.jar是什么？做了哪些事？这些暂且不提，那你有没有想过，为什么可以在idea这些开发工具中可以直接去使用String、ArrayList、甚至一些JDK提供的类和方法？观察下面动图就可以知道，原来这些都在rt.jar中定义好了，且直接被启动类加载器进行加载了。</p>
<img src="/posts/410000554/20200722130535525.gif" class="" title="在这里插入图片描述">
</blockquote>
<h2 id="三、PC-和-Native-Method-Stack"><a href="#三、PC-和-Native-Method-Stack" class="headerlink" title="三、PC 和 Native Method Stack"></a>三、PC 和 Native Method Stack</h2><h3 id="1、本地方法栈"><a href="#1、本地方法栈" class="headerlink" title="1、本地方法栈"></a>1、本地方法栈</h3><p><strong>本地方法接口（Native Interface）</strong>，其作用是融合不同的编程语言为 Java 所用，它的初衷是用来融合 C/C++ 程序的，Java 诞生的时候是 C/C++ 流行时期，要想立足，就得调用 C/C++ 程序，于是 Java就在内存中专门开辟了一块区域处理标记为 native 的代码。</p>
<p>而<strong>本地方法栈（Native Method Stack）</strong>，就是在一个 Stack 中登记这些 native 方法，然后在执行引擎<code>Execution Engine</code>执行时加载本地方法库<code>native libraies</code>。</p>
<p>接下来，我们通过下图的多线程部分源码来理解什么是<code>native</code>方法。首先我们观察<code>start()</code>的源码，发现它其实并没有做什么复杂的操作，只是单纯的调用了<code>start0()</code>这个方法，然后我们去观察<code>start0()</code>的源码，发现它只是一个使用了<code>native</code>关键字修饰的一个方法（<code>private native void start0();</code>），但只有声明却没有具体的实现！。</p>
<img src="/posts/410000554/20200722151311154.png" class="" title="在这里插入图片描述">

<p>为什么？我们都知道<code>Thread</code>是<code>Class</code>关键字修饰的类（<code>class Thread implements Runnable</code>），而不是接口。一般来说，类中的方法都要有定义和实现，接口里面才有方法的定义声明。这就是<code>native</code>方法的独特之处，说白了，被<code>native</code>关键字修饰的方法，基本上和我们，甚至和 Java 都没啥关系了，因为它要去调用底层操作系统或者第三方语言的库函数，所以我们不需要去考虑它具体是如何实现的。</p>
<h3 id="2、程序计数器"><a href="#2、程序计数器" class="headerlink" title="2、程序计数器"></a>2、程序计数器</h3><p><strong>程序计数器（Program Counter Register）</strong>，也叫PC寄存器。每个线程启动的时候，都会创建一个PC寄存器。PC寄存器里保存当前正在执行的JVM指令的地址。 每一个线程都有它自己的PC寄存器，也是该线程启动时创建的。</p>
<p>简单来说，PC寄存器就是保存下一条将要执行的指令地址的寄存器，其内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。</p>
<p>每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎<code>Execution Engine</code>读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p>
<p>这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>PC寄存器一般用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出（OutOfMemory，OOM）错误。</p>
<blockquote>
<p>如果执行的是一个native方法，那这个计数器是空的。</p>
</blockquote>
<h2 id="四、运行时数据区"><a href="#四、运行时数据区" class="headerlink" title="四、运行时数据区"></a>四、运行时数据区</h2><p>用一张图来介绍每个区域存储的内容。</p>
<img src="/posts/410000554/image-20220219092023564.png" class="" title="image-20220219092023564">

<blockquote>
<p>成员变量包括：</p>
<p>实例变量：</p>
<ul>
<li>类变量：类变量又称为静态变量，指在类中被 static 修饰的成员变量。</li>
<li>常量：final 修饰的变量。</li>
</ul>
<p>局部变量：</p>
<ul>
<li>定义在方法体体中的基本数据类型的变量。</li>
</ul>
</blockquote>
<h3 id="1、方法区"><a href="#1、方法区" class="headerlink" title="1、方法区"></a>1、方法区</h3><p><strong>方法区（Method Area）</strong>，是供各线程共享的运行时内存区域，它存储了<code>每一个类的结构信息</code>。例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。</p>
<blockquote>
<p>方法区放什么数据</p>
</blockquote>
<h4 id="1-方法区存储的类信息"><a href="#1-方法区存储的类信息" class="headerlink" title="1. 方法区存储的类信息"></a>1. 方法区存储的类信息</h4><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p>
<ul>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名称( java.lang.Object除外，其他类型若没有声明父类，默认父类是Object)</li>
<li>这个类型的修饰符(public、abstract、final)类型的常量池</li>
<li>域(Field)信息 (域就是范围的意思例｛｝之间，称为一块域，用来描述变量适用范围，全局变量的域是整个类，局部变量只适用于他所在的｛｝之间)</li>
<li>方法(Method)信息</li>
<li>除了常量外的所有静态(static)变量</li>
</ul>
<h4 id="2-方法区存储的常量"><a href="#2-方法区存储的常量" class="headerlink" title="2. 方法区存储的常量"></a>2. 方法区存储的常量</h4><ul>
<li>static final修饰的成员变量都存储于 方法区中</li>
<li>字符串常量也是存储在方法区中（字符串都是常量，一旦创建就无法改变）。</li>
</ul>
<h4 id="3-方法区存储的静态变量"><a href="#3-方法区存储的静态变量" class="headerlink" title="3. 方法区存储的静态变量"></a>3. 方法区存储的静态变量</h4><ul>
<li>静态变量又称为类变量，类中被static修饰的成员变量都是静态变量（类变量）</li>
<li>静态变量之所以又称为类变量，是因为静态变量和类关联在一起，随着类的加载</li>
<li>存在于方法区（而不是堆中）</li>
<li>八种基本数据类型（byte、short、int、long、float、double、char、boolean）的静态变量会在方法区开辟空间，并将对应的值存储在方法方法区</li>
<li>对于引用类型的静态变量<ul>
<li>如果未用new关键字为引用类型的静态变量分配对象（如：static Student stu）那么对象的引用stu会存储在方法区中，并为其指定默认值null;</li>
<li>如果用new关键字为引用类型的静态变量分配对象（如：static Student stu = new Student()）,那么对象的引用stu 会存储在方法区中，并且该对象在堆中的地址也会存储在方法区中（注意此时静态变量只存储了对象的堆地址，而对象本身仍在堆内存中）</li>
</ul>
</li>
</ul>
<h4 id="4-方法区存储的方法"><a href="#4-方法区存储的方法" class="headerlink" title="4. 方法区存储的方法"></a>4. 方法区存储的方法</h4><ul>
<li><p>程序运行时会加载类编译生成的字节码，这个过程中静态变量（类变量）和静态方法及普通方法对应的字节码加载到方法区。</p>
</li>
<li><p>特别注意 :方法区中没有实例变量，这是因为，类加载先于对应类对象的产生，而实例变量是和对象关联在一起的，没有对象就不存在实例变量，类加载时没有对象，所以方法区中没有实例变量</p>
</li>
<li><p>静态变量（类变量）和静态方法及普通方法在方法区存储方式是有区别的(这个暂时只做声明 还未研究那么深刻)</p>
</li>
<li><p>对于字符串就又有不同来着情况:</p>
<p>String类型创建对象有两种方式：①通过字面量赋值：会先去常量池中查找是否存在相同的字符串，若存在，栈中引用直接指定该字符串；若不存在，在常量池中进行缓存，再将栈中引用指向它。②通过new关键字：每次new出来的都是一个新的对象，在堆中开辟空间进行存储。</p>
</li>
</ul>
<h3 id="2、栈-Stack"><a href="#2、栈-Stack" class="headerlink" title="2、栈 Stack"></a>2、栈 Stack</h3><p><code>栈管运行，堆管存储！</code></p>
<p><strong>栈（Stack）</strong>，也叫栈内存，主管Java程序的运行，在线程创建时创建。其生命期是跟随线程的生命周期，是线程私有的，线程结束栈内存也就是释放。</p>
<p>对于栈来说，不存在垃圾回收的问题，只要线程一结束该栈就Over。</p>
<h4 id="1-栈存储什么数据？"><a href="#1-栈存储什么数据？" class="headerlink" title="1.栈存储什么数据？"></a>1.栈存储什么数据？</h4><ul>
<li>栈是线程私有的内存区域;</li>
<li>每个方法执行的时候都会创建一个栈帧 用于存储局部变量表 操作数栈 动态链接方法出口信息等;</li>
<li>八种基本数据类型（byte、short、int、long、float、double、char、boolean）的局部变量（定义在方法体中的基本数据类型的变量）也是存储在栈中并且在栈中存储的是它们对应的值;</li>
<li>栈中还存储局部的对象的引用（定义在方法体中的引用类型的变量），对象的引用并不是对象本身，而是对象在堆中的地址，换句话说，局部的对象的引用所指的是对象在堆中的地址, 而这个则引用存储在了栈中。当然，如果对象的引用没有指向具体的对象，对象的引用则是null;</li>
<li>所以栈中存储的变量和引用都是局部的(即是在方法体中的变量或者引用) 所以得出<strong>局部变量和局部引用都在栈中，包括final 修饰的局部变量</strong></li>
</ul>
<p>这里引出一个名词，<code>栈帧</code>，什么是栈帧？<br>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p>
<img src="/posts/410000554/20200725155759288.png" class="" title="在这里插入图片描述">

<p>简单来说，<code>栈帧</code>对应一个方法的执行和结束，是方法执行过程的内存模型。</p>
<p>其中，栈帧主要保持了3类数据：</p>
<ul>
<li>本地变量（Local Variables）：输入参数和输出参数，以及方法内的变量。</li>
<li>栈操作（Operand Stack）：记录出栈、入栈的操作。</li>
<li>栈帧数据（Frame Data）：包括类文件、方法等。</li>
</ul>
<blockquote>
<p>栈的大小是根据JVM有关，一般在256K~756K之间，约等于1Mb左右。</p>
</blockquote>
<h4 id="2-栈的运行原理"><a href="#2-栈的运行原理" class="headerlink" title="2.栈的运行原理"></a>2.栈的运行原理</h4><p>观察下图，在java中，<code>test()</code> 和 <code>main()</code> 都是方法，而在栈中，称为栈帧。在栈中，main()都是第一个入栈的。<br>栈的顺序为：<code>main()</code>入栈 –&gt; <code>test()</code>入栈 –&gt; <code>test()</code>出栈 –&gt; <code>main()</code>出栈。</p>
<img src="/posts/410000554/20200725150917476.png" class="" title="在这里插入图片描述">

<p>根据代码和运行结果可以知道，<code>main()</code>想要出栈，则必须 <code>test()</code> 先出栈。那么怎么证明呢？观察下面代码，我们在test()方法中添加了一条语句<code>Thread.sleep(Integer.MAX_VALUE)</code>;，来让<code>test()</code>无法进行出栈操作，进而导致main()也无法出栈。运行代码发现，运行结果如我们所料，程序一直停留在<code>test()</code>入栈，无法进行其他操作。</p>
<img src="/posts/410000554/20200725150109203.png" class="" title="在这里插入图片描述">



<p>我们接着观察下图，在图中一个栈中有两个栈帧，分别是<code>Stack Frame1</code>和<code>Stack Frame2</code>，对应方法1和方法2。其中<code>Stack Frame2</code>是最先被调用的方法2，所以它先入栈。然后方法2又调用了方法1，所以<code>Stack Frame1</code>处于栈顶位置。执行完毕后，依次弹出<code>Stack Frame1</code>和<code>Stack Frame2</code>，然后线程结束，栈释放。<br>所以，每执行一个方法都会产生一个栈帧，并保存到栈的顶部，顶部的栈帧就是当前所执行的方法，该方法执行完毕后会自动出栈。</p>
<img src="/posts/410000554/20200725153138242.png" class="" title="在这里插入图片描述">

<p>总结如下，栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，方法A中又调用了方法B，于是产生栈帧F2也被压入栈中，方法B又调用方法C，于是产生栈帧F3也被压入栈中······执行完毕后，遵循“<strong>先进后出，后进先出</strong>”的原则，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧。</p>
<h4 id="3-栈溢出-StackOverflowError"><a href="#3-栈溢出-StackOverflowError" class="headerlink" title="3.栈溢出 StackOverflowError"></a>3.栈溢出 StackOverflowError</h4><p>大家肯定对栈溢出耳熟，那栈溢出是怎么产生的呢？</p>
<p>请看下面代码，<code>test()</code>方法里面又调用了<code>test()</code>方法，即自己调用自己，也叫递归。<br>同时，栈是一个内存块，它是有大小长度的，而我们观察代码发现，只要代码一运行，test()方法就会一直进行入栈操作，而没有出栈操作，结果肯定会超出栈的大小，进而造成栈溢出错误，即<code>java.lang.StackOverflowError</code>。</p>
<blockquote>
<p>java.lang.StackOverflowError是错误，不是异常！证明如下 ：</p>
<img src="/posts/410000554/20200725155549596.png" class="" title="在这里插入图片描述">
</blockquote>
<h3 id="3、堆-Heap"><a href="#3、堆-Heap" class="headerlink" title="3、堆 Heap"></a>3、堆 Heap</h3><h4 id="1-堆存放什么数据"><a href="#1-堆存放什么数据" class="headerlink" title="1. 堆存放什么数据"></a>1. 堆存放什么数据</h4><p>堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。堆的唯一目的就是存放对象实例。所有的对象实例及数组都要在堆上分配内存空间。</p>
<p>特别注意: 实例变量(非static修饰的成员变量) 因为他和对象是关联在一起的 所以实例变量也是在堆中存储；</p>
<p>java数组也在堆中开辟内存空间；</p>
<p><strong>所以得出结论由关键字 new 产生的所有对象都存储于Java堆 而且实例变量是和对象关联的所有也存储在堆中。</strong></p>
<h4 id="2-堆体系结构"><a href="#2-堆体系结构" class="headerlink" title="2.堆体系结构"></a>2.堆体系结构</h4><p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件之后，需要把类、方法、常量变量放到堆内存中，保持所以引用类型的真实信息，方便执行器执行。</p>
<p>其中，堆内存分为3个部分：</p>
<ul>
<li>Young Generation Space，新生区、新生代</li>
<li>Tenure Generation Space，老年区、老年代</li>
<li>Permanent Space，永久区、元空间</li>
</ul>
<p>Java7之前，堆结构图如下，而Java8则只将永久区变成了元空间。</p>
<img src="/posts/410000554/20200725163244622.png" class="" title="在这里插入图片描述">

<blockquote>
<p>总结一下，堆内存在逻辑上分为新生+养老+元空间，而堆内存在物理上分为新生+养老。</p>
</blockquote>
<h4 id="3-对象在堆中的生命周期"><a href="#3-对象在堆中的生命周期" class="headerlink" title="3 对象在堆中的生命周期"></a>3 对象在堆中的生命周期</h4><p>那么如何直观的了解对象在堆中的生命周期呢？</p>
<p>（1）首先，新生区是类的诞生、成长、消亡的区域。一个类在这里被创建并使用，最后被垃圾回收器收集，结束生命。</p>
<p>（2）其次，所有的类都是在<code>Eden Space</code>被<code>new</code>出来的。而当<code>Eden Space</code>的空间用完时，程序又需要创建对象，JVM的垃圾回收器则会将Eden Space中不再被其他对象所引用的对象进行销毁，也就是垃圾回收（Minor GC）。此时的GC可以认为是轻量级<code>GC</code>。</p>
<p>（3）然后将<code>Eden Space</code>中剩余的未被回收的对象，移动到<code>Survivor 0 Space</code>，以此往复，直到<code>Survivor 0 Space</code>也满了的时候，再对<code>Survivor 0 Space</code>进行垃圾回收，剩余的未被回收的对象，则再移动到<code>Survivor 1 Space</code>。<code>Survivor 1 Space</code>也满了的话，再移动至<code>Tenure Generation Space</code>。</p>
<p>（4）最后，如果<code>Tenure Generation Space</code>也满了的话，那么这个时候就会被垃圾回收（Major GC or Full GC）并将该区的内存清理。此时的GC可以认为是<code>重量级GC</code>。如果<code>Tenure Generation Space</code>被GC垃圾回收之后，依旧处于占满状态的话，就会产生我们场景的<code>OOM</code>异常，即<code>OutOfMemoryError</code>。</p>
<h4 id="4-Minor-GC的过程"><a href="#4-Minor-GC的过程" class="headerlink" title="4 Minor GC的过程"></a>4 Minor GC的过程</h4><p><code>Survivor 0 Space</code>，幸存者0区，也叫<code>from</code>区；<br><code>Survivor 1 Space</code>，幸存者1区，也叫<code>to</code>区。</p>
<p>其中，from区和to区的区分不是固定的，是互相交换的，意思是说，在每次GC之后，两者会进行交换，谁空谁就是to区。</p>
<p>不明白？没关系，接着往下看。</p>
<img src="/posts/410000554/20200807105031435.png" class="" title="在这里插入图片描述">

<p>（1）<code>Eden Space、from</code>复制到<code>to</code>，年龄+1。<br>首先，当<code>Eden Space</code>满时，会触发第一次GC，把还活着的对象拷贝到<code>from</code>区。而当<code>Eden Space</code>再次触发GC时，会扫描<code>Eden Space</code>和<code>from</code>，对这两个区进行垃圾回收，经过此次回收后依旧存活的对象，则直接复制到<code>to</code>区（如果对象的年龄已经达到老年的标准，则移动至老年代区），同时把这些对象的年龄+1。</p>
<p>（2）清空<code>Eden Space</code>、<code>from</code><br>然后，清空<code>Eden Space</code>和<code>from</code>中的对象，此时的<code>from</code>是空的。</p>
<p>（3）<code>from</code>和<code>to</code>互换<br>最后，<code>from</code>和<code>to</code>进行互换，原<code>from</code>成为下一次GC时的<code>to</code>，原<code>to</code>成为下一次GC时的<code>from</code>。部分对象会在<code>from</code>和<code>to</code>中来回进行交换复制，如果交换15次（由JVM参数<code>MaxTenuringThreshold</code>决定，默认15），最终依旧存活的对象就会移动至老年代。</p>
<p>总结一句话，<code>GC之后有交换，谁空谁是to</code>。</p>
<blockquote>
<p>这样也是为了保证内存中没有碎片，所以Survivor 0 Space和Survivor 1 Space有一个要是空的。</p>
</blockquote>
<h4 id="5-HotSpot虚拟机的内存管理"><a href="#5-HotSpot虚拟机的内存管理" class="headerlink" title="5 HotSpot虚拟机的内存管理"></a>5 HotSpot虚拟机的内存管理</h4><img src="/posts/410000554/20200807112107588.png" class="" title="在这里插入图片描述">

<blockquote>
<p>不同对象的生命周期不同，其中98%的对象都是临时对象，即这些对象的生命周期大多只存在于Eden区。</p>
</blockquote>
<p>实际而言，方法区（<code>Method Area</code>）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等。<strong>虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做<code>Non-Heap</code>（非堆内存），目的就是要和堆区分开</strong>。</p>
<p>对于HotSpot虚拟机而言，很多开发者习惯将方法区称为 “永久代（<code>Permanent Gen</code>）” 。但严格来说两者是不同的，或者说只是使用永久代来实现方法区而已，永久代是方法区（可以理解为一个接口<code>interface</code>）的一个实现，JDK1.7的版本中，已经将原本放在永久代的字符串常量池移走。（字符串常量池，JDK1.6在方法区，JDK1.7在堆，JDK1.8在元空间。）</p>
<img src="/posts/410000554/20200807112937832.png" class="" title="在这里插入图片描述">

<blockquote>
<p>如果没有明确指明，Java虚拟机的名字就叫做HotSpot。</p>
<img src="/posts/410000554/20200807114729427.png" class="" title="在这里插入图片描述">
</blockquote>
<h4 id="6-永久区"><a href="#6-永久区" class="headerlink" title="6 永久区"></a>6 永久区</h4><p>永久区是一个常驻内存区域，用于存放JDK自身所携带的<code>Class</code>，<code>Interface</code>的元数据（也就是上面文章提到的<code>rt.jar</code>等），也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。<br>（1）JDK1.7</p>
<img src="/posts/410000554/20200807121320925.png" class="" title="在这里插入图片描述">

<p>（2）JDK1.8</p>
<img src="/posts/410000554/20200807121358976.png" class="" title="在这里插入图片描述">



<p>在JDK1.8中，永久代已经被移除，被一个称为<code>元空间</code>的区域所取代。元空间的本质和永久代类似。</p>
<p>元空间与永久代之间最大的区别在于： <strong>永久带使用的JVM的堆内存，但是java8以后的元空间并不在虚拟机中而是使用本机物理内存</strong>。</p>
<p>因此，默认情况下，元空间的大小仅受本地内存限制。<br>类的元数据放入<code>native memory</code>，字符串池和类的静态变量放入Java堆中，这样可以加载多少类的元数据就不再由<code>MaxPermSize</code>控制, 而由系统的实际可用空间来控制。</p>
<h4 id="7-堆参数调优"><a href="#7-堆参数调优" class="headerlink" title="7 堆参数调优"></a>7 堆参数调优</h4><p>在进行堆参数调优前，我们可以通过下面的代码来获取虚拟机的相关内存信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVMMemory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回 Java 虚拟机试图使用的最大内存量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory();</span><br><span class="line">        System.out.println(<span class="string">&quot;MAX_MEMORY = &quot;</span> + maxMemory + <span class="string">&quot;（字节）、&quot;</span> + (maxMemory / (<span class="type">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 Java 虚拟机中的内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">totalMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory();</span><br><span class="line">        System.out.println(<span class="string">&quot;TOTAL_MEMORY = &quot;</span> + totalMemory + <span class="string">&quot;（字节）、&quot;</span> + (totalMemory / (<span class="type">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<img src="/posts/410000554/20200807135332693.png" class="" title="在这里插入图片描述">

<p>有人就有疑问了，这个<code>3607.5MB</code>和<code>243.5MB</code>是怎么算出来的？看下图就明白了，虚拟机最大内存为物理内存的1/4，而初始分配的内存为物理内存的1/64。</p>
<img src="/posts/410000554/20200807124758835.png" class="" title="在这里插入图片描述">

<p>IDEA中如何配置JVM内存参数？在【Run】-&gt;【Edit Configuration…】-&gt;【VM options】中，输入参数-Xms1024m -Xmx1024m -XX:+PrintGCDetails，然后保存退出。</p>
<img src="/posts/410000554/2020080714041120.png" class="" title="在这里插入图片描述">

<p>运行结果如下：</p>
<img src="/posts/410000554/20200807141114216.png" class="" title="在这里插入图片描述">

<blockquote>
<p>JVM的初始内存和最大内存一般怎么配？<br>答：初始内存和最大内存一定是一样大，理由是避免GC和应用程序争抢内存，进而导致内存忽高忽低产生停顿。</p>
</blockquote>
<h4 id="8-堆溢出-OutOfMemoryError"><a href="#8-堆溢出-OutOfMemoryError" class="headerlink" title="8 堆溢出 OutOfMemoryError"></a>8 堆溢出 OutOfMemoryError</h4><p>现在我们来演示一下OOM，首先把堆内存调成10M后，再一直new对象，导致Full GC也无法处理，直至撑爆堆内存，进而导致OOM堆溢出错误，程序及结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Atlantis&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 每执行下面语句，会在堆里创建新的对象</span></span><br><span class="line">            str += str + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">88888888</span>) + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">999999999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/410000554/20200807143709937.png" class="" title="在这里插入图片描述">

<blockquote>
<p>如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够，造成堆内存溢出。原因有两点：<br>①Java虚拟机的堆内存设置太小，可以通过参数-Xms和-Xmx来调整。<br>②代码中创建了大量对象，并且长时间不能被GC回收（存在被引用）。</p>
</blockquote>
<h3 id="4、栈、堆、方法区的交互关系"><a href="#4、栈、堆、方法区的交互关系" class="headerlink" title="4、栈、堆、方法区的交互关系"></a>4、栈、堆、方法区的交互关系</h3><p>栈、堆、方法区三者的关系如下图，其中reference是引用类型。</p>
<img src="/posts/410000554/20200725160245331.png" class="" title="在这里插入图片描述">

<p>举个栗子，比如<code>MyObject myObject = new MyObject()</code>;，等号左边<code>MyObject myObject</code>的<code>myObject</code>就是引用，在Java栈里面。等号右边的<code>new MyObject()</code>，<code>new</code>出来的<code>MyObject</code>实例对象在堆里面。简单来说，就是Java栈中的引用<code>myObject</code>指向了堆中的<code>MyObject</code>实例对象。</p>
<img src="/posts/410000554/20200725161551868.png" class="" title="在这里插入图片描述">

<h3 id="5、认识static关键字"><a href="#5、认识static关键字" class="headerlink" title="5、认识static关键字"></a>5、认识static关键字</h3><blockquote>
<p>1、static目的 </p>
</blockquote>
<p>java中的<code>static</code>关键字主要用于内存管理。</p>
<blockquote>
<p>2、static范围</p>
</blockquote>
<p><strong>使用范围</strong>：java static关键字可以用在变量、方法、代码块和嵌套类。</p>
<p><strong>作用范围</strong>：static关键字属于类，而不是类的实例。</p>
<p>静态(static)修饰如下：</p>
<ul>
<li>变量：称为类变量、静态变量</li>
<li>方法：称为类方法、静态方法</li>
<li>代码块：称为静态代码块</li>
<li>嵌套类：称为静态内部类</li>
</ul>
<blockquote>
<p>3、静态变量</p>
</blockquote>
<p>类的成员变量可以分为以下两种：</p>
<ul>
<li><p>静态变量（或称为类变量），指被 static 修饰的成员变量。</p>
</li>
<li><p>实例变量，指没有被 static 修饰的成员变量。</p>
</li>
</ul>
<p><strong>静态变量与实例变量的区别如下</strong>：</p>
<p>1）静态变量</p>
<ol>
<li>运行时，Java 虚拟机只为静态变量分配一次内存，加载类过程中完成静态变量的内存分配。</li>
<li>在类的内部，可以在任何方法内直接访问静态变量。</li>
<li>在其他类中，可以通过类名访问该类中的静态变量。</li>
</ol>
<p>2）实例变量</p>
<ol>
<li>每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。</li>
<li>在类的内部，可以在非静态方法中直接访问实例变量。</li>
<li>在本类的静态方法或其他类中则需要通过类的实例对象进行访问。</li>
</ol>
<p><strong>静态变量在类中的作用如下：</strong></p>
<ol>
<li><p>静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。</p>
</li>
<li><p>如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。</p>
</li>
</ol>
<blockquote>
<p>4、静态方法</p>
</blockquote>
<p>同成员变量，成员方法也可以分为以下两种：</p>
<ul>
<li>静态方法（或称为类方法），指被 static 修饰的成员方法。</li>
<li>实例方法，指没有被 static 修饰的成员方法。</li>
</ul>
<p><strong>静态方法与实例方法的区别：</strong></p>
<ol>
<li><p>静态方法，属于类，而不属于类的对象。<br>1）它通过类直接被调用，无需创建类的对象。</p>
<p>2）静态方法中，不能使用 this 关键字，也不能直接访问所属类的实例变量和实例方法；</p>
<p>3）静态方法中，可以直接访问所属类的静态变量和静态方法。</p>
<p>4）同this 关键字，super 关键字也与类的实例相关，静态方法中不能使用 super 关键字。</p>
</li>
<li><p>实例方法，可直接访问所属类的静态变量、静态方法、实例变量和实例方法。</p>
</li>
</ol>
<p><strong>静态方法与静态变量好处：</strong></p>
<ol>
<li><p>属于类级别，无需创建对象就即可直接使用，使用方便。</p>
</li>
<li><p>全局唯一，内存中唯一，静态变量可以唯一标识某些状态。</p>
</li>
<li><p>类加载时候初始化，常驻在内存，调用快捷方便。</p>
</li>
</ol>
<p><strong>静态方法与静态变量缺点：</strong></p>
<ol>
<li><p>静态方法不能调用非静态的方法和变量。</p>
</li>
<li><p>不能使用this和super关键字。</p>
</li>
</ol>
<p><strong>静态方法与静态变量适用场景：</strong></p>
<ol>
<li><p>静态方法，最适合工具类中方法的定义；比如文件操作，日期处理方法等。</p>
</li>
<li><p>静态方法，适合入口方法定义；比如单例模式，因从外部拿不到构造函数，所以定义一个静态的方法获取对象非常有必要。</p>
</li>
<li><p>静态变量适合全局变量的定义；举例：用一个布尔型静态成员变量做控制标志。</p>
</li>
</ol>
<blockquote>
<p>5、静态代码块</p>
</blockquote>
<p>定义：静态代码块，是 Java 类中的 static{ } 修饰的代码。</p>
<p>作用：用于类初始化时，为类的静态变量赋初始值，提升程序性能。<br>静态代码块的特点如下：</p>
<ol>
<li><p>静态代码块，有点类似于一个方法，但不可以存在于任何方法体内。</p>
</li>
<li><p>静态代码块，可以置于类中的任何地方，类中可以有多个静态初始化块。 </p>
</li>
<li><p>Java 虚拟机在加载类时执行，将只需要进行一次初始化的操作放在 static 代码块。</p>
</li>
<li><p>类中含多个静态代码块，Java虚拟机将按它们在类中出现的顺序依次执行，且都执行一次。</p>
</li>
<li><p>同静态代码块与静态，不能直接访问类的实例变量和实例方法，需通过类的对象访问。</p>
</li>
</ol>
<blockquote>
<p>6、静态类</p>
</blockquote>
<p> java中一个类要被声明为static的，只有一种情况，就是静态内部类（内嵌类）。如在外部类声明为static的，程序会编译都不会通过。</p>
<ol>
<li><p>静态内部类，跟静态方法一样，只能访问静态成员变量和方法，不能访问非静态方法和属性。</p>
</li>
<li><p>普通内部类，可以访问任意外部类的成员变量和方法。</p>
</li>
<li><p>静态内部类，可以声明普通成员变量和方法，而普通内部类不能声明static成员变量和方法。</p>
</li>
<li><p>静态内部类，可以单独初始化。</p>
</li>
</ol>
<h2 id="五、GC"><a href="#五、GC" class="headerlink" title="五、GC"></a>五、GC</h2><h3 id="1-GC垃圾收集机制"><a href="#1-GC垃圾收集机制" class="headerlink" title="1 GC垃圾收集机制"></a>1 GC垃圾收集机制</h3><p>对于GC垃圾收集机制，我们需要记住以下几点：</p>
<ol>
<li>次数上频繁收集Young区。</li>
<li>次数上较少收集Old区。</li>
<li>基本不动元空间。</li>
</ol>
<img src="/posts/410000554/2020080716523497.png" class="" title="在这里插入图片描述">

<img src="/posts/410000554/20200807154231426.png" class="" title="在这里插入图片描述">

<p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。<br>因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC），一种是全局GC（ Full GC或者major GC）</p>
<p><strong>Minor GC和Full GC的区别：</strong></p>
<p>（1）<strong>普通GC（minor GC）</strong>：只针对新生代区域的GC，指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快。<br>（2）<strong>全局GC（major GC or Full GC）</strong>：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（但并不是绝对的）。Major GC的速度一般要比Minor GC慢上10倍以上</p>
<h3 id="2-GC日志信息详解"><a href="#2-GC日志信息详解" class="headerlink" title="2 GC日志信息详解"></a>2 GC日志信息详解</h3><p>通过上面OOM案例，是不是觉得那一大片的日志信息看不懂？懵逼？没事，通过下图你就知道如何阅读GC日志信息。</p>
<p>（1）YGC相关参数：</p>
<img src="/posts/410000554/20200807151938212.png" class="" title="在这里插入图片描述">

<p>（2）FGC相关参数：</p>
<img src="/posts/410000554/20200807153518837.png" class="" title="在这里插入图片描述">

<h2 id="六、四大垃圾回收算法"><a href="#六、四大垃圾回收算法" class="headerlink" title="六、四大垃圾回收算法"></a>六、四大垃圾回收算法</h2><h3 id="1、如何判断Java中对象是否存活？"><a href="#1、如何判断Java中对象是否存活？" class="headerlink" title="1、如何判断Java中对象是否存活？"></a>1、如何判断Java中对象是否存活？</h3><h4 id="1、引用计数算法"><a href="#1、引用计数算法" class="headerlink" title="1、引用计数算法"></a><strong>1、引用计数算法</strong></h4><p>引用计数算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候，JVM就认为该对象不再被使用，是“垃圾”了。</p>
<p>引用计数实现简单，效率高；但是不能解决循环引用问问题（A对象引用B对象，B对象又引用A对象，但是A，B对象已不被任何其他对象引用），同时每次计数器的增加和减少都带来了很多额外的开销，所以在JDK1.1之后，这个算法已经不再使用了。</p>
<img src="/posts/410000554/20200807170516550.png" class="" title="在这里插入图片描述">

<h4 id="2、根搜索方法"><a href="#2、根搜索方法" class="headerlink" title="2、根搜索方法"></a><strong>2、根搜索方法</strong></h4><p><strong>根搜索方法</strong>是通过一些<code>GCRoots</code>对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（ReferenceChain），当一个对象没有被<code>GCRoots</code>的引用链连接的时候，说明这个对象是不可用的。</p>
<p><strong>GCRoots对象包括：</strong></p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li>
<li>方法区域中的常量、类静态属性引用的对象。</li>
<li>方法栈中JNI（<code>Native</code>方法）的引用的对象。</li>
</ul>
<img src="/posts/410000554/20200807180534899.png" class="" title="在这里插入图片描述">



<h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="1、标记-清除"><a href="#1、标记-清除" class="headerlink" title="1、标记-清除"></a>1、标记-清除</h4><p>标记-清除(Mark-Sweep）算法，是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段:<code>标记阶段和清除阶段</code>。在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。<br><code>缺点:</code></p>
<ol>
<li>效率问题，标记和清除两个过程的效率都不高。</li>
<li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ol>
<h4 id="2、标记-整理"><a href="#2、标记-整理" class="headerlink" title="2、标记-整理"></a>2、标记-整理</h4><p>标记整理算法，类似与标记清除算法，不过它标记完对象后，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。<br><code>优点:</code></p>
<ol>
<li>相对标记清除算法，解决了内存碎片问题</li>
<li>没有内存碎片后，对象创建内存分配也更快速了（可以使用TLAB进行分配)。</li>
</ol>
<p><code>缺点:</code></p>
<ol>
<li>效率问题，（同标记清除算法）标记和整理两个过程的效率都不高。</li>
</ol>
<h4 id="3、复制算法"><a href="#3、复制算法" class="headerlink" title="3、复制算法"></a>3、复制算法</h4><p>复制算法，可以解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。</p>
<p><code>优点:</code></p>
<ol>
<li>效率高，没有内存碎片。</li>
</ol>
<p><code>缺点:</code></p>
<ol>
<li>浪费一半的内存空间。</li>
<li>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。</li>
</ol>
<h4 id="4、分代收集算法"><a href="#4、分代收集算法" class="headerlink" title="4、分代收集算法"></a>4、分代收集算法</h4><p>当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为<code>新生代</code>和<code>老年代</code>，然后根据各个年代的特点采用最适当的收集算法。<br>在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用复制算法。<br>而老年代中，因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记清理”或者“标记整理”算法来进行回收。</p>
<h2 id="七、十个最常用的JVM-配置参数"><a href="#七、十个最常用的JVM-配置参数" class="headerlink" title="七、十个最常用的JVM 配置参数"></a>七、十个最常用的JVM 配置参数</h2><ol>
<li>-Xms：初始堆大小。只要启动，就占用的堆大小。</li>
<li>-Xmx：最大堆大小。java.lang.OutOfMemoryError：Java heap这个错误可以通过配置-Xms和-Xmx参数来设置。</li>
<li>-Xss：栈大小分配。栈是每个线程私有的区域，通常只有几百K大小，决定了函数调用的深度，而局部变量、参数都分配到栈上。当出现大量局部变量，递归时，会发生栈空间OOM（java.lang.StackOverflowError）之类的错误。</li>
<li>XX:NewSize：设置新生代大小的绝对值。</li>
<li>-XX:NewRatio：设置年轻代和年老代的比值。比如设置为3，则新生代：老年代=1:3，新生代占总heap的1/4。</li>
<li>-XX:MaxPermSize：设置持久代大小。java.lang.OutOfMemoryError:PermGenspace这个OOM错误需要合理调大PermSize和MaxPermSize大小。</li>
<li>-XX:SurvivorRatio：年轻代中Eden区与两个Survivor区的比值。注意，Survivor区有form和to两个。比如设置为8时，那么eden:form:to=8:1:1。</li>
<li>-XX:HeapDumpOnOutOfMemoryError：发生OOM时转储堆到文件，这是一个非常好的诊断方法。</li>
<li>-XX:HeapDumpPath：导出堆的转储文件路径。</li>
<li>-XX:OnOutOfMemoryError：OOM时，执行一个脚本，比如发送邮件报警，重启程序。后面跟着一个脚本的路径。</li>
</ol>
<blockquote>
<p>GC日志</p>
</blockquote>
<ol>
<li>-XX:+PrintGC        开启GC日志(简单日志)。</li>
<li>-XX:+PrintGCDetails  输出详细的 GC 处理日志。</li>
<li>-XX:+PrintGCDateStamps  带有时间戳输出GC日志。</li>
<li>-Xloggc:/user/gc.log  将GC日志输出到指定文件。</li>
</ol>
<h2 id="八、附录-常见面试问题"><a href="#八、附录-常见面试问题" class="headerlink" title="八、附录.常见面试问题"></a>八、附录.常见面试问题</h2><h3 id="1-GC四种算法哪个好？"><a href="#1-GC四种算法哪个好？" class="headerlink" title="1 GC四种算法哪个好？"></a>1 GC四种算法哪个好？</h3><p>没有哪个算法是能一次性解决所有问题的，因为JVM垃圾回收使用的是分代收集算法，没有最好的算法，只有根据每一代他的垃圾回收的特性用对应的算法。例如新生代使用复制算法，老年代使用标记清除和标记整理算法。<br>所以说，没有最好的垃圾回收机制，只有最合适的。</p>
<h3 id="2-请说出各个垃圾回收算法的优缺点"><a href="#2-请说出各个垃圾回收算法的优缺点" class="headerlink" title="2 请说出各个垃圾回收算法的优缺点"></a>2 请说出各个垃圾回收算法的优缺点</h3><p>（1）内存效率： 复制算法 &gt; 标记清除算法 &gt; 标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。<br>（2）内存整齐度： 复制算法 = 标记整理算法 &gt; 标记清除算法。<br>（3）内存利用率： 标记整理算法 = 标记清除算法 &gt; 复制算法。</p>
<p>可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记清除多了一个整理内存的过程。</p>
<h3 id="3-为什么需要JVM调优"><a href="#3-为什么需要JVM调优" class="headerlink" title="3 为什么需要JVM调优"></a>3 为什么需要JVM调优</h3><h4 id="1-将新对象预留在新生代"><a href="#1-将新对象预留在新生代" class="headerlink" title="1.将新对象预留在新生代"></a>1.将新对象预留在新生代</h4><p>由于Full GC的成本远高于Minor GC，因此尽可能将对象分配在新生代是一项明智的做法。虽然在大部分情况下，JVM会尝试在eden区分配对象，但是由于空间紧张等问题，很可能不得不将部分年轻对象提前向老年代压缩。</p>
<p>在JVM参数调优中，可以为应用程序分配一个合理的新生代空间，以避免新对象直接进入老年代的情况。因为新生代垃圾回收的速度高于老年代回收。因此，将年轻对象预留在新生代有利于提升整体的GC效率。</p>
<h4 id="2-大对象进入老年代"><a href="#2-大对象进入老年代" class="headerlink" title="2.大对象进入老年代"></a>2.大对象进入老年代</h4><p>虽然在大部分情况下，将对象分配在新生代是合理的。但是，对于大对象，这种做法是值得商榷的。大对象出现在新生代很可能扰乱新生代GC，并破坏新生代原有的对象结构。</p>
<p>因为尝试在新生代分配大对象，很可能导致空间不足，为了有足够的空间容纳大对象，JVM不得不将新生代中的年轻对象挪到老年代。因为大对象占用空间多，所以可能需要移动大量的小的年轻对象进入老年代。因为新生代的对象往往存活时间比较短，所以会引起多次的Full GC造成程序卡顿。</p>
<p>基于以上的原因，可以直接将大对象分配到老年代，以保持新生代对象结构的完整性，提高GC的效率。</p>
<p>可以使用参数-XX:PretenureSizeThreshold设置大对象直接进入老年代的阈值。当对象的大小超过这个值，将直接在老年代分配。</p>
<h4 id="3-设置对象进入老年代的年龄"><a href="#3-设置对象进入老年代的年龄" class="headerlink" title="3.设置对象进入老年代的年龄"></a>3.设置对象进入老年代的年龄</h4><p>在堆中，每个对象都有自己的年龄，一般情况下，年轻对象存放在新生区，年老对象存放在老年区。为了做到这一点，JVM会为每一个对象都维护一个年龄</p>
<p>如果对象在eden区，经过一次GC之后还存活，则被移动到survivor区中，对象年龄加1 。之后对象每经过一次GC之后依然存活，则年龄再加1 。当对象年龄到达阈值，就移入老年代，成为老年对象。</p>
<p>这个阈值的最大值可以通过参数-XX:MaxTenuringThreshold来设置，它的默认值为15.但这并不意味着新对象一定要达到这个年龄才能进入老年代。对象实际进入老年代的年龄是虚拟机在运行时根据内存使用情况动态计算的，这个参数指定的是阈值的最大值。即实际进入老年代的年龄等于动态计算所得的年龄与参数指定的中较小的那一个。</p>
<h4 id="4-稳定与震荡的堆大小"><a href="#4-稳定与震荡的堆大小" class="headerlink" title="4.稳定与震荡的堆大小"></a>4.稳定与震荡的堆大小</h4><p>一般来说，稳定的堆大小对垃圾回收是有利的。获得一个稳定的堆大小的方法是使-Xms和-xmx的大小一致，即最大堆和最小堆都一样。</p>
<p>如果这样设置，系统在运行时，堆的大小是恒定的，稳定的堆大小可以减少GC的次数，因此很多 服务端应用都会将最大堆和最小堆设置为相同的数值。</p>
<p>但是一个不稳定的堆大小也并非一无是处。稳定的堆大小虽然减少了GC的次数，但是同时也增加了GC的时间。让堆大小在一个区间中震荡，在系统不需要使用大内存时，压缩堆空间，使GC应对一个较小的堆可以加快单次GC的速度。</p>
<p>基于这样的考虑，JVM还提供了两个参数用于压缩和拓展堆空间：</p>
<ol>
<li>-XX:MinHeapFreeRatio ： 设置堆空间的最小空闲比例，默认是40.当堆空间的空闲内存小于这个数值时，JVM会拓展堆空间。</li>
<li>-XX:MinHeapFreeRatio ： 设置堆空间的最大空闲比例，默认是70.当堆空间的空闲内存大于这个数值时，JVM会拓展空间。</li>
</ol>
<p>当-XMS和-Xmx相等时，这两个参数是无效的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io">Eric</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io/posts/410000554/">https://ericwjian.github.io/posts/410000554/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericwjian.github.io" target="_blank">Eric</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1706463495/" title="Nginx"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Nginx</div></div></a></div><div class="next-post pull-right"><a href="/posts/2857723967/" title="JUC"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Eric</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/wangjian_uuid" target="_blank" title="Gitee"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:358070983@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=358070983&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AE%B6%E6%97%8F"><span class="toc-text">1.Java虚拟机的家族</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A7%8B%E7%A5%96"><span class="toc-text">1.虚拟机始祖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B9%BF"><span class="toc-text">2.使用最广</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%A4%E8%AF%86-JVM"><span class="toc-text">一、认识 JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JVM-%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-text">1.JVM 架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JVM-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">2.JVM 体系结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8"><span class="toc-text">二、类装载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">1、运行原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8"><span class="toc-text">2、有哪些类装载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%92%8C%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8"><span class="toc-text">3、双亲委派和沙箱安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81PC-%E5%92%8C-Native-Method-Stack"><span class="toc-text">三、PC 和 Native Method Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">1、本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">2、程序计数器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-text">四、运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">1、方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%AD%98%E5%82%A8%E7%9A%84%E7%B1%BB%E4%BF%A1%E6%81%AF"><span class="toc-text">1. 方法区存储的类信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%AD%98%E5%82%A8%E7%9A%84%E5%B8%B8%E9%87%8F"><span class="toc-text">2. 方法区存储的常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%AD%98%E5%82%A8%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">3. 方法区存储的静态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">4. 方法区存储的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%A0%88-Stack"><span class="toc-text">2、栈 Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%88%E5%AD%98%E5%82%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-text">1.栈存储什么数据？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%88%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">2.栈的运行原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%88%E6%BA%A2%E5%87%BA-StackOverflowError"><span class="toc-text">3.栈溢出 StackOverflowError</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%A0%86-Heap"><span class="toc-text">3、堆 Heap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A0%86%E5%AD%98%E6%94%BE%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE"><span class="toc-text">1. 堆存放什么数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A0%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">2.堆体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3 对象在堆中的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Minor-GC%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">4 Minor GC的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">5 HotSpot虚拟机的内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%B0%B8%E4%B9%85%E5%8C%BA"><span class="toc-text">6 永久区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%A0%86%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="toc-text">7 堆参数调优</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%A0%86%E6%BA%A2%E5%87%BA-OutOfMemoryError"><span class="toc-text">8 堆溢出 OutOfMemoryError</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="toc-text">4、栈、堆、方法区的交互关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%AE%A4%E8%AF%86static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">5、认识static关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81GC"><span class="toc-text">五、GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-GC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6"><span class="toc-text">1 GC垃圾收集机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-GC%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3"><span class="toc-text">2 GC日志信息详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%9B%9B%E5%A4%A7%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">六、四大垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADJava%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="toc-text">1、如何判断Java中对象是否存活？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">1、引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%A0%B9%E6%90%9C%E7%B4%A2%E6%96%B9%E6%B3%95"><span class="toc-text">2、根搜索方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">2、垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4"><span class="toc-text">1、标记-清除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86"><span class="toc-text">2、标记-整理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">3、复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">4、分代收集算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8D%81%E4%B8%AA%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84JVM-%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">七、十个最常用的JVM 配置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%99%84%E5%BD%95-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-text">八、附录.常见面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-GC%E5%9B%9B%E7%A7%8D%E7%AE%97%E6%B3%95%E5%93%AA%E4%B8%AA%E5%A5%BD%EF%BC%9F"><span class="toc-text">1 GC四种算法哪个好？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B7%E8%AF%B4%E5%87%BA%E5%90%84%E4%B8%AA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2 请说出各个垃圾回收算法的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81JVM%E8%B0%83%E4%BC%98"><span class="toc-text">3 为什么需要JVM调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B0%86%E6%96%B0%E5%AF%B9%E8%B1%A1%E9%A2%84%E7%95%99%E5%9C%A8%E6%96%B0%E7%94%9F%E4%BB%A3"><span class="toc-text">1.将新对象预留在新生代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">2.大对象进入老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%B9%B4%E9%BE%84"><span class="toc-text">3.设置对象进入老年代的年龄</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%A8%B3%E5%AE%9A%E4%B8%8E%E9%9C%87%E8%8D%A1%E7%9A%84%E5%A0%86%E5%A4%A7%E5%B0%8F"><span class="toc-text">4.稳定与震荡的堆大小</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148432/" title="MyBatis 拦截器">MyBatis 拦截器</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148434/" title="MyBatis 集成druid数据源">MyBatis 集成druid数据源</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1166366203/" title="SQL调优">SQL调优</a><time datetime="2024-07-16T16:00:00.000Z" title="发表于 2024-07-17 00:00:00">2024-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3109398172/" title="ContextHolder">ContextHolder</a><time datetime="2024-07-11T16:00:00.000Z" title="发表于 2024-07-12 00:00:00">2024-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2889834893/" title="SpringCloud Feign">SpringCloud Feign</a><time datetime="2024-07-01T16:00:00.000Z" title="发表于 2024-07-02 00:00:00">2024-07-02</time></div></div></div></div></div></div></main><footer id="footer" style="background: #47577e"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '2N3fEF3CzNAzKwVbFlhSTUuM-gzGzoHsz',
      appKey: '9m41Klhi8IgsrNrbyMnoCHrN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>