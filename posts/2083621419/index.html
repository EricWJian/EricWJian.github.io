<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 面试题 | Eric</title><meta name="author" content="Eric"><meta name="copyright" content="Eric"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 基础1.Java 有哪些数据类型基本数据类型有8种，  整数类型：byte（位）、short（短整数）、int（整数）、long（长整数） 浮点类型：float（单精度）、double（双精度） 字符型：char（字符） 布尔型：boolean（布尔值）    引用数据类型：  类（Str"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://ericwjian.github.io/posts/2083621419/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4dfa2c883c8c4c23f4866185de932236";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-19 10:48:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Eric"><span class="site-name">Eric</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java 面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-10T16:00:00.000Z" title="发表于 2022-06-11 00:00:00">2022-06-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-19T02:48:39.797Z" title="更新于 2024-04-19 10:48:39">2024-04-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java 面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h3 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h3><h4 id="1-Java-有哪些数据类型"><a href="#1-Java-有哪些数据类型" class="headerlink" title="1.Java 有哪些数据类型"></a>1.Java 有哪些数据类型</h4><p><code>基本数据类型有8种</code>，</p>
<ul>
<li>整数类型：byte（位）、short（短整数）、int（整数）、long（长整数）</li>
<li>浮点类型：float（单精度）、double（双精度）</li>
<li>字符型：char（字符）</li>
<li>布尔型：boolean（布尔值）</li>
</ul>
<img src="/posts/2083621419/978c9c4b19a141a6af60c9489e2fc0e7.png" class="" title="在这里插入图片描述">

<p><code>引用数据类型：</code></p>
<ul>
<li>类（String）</li>
<li>接口</li>
<li>数组</li>
</ul>
<h4 id="2-override-和-overload-的区别"><a href="#2-override-和-overload-的区别" class="headerlink" title="2.override 和 overload 的区别"></a>2.override 和 overload 的区别</h4><blockquote>
<p>override  重写：</p>
</blockquote>
<ul>
<li><code>Override 只发生在父类和子类之间</code>；</li>
<li>方法名、参数、返回值相同；（Object最高父类中有相同方法名方法）</li>
<li>子类方法访问修饰符权限范围要大于或等于父类访问修饰符权限范围；</li>
<li>子类方法不能抛出比父类方法更多的异常（子类方法可以不抛出异常）；</li>
<li>方法被定义为final不能重写；</li>
<li>被覆盖的方法不能为private，否则子类只是新定义了一个方法，不能被覆盖。</li>
</ul>
<blockquote>
<p>overload  重载：</p>
</blockquote>
<ul>
<li><code>发生在同一个类中</code>。</li>
<li>参数类型、个数、顺序至少一个不同;</li>
<li>方法的异常类型和数目</li>
<li>与访问修饰符和返回值类型无关</li>
</ul>
<h4 id="3-this-关键字和-super关键字"><a href="#3-this-关键字和-super关键字" class="headerlink" title="3.this 关键字和 super关键字"></a>3.this 关键字和 super关键字</h4><blockquote>
<p>this</p>
</blockquote>
<p>this 是自身的一个对象，代表对象本身，可以理解为：<code>指向对象本身的一个指针</code>。</p>
<p>this 的用法在 java 中大体可以分为3种：</p>
<ol>
<li>普通的直接引用，this 相当于是指向当前对象本身。</li>
<li>形参与成员名字重名，用 this 来区分：</li>
<li>引用本类的构造函数</li>
</ol>
<blockquote>
<p>super</p>
</blockquote>
<p>super可以理解为是<code>指向自己超（父）类对象的一个指针</code>，而这个超类指的是离自己最近的一个父类。</p>
<p>super也有三种用法：</p>
<ol>
<li>普通的直接引用：<br>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</li>
<li>子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分：</li>
<li>引用父类构造函数：<ul>
<li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li>
<li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li>
</ul>
</li>
</ol>
<h4 id="4-static关键字"><a href="#4-static关键字" class="headerlink" title="4.static关键字"></a>4.static关键字</h4><blockquote>
<p>static 存在的主要意义</p>
</blockquote>
<ul>
<li>static 的主要意义是在于创建独立于具体对象的域变量或者方法。以致于<code>即使没有创建对象，也能使用属性和调用方法</code>！</li>
<li>static 关键字还有一个比较关键的作用就是 <code>用来形成静态代码块以优化程序性能</code>。static 块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</li>
<li>为什么说 static 块可以用来优化程序性能，是因为它的特性:<code>只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行</code>。</li>
</ul>
<blockquote>
<p>static的独特之处</p>
</blockquote>
<ul>
<li>被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法<strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong>(方法区中，类的模板)。</li>
<li>在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</li>
<li>static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</li>
<li>被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</li>
</ul>
<h4 id="5-final-在-Java-中有什么作用？"><a href="#5-final-在-Java-中有什么作用？" class="headerlink" title="5.final 在 Java 中有什么作用？"></a>5.final 在 Java 中有什么作用？</h4><ul>
<li>final 修饰的类叫最终类，该类不能被继承。</li>
<li>final 修饰的方法不能被重写。</li>
<li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li>
</ul>
<h4 id="6-Java-中的-Math-round-1-5-等于多少？"><a href="#6-Java-中的-Math-round-1-5-等于多少？" class="headerlink" title="6.Java 中的 Math. round(-1. 5) 等于多少？"></a>6.Java 中的 Math. round(-1. 5) 等于多少？</h4><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>
<h4 id="7-float-f-3-4-是否正确"><a href="#7-float-f-3-4-是否正确" class="headerlink" title="7.float f=3.4;是否正确"></a>7.float f=3.4;是否正确</h4><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 floatf=3.4F。</p>
<p>在 Java 语言中有这样的一条规定：<code>只要是浮点型的字面量，例如 1.0、3.14 等默认会被当做 double 类型来处理</code>，如果想让程序将其当做 float 类型来处理，需要在字面量后面添加 f/F。</p>
<h4 id="8-在Java中，如何跳出当前的多重嵌套循环"><a href="#8-在Java中，如何跳出当前的多重嵌套循环" class="headerlink" title="8.在Java中，如何跳出当前的多重嵌套循环"></a>8.在Java中，如何跳出当前的多重嵌套循环</h4><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个<code>标号</code>，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ok:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;,j=&quot;</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span> ok;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;main~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-i和i-的区别"><a href="#9-i和i-的区别" class="headerlink" title="9.++i和i++的区别"></a>9.++i和i++的区别</h4><ol>
<li><p>++ i 是指先把变量i的值加1，然后再把结果值赋值给左边变量；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">n = ++i;</span><br><span class="line">System.out.println(n); <span class="comment">// 2</span></span><br><span class="line">System.out.println(i); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
<li><p>i ++ 是先把变量i的值赋值给左边变量，然后再把变量i的值加1；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">n = i++;</span><br><span class="line">System.out.println(n); <span class="comment">//1</span></span><br><span class="line">System.out.println(i); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="10-return-和-Break-的区别"><a href="#10-return-和-Break-的区别" class="headerlink" title="10.return 和 Break 的区别"></a>10.return 和 Break 的区别</h4><ol>
<li>break：用在for,while,do…while循环中，打破/结束循环，但不会跳出函数</li>
<li>return ：是使整个函数返回的，后面的不管是循环里面还是循环外面的都不执行</li>
<li>continue：执行continue操作，跳出本次循环，从下一个迭代继续运行循环，内层循环执行完毕，外层代码继续运行。</li>
</ol>
<h3 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h3><h4 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h4><p><code>成员变量</code>：方法外部，类内部定义的变量。</p>
<p>成员变量又分为：</p>
<ul>
<li>实例变量:</li>
<li>类变量：又称静态变量，类中被<code>static</code>修饰的成员变量。</li>
<li>常量:被 <code>final</code> 修饰的变量。</li>
</ul>
<p><code>局部变量</code>：定义在方法体中的基本数据类型的变量。</p>
<h4 id="2-构造函数的作用，分为哪几类"><a href="#2-构造函数的作用，分为哪几类" class="headerlink" title="2.构造函数的作用，分为哪几类"></a>2.构造函数的作用，分为哪几类</h4><p>构造函数的最大作用就是<code>创建对象时完成初始化</code>,当我们在 new 一个对象并传入参数的时候,会自动调用构造函数并完成参数的初始化。</p>
<ol>
<li><p>无参构造函数</p>
</li>
<li><p>有参构造函数</p>
</li>
<li><p>默认构造函数</p>
</li>
</ol>
<h3 id="String-相关"><a href="#String-相关" class="headerlink" title="String 相关"></a>String 相关</h3><h4 id="1-Java-中操作字符串有哪些类"><a href="#1-Java-中操作字符串有哪些类" class="headerlink" title="1.Java 中操作字符串有哪些类"></a>1.Java 中操作字符串有哪些类</h4><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
<p><code>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象</code>，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
<p><code>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的(添加了synchronize关键字修饰)，而 StringBuilder 是非线程安全的</code>，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
<h4 id="2-如何将字符串反转？"><a href="#2-如何将字符串反转？" class="headerlink" title="2.如何将字符串反转？"></a>2.如何将字符串反转？</h4><p>使用 StringBuilder 或者 StringBuffer 的 <code>reverse()</code> 方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">stringBuffer. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">stringBuilder. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure>

<h4 id="3-如何将字符串转换为数组？"><a href="#3-如何将字符串转换为数组？" class="headerlink" title="3.如何将字符串转换为数组？"></a>3.如何将字符串转换为数组？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;String&quot;</span>;</span><br><span class="line">    String[] split = s.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(split));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-String-类的常用方法都"><a href="#4-String-类的常用方法都" class="headerlink" title="4.String 类的常用方法都"></a>4.String 类的常用方法都</h4><ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h4 id="5-什么是字符串常量池？"><a href="#5-什么是字符串常量池？" class="headerlink" title="5.什么是字符串常量池？"></a>5.什么是字符串常量池？</h4><p>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p>
<ul>
<li>JDK1.6及以前，常量池在方法区；</li>
<li>JDK1.7的时候，方法区合并到了堆内存中，这时的常量池也可以说是在堆内存中；</li>
<li>JDK1.8及以后，方法区又从堆内存中剥离出来了，常量池就存储在元空间。</li>
</ul>
<h4 id="6-String为什么是不可变的？"><a href="#6-String为什么是不可变的？" class="headerlink" title="6.String为什么是不可变的？"></a>6.String为什么是不可变的？</h4><p>简单来说就是String类利用了final修饰的char类型数组存储字符。</p>
<h4 id="7-是否可以继承-String-类？"><a href="#7-是否可以继承-String-类？" class="headerlink" title="7.是否可以继承 String 类？"></a>7.是否可以继承 String 类？</h4><p>String 类是 <code>final</code> 类，不可以被继承。</p>
<h4 id="8-String-和-new-String-的区别"><a href="#8-String-和-new-String-的区别" class="headerlink" title="8.String 和 new String() 的区别"></a>8.String 和 new String() 的区别</h4><p><code>String类：表示不可改变的字符串，当前对象创建完毕之后，该对象的内容（字符序列）是不能改变的，一旦内容改变就是一个新的对象。</code></p>
<p>记住一点：<code>栈区存引用和基本类型，不能存对象，而堆区存对象。==是比较地址，equals()比较对象内容</code>。</p>
<p>JVM为了提升性能和减少内存开销，避免字符串的重复创建，维护了一块特殊的内存空间——字符串实例池。</p>
<blockquote>
<p>String赋值的两种方式。</p>
</blockquote>
<p><strong>1、String str = “abcd”;</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">        System.out.println(x == y); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String str = &quot;abcd&quot;</code>  的实现过程：首先栈区创建 str 引用，然后在 String 常量池中寻找其指向的内容为 “abcd” 的对象，如果 String 常量池中没有，则创建一个，然后 str 指向 String 常量池中的对象，如果有，则直接将 str 指向 “abcd””；如果后来又定义了 字符串变量 str2 = “abcd” , 则直接将 str2 引用指向 String 池中已经存在的 “abcd”，不再重新创建对象；</p>
<p><strong>2、new String(“abcd”)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String str3 = new String(&quot;abcd&quot;)</code> 的实现过程：底层会创建两个对象。一个是在堆中创建XXX的对象，另一个是在堆中字符串常量池中创建。这两个对象的内容都是一样的，但是地址是不相同的。如果后来又有 <code>String str4 = new String(&quot;abcd&quot;)</code>，str4不会指向之前的对象，而是重新创建一个对象并指向它，所以如果此时进行str3==str4返回值是false，因为两个对象的地址不一样，如果是str3.equals(str4)，返回true,因为内容相同。</p>
<p><strong>3、面试题</strong></p>
<p><code>string a =“a”</code>； 创建了<code>一个或者零</code>个对象。</p>
<p><code>String b = new string(&quot;ab&quot;)</code>;创建了一个或两个对象，单纯执行new String(“XXX”)，底层会创建两个对象。一个是在堆中创建XXX的对象，另一个是在堆中字符串常量池中创建。这两个对象的内容都是一样的，但是地址是不相同的。</p>
<h3 id="对象相等判断"><a href="#对象相等判断" class="headerlink" title="对象相等判断"></a>对象相等判断</h3><h4 id="1-和-equals-的区别是什么？"><a href="#1-和-equals-的区别是什么？" class="headerlink" title="1.== 和 equals 的区别是什么？"></a>1.== 和 equals 的区别是什么？</h4><p><strong>== 解读</strong></p>
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同；</li>
<li>引用类型：比较的是引用是否相同；</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>
<p><strong>equals 解读</strong></p>
<ul>
<li>只比较引用类型。</li>
</ul>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Cat</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;王磊&quot;</span>);</span><br><span class="line"><span class="type">Cat</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;王磊&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>
<p><strong>总结</strong> ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h4 id="2-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#2-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="2.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>2.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h4><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;通话&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;重地&quot;</span>;</span><br><span class="line">System. out. println(String. format(<span class="string">&quot;str1：%d | str2：%d&quot;</span>,  str1. hashCode(),str2. hashCode()));</span><br><span class="line">System. out. println(str1. equals(str2));</span><br></pre></td></tr></table></figure>

<p>执行的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1：1179395 | str2：1179395</span><br><span class="line"></span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<h4 id="3-为什么重写equals方法后，hashCode方法也必须重写"><a href="#3-为什么重写equals方法后，hashCode方法也必须重写" class="headerlink" title="3.为什么重写equals方法后，hashCode方法也必须重写"></a>3.为什么重写equals方法后，hashCode方法也必须重写</h4><ol>
<li><p><strong>保证是同一个对象</strong>，如果重写了equals方法，而没有重写hashcode方法，会出现equals相等的对象，hashcode不相等的情况，重写hashcode方法就是为了避免这种情况的出现。</p>
</li>
<li><p>使用hashcode方法<strong>提前校验</strong>，可以避免每一次比对都调用equals方法，<strong>提高效率</strong></p>
</li>
</ol>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="1-面向对象的特征"><a href="#1-面向对象的特征" class="headerlink" title="1.面向对象的特征"></a>1.面向对象的特征</h4><ul>
<li><p><code>继承</code></p>
<p>将公共的属性和方法放在父类中，自己自考虑特有的属性和方法。</p>
</li>
<li><p><code>封装</code></p>
<p>把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法；将有一定功能的代码封装起来，使用时调用即可。</p>
</li>
<li><p><code>多态</code></p>
<p>程序运行过程中，根据执行条件的不同，动态执行不同的操作代码的过程称为运行时多态。具体表现为<code>父类的引用指向子类的实例</code>。</p>
</li>
</ul>
<h4 id="2-什么是多态机制？Java语言是如何实现多态的？"><a href="#2-什么是多态机制？Java语言是如何实现多态的？" class="headerlink" title="2.什么是多态机制？Java语言是如何实现多态的？"></a>2.什么是多态机制？Java语言是如何实现多态的？</h4><p>所谓多态就是：指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在<strong>编程时并不确定</strong>，而是在<strong>程序运行期间才确定</strong>，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<h4 id="3-多态的实现"><a href="#3-多态的实现" class="headerlink" title="3.多态的实现"></a>3.多态的实现</h4><ul>
<li><code>继承</code>：在多态中必须存在有继承关系的子类和父类。</li>
<li><code>重写</code>：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li><code>向上转型</code>：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li>
</ul>
<h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><h4 id="1-抽象类的作用"><a href="#1-抽象类的作用" class="headerlink" title="1.抽象类的作用"></a>1.抽象类的作用</h4><p><code>用一句话总结抽象类的作用就是：降低接口实现类与接口之间的实现难度</code>，抽象类在实现接口的时候不必对接口中的所有方法进行重写继承，可以进行选择。</p>
<h4 id="2-抽象类必须要有抽象方法吗？"><a href="#2-抽象类必须要有抽象方法吗？" class="headerlink" title="2.抽象类必须要有抽象方法吗？"></a>2.抽象类必须要有抽象方法吗？</h4><p>不需要，抽象类不一定非要有抽象方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span>&#123;</span><br><span class="line">        System. out. println(<span class="string">&quot;hi ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<h4 id="3-抽象类能使用-final-修饰吗？"><a href="#3-抽象类能使用-final-修饰吗？" class="headerlink" title="3.抽象类能使用 final 修饰吗？"></a>3.抽象类能使用 final 修饰吗？</h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p>
<img src="/posts/2083621419/58edb860-3be3-11e9-af57-196eefd310b5.png" class="" title="编译器保存图">

<h4 id="4-普通类和抽象类有哪些区别？"><a href="#4-普通类和抽象类有哪些区别？" class="headerlink" title="4.普通类和抽象类有哪些区别？"></a>4.普通类和抽象类有哪些区别？</h4><ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<h4 id="5-接口和抽象类有什么区别？"><a href="#5-接口和抽象类有什么区别？" class="headerlink" title="5.接口和抽象类有什么区别？"></a>5.接口和抽象类有什么区别？</h4><ul>
<li>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</li>
<li>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li>
</ul>
<p><code>相同点</code>：</p>
<ul>
<li>接口和抽象类都不能实例化。</li>
<li>都位于继承的顶端，用于被其他实现或继承。</li>
<li>都包含抽象方法，其子类都必须覆写这些抽象方法。</li>
</ul>
<p><code>不同点</code>：</p>
<ul>
<li>声明：抽象类的子类使用 abstract 来声明；接口使用 interface 来声明接口。</li>
<li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li>
<li>构造函数：抽象类可以有构造函数；接口不能有。</li>
<li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li>
<li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>
</ul>
<h4 id="6-Java中接口的意义"><a href="#6-Java中接口的意义" class="headerlink" title="6.Java中接口的意义"></a>6.Java中接口的意义</h4><ul>
<li>定义接口有利于代码的规范。不同的开发人员遵从接口编写具体的实现代码。</li>
<li>有利于对代码进行维护，方便扩展。类想增加功能，再实现一个接口即可。换实现类的时候，可以直接替换生成类。比如两个kfc实体店，实现了kfc接口。再增加一个直接实现接口即可。kfc接口增加新品。实体店就可以都加。</li>
<li>解决了不能多继承的问题。</li>
</ul>
<h4 id="7-抽象类的意义"><a href="#7-抽象类的意义" class="headerlink" title="7.抽象类的意义"></a>7.抽象类的意义</h4><ol>
<li>为其他子类提供一个公共的类型。</li>
<li>封装子类中重复定义的内容。</li>
<li>定义抽象方法,子类虽然有不同的实现,但是定义时一致的。</li>
</ol>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="1-什么是泛型"><a href="#1-什么是泛型" class="headerlink" title="1.什么是泛型"></a>1.什么是泛型</h4><p>Java在 1.5 之后引入了泛型，<code>泛型</code>的本质是<code>参数化类型</code>，也就是说<code>所操作的数据类型被指定为一个参数</code>，就是一种不确定的数据类型。</p>
<blockquote>
<p>泛型分类</p>
</blockquote>
<ul>
<li>泛型类</li>
<li>泛型接口</li>
<li>泛型方法</li>
</ul>
<h4 id="2-泛型中extends和super的区别"><a href="#2-泛型中extends和super的区别" class="headerlink" title="2.泛型中extends和super的区别"></a>2.泛型中extends和super的区别</h4><ol>
<li><? extends T>：表示包括T在内的任何T的⼦类，extends 向下。</li>
<li><? super T>：表示包括T在内的任何T的⽗类 ，super 向上。</li>
</ol>
<h4 id="3-泛型擦除"><a href="#3-泛型擦除" class="headerlink" title="3.泛型擦除"></a>3.泛型擦除</h4><p> java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。 </p>
<p>Java 中的泛型是伪泛型，Java中类型参数只存在于编译期。在运行时Java的虚拟机并不知道泛型的存在，这就是java中的泛型使用了类型擦除机制。</p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h4 id="1-Java-中-IO-流分为几种？"><a href="#1-Java-中-IO-流分为几种？" class="headerlink" title="1. Java 中 IO 流分为几种？"></a>1. Java 中 IO 流分为几种？</h4><p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<h4 id="2-BIO、NIO、AIO-有什么区别？"><a href="#2-BIO、NIO、AIO-有什么区别？" class="headerlink" title="2. BIO、NIO、AIO 有什么区别？"></a>2. BIO、NIO、AIO 有什么区别？</h4><ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
<h4 id="3-Files-的常用方法都有哪些？"><a href="#3-Files-的常用方法都有哪些？" class="headerlink" title="3. Files 的常用方法都有哪些？"></a>3. Files 的常用方法都有哪些？</h4><ul>
<li>Files. exists()：检测文件路径是否存在。</li>
<li>Files. createFile()：创建文件。</li>
<li>Files. createDirectory()：创建文件夹。</li>
<li>Files. delete()：删除一个文件或目录。</li>
<li>Files. copy()：复制文件。</li>
<li>Files. move()：移动文件。</li>
<li>Files. size()：查看文件个数。</li>
<li>Files. read()：读取文件。</li>
<li>Files. write()：写入文件。</li>
</ul>
<h3 id="包装类相关"><a href="#包装类相关" class="headerlink" title="包装类相关"></a>包装类相关</h3><h4 id="1-基本类型和包装类型区别"><a href="#1-基本类型和包装类型区别" class="headerlink" title="1.基本类型和包装类型区别"></a>1.基本类型和包装类型区别</h4><ol>
<li>包装类是对象，有方法和字段，对象的调用是通过引用对象的地址，而基本类型不是。</li>
<li>包装类型是引用的传递，基本类型是值的传递。</li>
<li>初始值不同：int的初始值位0，boolean的初始值为false;包装类型的初始值null。</li>
<li>声明的方式不同：基本类型不需要new关键字；包装类型需要new关键字创建对象分配内存空间。</li>
<li>存储位置不同：基本数据类型直接将值保存在堆中；包装类型的对象存储在堆中，通过对象的引用来调用。</li>
<li>使用的方式不同：基本数据类型直接赋值就可以；包装类型通常是在集合时使用。</li>
</ol>
<h4 id="2-Integer-a-127-与-Integer-b-127相等吗"><a href="#2-Integer-a-127-与-Integer-b-127相等吗" class="headerlink" title="2.Integer a= 127 与 Integer b = 127相等吗"></a>2.Integer a= 127 与 Integer b = 127相等吗</h4><ul>
<li>对于对象引用类型：==比较的是对象的内存地址。</li>
<li>对于基本数据类型：==比较的是值。</li>
</ul>
<blockquote>
<p>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    System.out.println(a == b); <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">    System.out.println(a == c); <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">    System.out.println(b == c); <span class="comment">// true</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(a1 == b1); <span class="comment">// false</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    System.out.println(a2 == b2); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集合容器"><a href="#集合容器" class="headerlink" title="集合容器"></a>集合容器</h3><h4 id="1-集合和数组的区别"><a href="#1-集合和数组的区别" class="headerlink" title="1.集合和数组的区别"></a>1.集合和数组的区别</h4><ul>
<li>数组是固定长度的；集合可变长度的。</li>
<li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li>
<li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li>
</ul>
<h4 id="2-Java-容器都有哪些？"><a href="#2-Java-容器都有哪些？" class="headerlink" title="2.Java 容器都有哪些？"></a>2.Java 容器都有哪些？</h4><img src="/posts/2083621419/6e00b902b10e4743ac4c842f27efc00b.png" class="" title="在这里插入图片描述">

<p>Java <code>容器</code>分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<ul>
<li><p>Collection</p>
<ul>
<li><p>List</p>
<ul>
<li>ArrayList </li>
<li>LinkedList：</li>
<li>Vector：<code>线程安全的</code></li>
<li>Stack：<code>线程安全的</code></li>
</ul>
</li>
<li><p>Set</p>
<ul>
<li>HashSet</li>
<li>LinkedHashSet</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
<li><p>Map</p>
<ul>
<li><p>HashMap</p>
<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li><p>TreeMap</p>
</li>
<li><p>ConcurrentHashMap ：<code>线程安全的</code></p>
</li>
<li><p>Hashtable：<code>线程安全的</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="3-Collection-和-Collections-有什么区别？"><a href="#3-Collection-和-Collections-有什么区别？" class="headerlink" title="3. Collection 和 Collections 有什么区别？"></a>3. Collection 和 Collections 有什么区别？</h4><ul>
<li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li>
<li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</li>
</ul>
<h4 id="4-List、Set、Map-之间的区别是什么？"><a href="#4-List、Set、Map-之间的区别是什么？" class="headerlink" title="4.List、Set、Map 之间的区别是什么？"></a>4.List、Set、Map 之间的区别是什么？</h4><p>List、Set、Map 的区别主要体现在两个方面：元素是否<code>有序</code>、元素是否允许<code>重复</code>。</p>
<p>三者之间的区别，如下表：</p>
<img src="/posts/2083621419/6e7001c0-3be3-11e9-af57-196eefd310b5.png" class="" title="区别图">

<h4 id="5-HashMap-和-Hashtable-有什么区别？"><a href="#5-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="5. HashMap 和 Hashtable 有什么区别？"></a>5. HashMap 和 Hashtable 有什么区别？</h4><ul>
<li>存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。</li>
<li>线程安全：Hashtable 是线程安全的(<code>Hashtable的实现方法里面都添加了synchronized的关键字</code>)，而 HashMap 是非线程安全的。</li>
<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>
</ul>
<h4 id="5-HashMap-和-ConcurrentHashMap-的区别是什么"><a href="#5-HashMap-和-ConcurrentHashMap-的区别是什么" class="headerlink" title="5.HashMap 和 ConcurrentHashMap 的区别是什么"></a>5.HashMap 和 ConcurrentHashMap 的区别是什么</h4><ul>
<li> HashMap不是线程安全的，ConcurrentHashMap是线程安全的。</li>
<li>ConcurrentHashMap 底层使用 synchronized 关键字，以及使用 <code>分段锁(每一把锁只锁容器的一段数据)</code> 的概念。</li>
</ul>
<h4 id="6-如何决定使用-HashMap-还是-TreeMap？"><a href="#6-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="6. 如何决定使用 HashMap 还是 TreeMap？"></a>6. 如何决定使用 HashMap 还是 TreeMap？</h4><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快；但如果你要对一个 key 集合进行<code>有序</code>的遍历，那 TreeMap 是更好的选择。</p>
<h4 id="7-说一下-HashMap-的实现原理？"><a href="#7-说一下-HashMap-的实现原理？" class="headerlink" title="7. 说一下 HashMap 的实现原理？"></a>7. 说一下 HashMap 的实现原理？</h4><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>
<p><strong>map.put(Key,value)的实现原理（存）</strong></p>
<ol>
<li>先将key和value封装到Node节点中。</li>
<li>底层会调用key的hashcode()方法，通过hash函数将hash值转换为数组下标，下标位置上如果没有任何元素，就把该Node添加到该位置上（该下标处）</li>
<li>如果该下标处对应的位置上已经存在元素或链表（多于一个元素变成链表），那么就会拿着新节点的key与链表上的每一个人节点中的key进行equals。<ul>
<li>如果所有对比（equals)都返回false,那么这个新节点将会被添加到链表的尾部。</li>
<li> 如果其中有一个对比（equals)返回true，那么这个节点上的value将会被新节点的value覆盖。</li>
</ul>
</li>
</ol>
<p><strong>map.get(Key)的实现原理（取）</strong></p>
<ol>
<li>底层会调用key的hashcode()方法，通过hash函数将hash值转换为数组下标，通过数组下标快速定位到数组的指定位置上，如果这个位置上没有任何元素，那么返回null。</li>
<li>如果这个位置上有单向链表（该位置上有元素），那么会拿着我们get(key)中的key和单向链表中的每个节点的key进行equals，如果说所有的equals都返回false，那么这个get方法返回false。</li>
<li>只要其中有一个节点的key和参数key的equals对比的结果返回true,那么这个节点的value就是我们想要找的value，get()方法返回这个value。</li>
</ol>
<p><strong>JDK 1.7 和 1.8 HashMap的不同</strong></p>
<ul>
<li>1.7 采用的是头插法，1.8 采用的是尾插法。</li>
<li>1.7是数组+链表，1.8则是数组+链表+红黑树结构（当链表长度大于8，转为红黑树）</li>
</ul>
<h4 id="为什么说-HashMap-不是线程安全的？"><a href="#为什么说-HashMap-不是线程安全的？" class="headerlink" title="为什么说 HashMap 不是线程安全的？"></a>为什么说 HashMap 不是线程安全的？</h4><ul>
<li>JDK 1.7 采用头插法会导致死循环。</li>
<li>JDK 1.8 中put方法会导致元素覆盖。</li>
</ul>
<h4 id="HashMap-的扩容机制"><a href="#HashMap-的扩容机制" class="headerlink" title="HashMap 的扩容机制"></a>HashMap 的扩容机制</h4><p>HashMap的底层有数组 + 链表(红黑树)组成，数组的大小可以在构造方法时设置，<code>默认大小为16</code>，但是，如果用户通过构造函数指定类一个数字作为容量，那么HashMap会选择大于该数字的的第一个 2的幂 作为容量。数组中每一个元素就是一个链表，jdk7之前链表中的元素采用头插法插入元素，jdk8之后采用尾插法插入元素，由于插入的元素越来越多，查找效率就变低了，所以满足某种条件时，链表会转换成红黑树。随着元素的增加，HashMap的数组会频繁扩容，如果构造时不赋予加载因子默认值，那么负载因子默认值为0.75,数组扩容的情况如下:</p>
<ol>
<li>当添加某个元素后，数组的总的添加元素数大于了 数组长度 * 0.75(默认,也可自己设定),数组长度扩容为两倍。(如开始创建HashMap集合后，数组长度为16，临界值为16 * 0.75 = 12，当加入元素后元素个数超过12，数组长度扩容为32，临界值变为24)。</li>
<li>在没有红黑树的条件下，添加元素后数组中某个链表的长度超过了8，数组会扩容为两倍.(如开始创建HashMAp集合后，假设添加的元素都在一个链表中，当链表中元素为8时，再在链表中添加一个元素，此时若数组中不存在红黑树，则数组会扩容为两倍变成32，假设此时链表元素排列不变，再在该链表中添加一个元素，数组长度再扩容两倍，变为64，假设此时链表元素排列还是不变，则此时链表中存在10个元素，这是HashMap链表元素数存在的最大值，此时，再加入元素，满足了链表树化的两个条件(1:数组长度达到64, 2:该链表长度达到了8)，该链表会转换为红黑树。</li>
</ol>
<h4 id="8-说一下-HashSet-的实现原理？"><a href="#8-说一下-HashSet-的实现原理？" class="headerlink" title="8. 说一下 HashSet 的实现原理？"></a>8. 说一下 HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，<code>HashSet 不允许重复的值</code>。</p>
<p>所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。</p>
<h4 id="9-ArrayList-的参数"><a href="#9-ArrayList-的参数" class="headerlink" title="9.ArrayList 的参数"></a>9.ArrayList 的参数</h4><p>这是初始容量，即<code>ArrayList</code>将作为项目的内部存储开始分配的项目数。</p>
<h4 id="10-ArrayList的扩容机制"><a href="#10-ArrayList的扩容机制" class="headerlink" title="10.ArrayList的扩容机制"></a>10.ArrayList的扩容机制</h4><blockquote>
<p>jdk1.7 情况下：</p>
</blockquote>
<p>ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData<br>list.add(123);//elementData[0] = new Integer(123);<br>…<br>list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。<br>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p>
<blockquote>
<p>jdk1.8 中ArrayList的变化：</p>
</blockquote>
<p>ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没创建长度为10的数组<br>list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]<br>…<br>后续的添加和扩容操作与jdk 7 无异。</p>
<p><strong>小结</strong>：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</p>
<h4 id="11-ArrayList-和-LinkedList-的区别是什么"><a href="#11-ArrayList-和-LinkedList-的区别是什么" class="headerlink" title="11.ArrayList 和 LinkedList 的区别是什么"></a>11.ArrayList 和 LinkedList 的区别是什么</h4><p><code>是否线程安全</code>： ArrayList 和 LinkedList 都是不保证线程安全的</p>
<p><code>底层实现</code>： ArrayList 的底层实现是动态数组， LinkedList 的底层是双向链表</p>
<p><code>内存占用</code>： ArrayList 会存在一定的空间浪费，因为每次扩容都是之前的1.5倍，而 LinkedList中的每个元素要存放直接后继和直接前驱以及数据，所以对于每个元素的存储都要比 ArrayList花费更多的空间</p>
<p><code>应用场景</code>： ArrayList 的底层数据结构是数组，所以在插入和删除元素时的时间复杂度都会收到位置的影响，平均时间复杂度为o(n)，在读取元素的时候可以根据下标直接查找到元素，不受位置的影响，平均时间复杂度为o(1)，所以 ArrayList 更加适用于多读，少增删的场景。 LinkedList的底层数据结构是双向链表，所以插入和删除元素不受位置的影响，平均时间复杂度为o(1)，如果是在指定位置插入则是o(n)，因为在插入之前需要先找到该位置，读取元素的平均时间复杂度为o(n)。所以 LinkedList 更加适用于多增删，少读写的场景</p>
<h4 id="12-ArrayList-和-Vector-的区别是什么？"><a href="#12-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="12. ArrayList 和 Vector 的区别是什么？"></a>12. ArrayList 和 Vector 的区别是什么？</h4><ul>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
</ul>
<h4 id="13-ArrayList-和-Array有何区别？"><a href="#13-ArrayList-和-Array有何区别？" class="headerlink" title="13. ArrayList 和 Array有何区别？"></a>13. ArrayList 和 Array有何区别？</h4><ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>
</ul>
<h4 id="14-如何实现数组和-List-之间的转换？"><a href="#14-如何实现数组和-List-之间的转换？" class="headerlink" title="14. 如何实现数组和 List 之间的转换？"></a>14. 如何实现数组和 List 之间的转换？</h4><ul>
<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>
<li>List 转数组：使用 List 自带的 toArray() 方法。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list. add(<span class="string">&quot;王磊&quot;</span>);</span><br><span class="line">list. add(<span class="string">&quot;的博客&quot;</span>);</span><br><span class="line">list. toArray();</span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line">String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;王磊&quot;</span>,<span class="string">&quot;的博客&quot;</span>&#125;;</span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure>

<h4 id="15-在-Queue-中-poll-和-remove-有什么区别？"><a href="#15-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="15. 在 Queue 中 poll()和 remove()有什么区别？"></a>15. 在 Queue 中 poll()和 remove()有什么区别？</h4><ul>
<li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li>
<li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">queue. offer(<span class="string">&quot;string&quot;</span>); <span class="comment">// add</span></span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure>

<h4 id="16-哪些集合类是线程安全的？"><a href="#16-哪些集合类是线程安全的？" class="headerlink" title="16. 哪些集合类是线程安全的？"></a>16. 哪些集合类是线程安全的？</h4><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>
<h4 id="17-迭代器-Iterator-是什么？"><a href="#17-迭代器-Iterator-是什么？" class="headerlink" title="17. 迭代器 Iterator 是什么？"></a>17. 迭代器 Iterator 是什么？</h4><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>
<h4 id="18-Iterator-怎么使用？有什么特点？"><a href="#18-Iterator-怎么使用？有什么特点？" class="headerlink" title="18. Iterator 怎么使用？有什么特点？"></a>18. Iterator 怎么使用？有什么特点？</h4><p>Iterator 使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<h4 id="19-Iterator-和-ListIterator-有什么区别？"><a href="#19-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="19. Iterator 和 ListIterator 有什么区别？"></a>19. Iterator 和 ListIterator 有什么区别？</h4><ul>
<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>
<li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>
</ul>
<h4 id="20-怎么确保一个集合不能被修改？"><a href="#20-怎么确保一个集合不能被修改？" class="headerlink" title="20. 怎么确保一个集合不能被修改？"></a>20. 怎么确保一个集合不能被修改？</h4><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list. add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(<span class="string">&quot;y&quot;</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure>

<h4 id="21-怎样对List-排序？"><a href="#21-怎样对List-排序？" class="headerlink" title="21.怎样对List 排序？"></a>21.怎样对List 排序？</h4><ol>
<li> 对整数列表排序（升序）</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">list.sort(Comparator.naturalOrder());</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">Collections.sort(list);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>对整数列表排序（降序）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">list.sort(Comparator.reverseOrder());</span><br></pre></td></tr></table></figure></li>
<li><p>按照List中对象的id属性升序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Comparator.comparing(User::getId))</span><br></pre></td></tr></table></figure></li>
<li><p>按照List中对象的id属性降序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Comparator.comparing(User::getId).reversed());</span><br></pre></td></tr></table></figure></li>
<li><p>多个条件升序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Comparator.comparing(User::getId).thenComparing(User::getDeId));</span><br></pre></td></tr></table></figure></li>
<li><p> id升序，deId降序</p>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Comparator.comparing(User::getId).reversed().thenComparing(User::getDeId));</span><br></pre></td></tr></table></figure>

<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1. 什么是反射？"></a>1. 什么是反射？</h4><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>
<h4 id="2-什么是-Java-序列化？什么情况下需要序列化？"><a href="#2-什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="2. 什么是 Java 序列化？什么情况下需要序列化？"></a>2. 什么是 Java 序列化？什么情况下需要序列化？</h4><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。</p>
<p>以下情况需要使用 Java 序列化：</p>
<ul>
<li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li>
<li>想用套接字在网络上传送对象的时候；</li>
<li>想通过RMI（远程方法调用）传输对象的时候。</li>
</ul>
<h4 id="3-动态代理是什么？有哪些应用？"><a href="#3-动态代理是什么？有哪些应用？" class="headerlink" title="3. 动态代理是什么？有哪些应用？"></a>3. 动态代理是什么？有哪些应用？</h4><p>动态代理是运行时动态生成代理类。</p>
<p>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p>
<h4 id="4-怎么实现动态代理？"><a href="#4-怎么实现动态代理？" class="headerlink" title="4. 怎么实现动态代理？"></a>4. 怎么实现动态代理？</h4><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p>
<h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><h4 id="1-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><a href="#1-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="1.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"></a>1.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</h4><p><code>是值传递</code>。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。</p>
<h4 id="2-为什么-Java-中只有值传递？"><a href="#2-为什么-Java-中只有值传递？" class="headerlink" title="2.为什么 Java 中只有值传递？"></a>2.为什么 Java 中只有值传递？</h4><ul>
<li><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>
</li>
<li><p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p>
</li>
</ul>
<h4 id="3-值传递和引用传递有什么区别？"><a href="#3-值传递和引用传递有什么区别？" class="headerlink" title="3.值传递和引用传递有什么区别？"></a>3.值传递和引用传递有什么区别？</h4><p><code>值传递</code>：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>
<p><code>引用传递</code>：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>
<h3 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h3><h4 id="1-为什么要使用克隆？"><a href="#1-为什么要使用克隆？" class="headerlink" title="1. 为什么要使用克隆？"></a>1. 为什么要使用克隆？</h4><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p>
<h4 id="2-如何实现对象克隆？"><a href="#2-如何实现对象克隆？" class="headerlink" title="2. 如何实现对象克隆？"></a>2. 如何实现对象克隆？</h4><ul>
<li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。</li>
<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li>
</ul>
<h4 id="3-深拷贝和浅拷贝区别是什么？"><a href="#3-深拷贝和浅拷贝区别是什么？" class="headerlink" title="3. 深拷贝和浅拷贝区别是什么？"></a>3. 深拷贝和浅拷贝区别是什么？</h4><ul>
<li><code>浅拷贝</code>：在拷贝一个对象时，对<code>对象的基本数据类型的成员变量进行拷贝</code>，但<code>对引用类型的成员变量只进行引用的传递，并没有创建一个新的对象</code>，当对引用类型的内容修改会影响被拷贝的对象。</li>
<li><code>深拷贝</code>：在拷贝一个对象时，除了<code>对基本数据类型的成员变量进行拷贝，对引用类型的成员变量进行拷贝时，创建一个新的对象来保存引用类型的成员变量</code>。</li>
</ul>
<blockquote>
<p>深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。<br>假设 B 复制了 A，修改 A 的时候，看 B 是否发生变化：</p>
<ul>
<li>如果 B 跟着也变了，说明是<code>浅拷贝</code>，拿人手短！（修改堆内存中的同一个值）</li>
<li>如果 B 没有改变，说明是<code>深拷贝</code>，自食其力！（修改堆内存中的不同的值）</li>
</ul>
</blockquote>
<h4 id="4-如何实现深拷贝"><a href="#4-如何实现深拷贝" class="headerlink" title="4.如何实现深拷贝"></a>4.如何实现深拷贝</h4><p><code>Java 中 Object 中的 clone 方法默认是浅拷贝，针对引用类型执行的是同一个地址。</code></p>
<ul>
<li>手动赋值，效率高，但代码过于啰嗦。</li>
<li>序列化与反序列化,使用SerializationUtils的clone(Object obj)方法，要求拷贝的对象实现了Serializable。</li>
<li>用fastjson从Object转成json，然后转回object。</li>
</ul>
<h3 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h3><h4 id="1-JSP-和-servlet-有什么区别？"><a href="#1-JSP-和-servlet-有什么区别？" class="headerlink" title="1. JSP 和 servlet 有什么区别？"></a>1. JSP 和 servlet 有什么区别？</h4><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p>
<h4 id="2-JSP-有哪些内置对象？作用分别是什么？"><a href="#2-JSP-有哪些内置对象？作用分别是什么？" class="headerlink" title="2. JSP 有哪些内置对象？作用分别是什么？"></a>2. JSP 有哪些内置对象？作用分别是什么？</h4><p>JSP 有 9 大内置对象：</p>
<ul>
<li>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web 应用的配置对象；</li>
<li>page：JSP 页面本身（相当于 Java 程序中的 this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<h4 id="3-说一下-JSP-的-4-种作用域？"><a href="#3-说一下-JSP-的-4-种作用域？" class="headerlink" title="3. 说一下 JSP 的 4 种作用域？"></a>3. 说一下 JSP 的 4 种作用域？</h4><ul>
<li>page：代表与一个页面相关的对象和属性。</li>
<li>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</li>
<li>application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<h4 id="4-session-和-cookie-有什么区别？"><a href="#4-session-和-cookie-有什么区别？" class="headerlink" title="4. session 和 cookie 有什么区别？"></a>4. session 和 cookie 有什么区别？</h4><ul>
<li>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</li>
<li>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</li>
<li>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。</li>
<li>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</li>
</ul>
<h4 id="5-说一下-session-的工作原理？"><a href="#5-说一下-session-的工作原理？" class="headerlink" title="5. 说一下 session 的工作原理？"></a>5. 说一下 session 的工作原理？</h4><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p>
<h4 id="6-如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#6-如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="6. 如果客户端禁止 cookie 能实现 session 还能用吗？"></a>6. 如果客户端禁止 cookie 能实现 session 还能用吗？</h4><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p>
<h4 id="7-servlet-的生命周期"><a href="#7-servlet-的生命周期" class="headerlink" title="7. servlet 的生命周期"></a>7. servlet 的生命周期</h4><ol>
<li>初始化阶段，调用init()方法</li>
<li>响应客户请求阶段，调用service()方法</li>
<li>终止阶段，调用destroy()方法</li>
</ol>
<h4 id="8-什么是-XSS-攻击，如何避免？"><a href="#8-什么是-XSS-攻击，如何避免？" class="headerlink" title="8. 什么是 XSS 攻击，如何避免？"></a>8. 什么是 XSS 攻击，如何避免？</h4><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</p>
<p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p>
<h4 id="9-什么是-CSRF-攻击，如何避免？"><a href="#9-什么是-CSRF-攻击，如何避免？" class="headerlink" title="9. 什么是 CSRF 攻击，如何避免？"></a>9. 什么是 CSRF 攻击，如何避免？</h4><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p>
<p>防御手段：</p>
<ul>
<li>验证请求来源地址；</li>
<li>关键操作添加验证码；</li>
<li>在请求地址添加 token 并验证。</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="1-throw-和-throws-的区别？"><a href="#1-throw-和-throws-的区别？" class="headerlink" title="1. throw 和 throws 的区别？"></a>1. throw 和 throws 的区别？</h4><ul>
<li>throw：是真实抛出一个异常。</li>
<li>throws：是声明可能会抛出一个异常。</li>
</ul>
<h4 id="2-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#2-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="2. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>2. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h4><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p>
<h4 id="3-final、finally、finalize-有什么区别？"><a href="#3-final、finally、finalize-有什么区别？" class="headerlink" title="3. final、finally、finalize 有什么区别？"></a>3. final、finally、finalize 有什么区别？</h4><ul>
<li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</li>
<li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li>
<li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li>
</ul>
<h4 id="4-try-catch-finally-中哪个部分可以省略？"><a href="#4-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="4. try-catch-finally 中哪个部分可以省略？"></a>4. try-catch-finally 中哪个部分可以省略？</h4><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p>
<h4 id="5-常见的异常类有哪些？"><a href="#5-常见的异常类有哪些？" class="headerlink" title="5. 常见的异常类有哪些？"></a>5. 常见的异常类有哪些？</h4><ul>
<li>NullPointerException 空指针异常</li>
<li>ClassNotFoundException 指定类不存在</li>
<li>NumberFormatException 字符串转换为数字异常</li>
<li>IndexOutOfBoundsException 数组下标越界异常</li>
<li>ClassCastException 数据类型转换异常</li>
<li>FileNotFoundException 文件未找到异常</li>
<li>NoSuchMethodException 方法不存在异常</li>
<li>IOException IO 异常</li>
<li>SocketException Socket 异常</li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="1-Http和https的区别"><a href="#1-Http和https的区别" class="headerlink" title="1.Http和https的区别"></a>1.Http和https的区别</h4><ol>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</li>
</ol>
<h4 id="2-http-响应码"><a href="#2-http-响应码" class="headerlink" title="2.http 响应码"></a>2.http 响应码</h4><ul>
<li>1XX：消息 </li>
<li>2XX：成功 </li>
<li>3XX：重定向 </li>
<li>4XX：请求错误 </li>
<li>5XX、6XX：服务器错误</li>
</ul>
<p><code>200 OK</code>：客户端请求成功。</p>
<p><code>400 Bad Request</code>：客户端请求有语法错误，不能被服务器所理解。</p>
<p><code>401 Unauthorized</code>：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</p>
<p><code>403 Forbidden</code>：服务器收到请求，但是拒绝提供服务。</p>
<p><code>404 Not Found</code>：请求资源不存在，举个例子：输入了错误的URL。</p>
<p><code>500 Internal Server Error</code>：服务器发生不可预期的错误。</p>
<p><code>503 Server Unavailable</code>：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</p>
<h4 id="3-forward-和-redirect-的区别？"><a href="#3-forward-和-redirect-的区别？" class="headerlink" title="3. forward 和 redirect 的区别？"></a>3. forward 和 redirect 的区别？</h4><p>forward 是转发 和 redirect 是重定向：</p>
<ul>
<li>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</li>
<li>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</li>
<li>效率：forward 比 redirect 效率高。</li>
</ul>
<h4 id="4-简述-tcp-和-udp的区别？"><a href="#4-简述-tcp-和-udp的区别？" class="headerlink" title="4. 简述 tcp 和 udp的区别？"></a>4. 简述 tcp 和 udp的区别？</h4><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>两者的区别大致如下：</p>
<ul>
<li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li>
<li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li>
<li>tcp 面向字节流，udp 面向报文；</li>
<li>tcp 数据传输慢，udp 数据传输快；</li>
</ul>
<h4 id="5-tcp-为什么要三次握手"><a href="#5-tcp-为什么要三次握手" class="headerlink" title="5. tcp 为什么要三次握手"></a>5. tcp 为什么要三次握手</h4><img src="/posts/2083621419/image-20220819082717134.png" class="" title="image-20220819082717134">

<p>第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入<strong>SYN_SENT</strong>状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入<strong>SYN_RECV</strong>状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入<strong>ESTABLISHED</strong>（TCP连接成功）状态，完成三次握手。</p>
<h4 id="6-get-和-post-请求有哪些区别？"><a href="#6-get-和-post-请求有哪些区别？" class="headerlink" title="6. get 和 post 请求有哪些区别？"></a>6. get 和 post 请求有哪些区别？</h4><ul>
<li>get 请求会被浏览器主动缓存，而 post 不会。</li>
<li>get 传递参数有大小限制，而 post 没有。</li>
<li>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li>
</ul>
<h4 id="7-如何实现跨域？"><a href="#7-如何实现跨域？" class="headerlink" title="7. 如何实现跨域？"></a>7. 如何实现跨域？</h4><p>实现跨域有以下几种方案：</p>
<ul>
<li>服务器端运行跨域 设置 CORS 等于 *；</li>
<li>在单个接口使用注解 @CrossOrigin 运行跨域；</li>
<li>使用 jsonp 跨域，只能使用 get 请求；</li>
</ul>
<h4 id="8-说一下-JSONP-实现原理？"><a href="#8-说一下-JSONP-实现原理？" class="headerlink" title="8. 说一下 JSONP 实现原理？"></a>8. 说一下 JSONP 实现原理？</h4><p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的<code>JS 函数</code>来执行的。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="1-说一下你熟悉的设计模式？"><a href="#1-说一下你熟悉的设计模式？" class="headerlink" title="1. 说一下你熟悉的设计模式？"></a>1. 说一下你熟悉的设计模式？</h4><ul>
<li>单例模式：保证被创建一次，节省系统开销，饥汉式和懒汉式。</li>
<li>工厂模式（简单工厂、抽象工厂）：解耦代码。</li>
<li>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</li>
<li>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li>
<li>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</li>
<li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li>
</ul>
<h4 id="2-简单工厂和抽象工厂有什么区别？"><a href="#2-简单工厂和抽象工厂有什么区别？" class="headerlink" title="2. 简单工厂和抽象工厂有什么区别？"></a>2. 简单工厂和抽象工厂有什么区别？</h4><ul>
<li>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</li>
<li>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</li>
<li>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</li>
</ul>
<h4 id="3-单例模式代码"><a href="#3-单例模式代码" class="headerlink" title="3.单例模式代码"></a>3.单例模式代码</h4><blockquote>
<p>1.饿汉单例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EhSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">EhSingleton</span> <span class="variable">ehSingleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EhSingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EhSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EhSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ehSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点： 类加载，就初始化，浪费内存<br>优点： 没有加锁，执行效率高。还是线程安全的实例。</p>
<blockquote>
<p>2.懒汉单例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton ehSingleton;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ehSingleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            ehSingleton = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ehSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉单例，在类初始化不会创建实例，只有被调用时才会创建实例。</p>
<p>实例在调用 <code>getInstance</code> 才会创建实例，这样的优点是不占内存，在单线程模式下，是安全的。但是 <code>多线程</code> 模式下，多个线程同时执行 <code>if (ehSingleton == null)</code> 结果都为 <code>true</code>，会创建多个实例，所以上面的懒汉单例是一个线程不安全的实例。</p>
<h3 id="实际面试"><a href="#实际面试" class="headerlink" title="实际面试"></a>实际面试</h3><h4 id="1-请简述一下面向接口编程的意义"><a href="#1-请简述一下面向接口编程的意义" class="headerlink" title="1.请简述一下面向接口编程的意义"></a>1.请简述一下面向接口编程的意义</h4><ul>
<li>代码的灵活性和高可复用性</li>
<li>良好的可扩展性</li>
<li>低耦合</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io">Eric</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io/posts/2083621419/">https://ericwjian.github.io/posts/2083621419/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericwjian.github.io" target="_blank">Eric</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/3620143989/" title="RocketMq 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RocketMq 面试题</div></div></a></div><div class="next-post pull-right"><a href="/posts/2558860022/" title="JUC 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC 面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2037477332/" title="面试其他问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">面试其他问题</div></div></a></div><div><a href="/posts/1514862636/" title="实际面试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">实际面试</div></div></a></div><div><a href="/posts/1514862635/" title="数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">数据结构</div></div></a></div><div><a href="/posts/742890947/" title="Mybatis 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">Mybatis 面试题</div></div></a></div><div><a href="/posts/1636770274/" title="SpringMVC 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">SpringMVC 面试题</div></div></a></div><div><a href="/posts/1218378067/" title="Spring面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">Spring面试题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Eric</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/wangjian_uuid" target="_blank" title="Gitee"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:358070983@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=358070983&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%9F%BA%E7%A1%80"><span class="toc-text">Java 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.Java 有哪些数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-override-%E5%92%8C-overload-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.override 和 overload 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-this-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.this 关键字和 super关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">4.static关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-final-%E5%9C%A8-Java-%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">5.final 在 Java 中有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Java-%E4%B8%AD%E7%9A%84-Math-round-1-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">6.Java 中的 Math. round(-1. 5) 等于多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-float-f-3-4-%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE"><span class="toc-text">7.float f&#x3D;3.4;是否正确</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%BD%93%E5%89%8D%E7%9A%84%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span class="toc-text">8.在Java中，如何跳出当前的多重嵌套循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-i%E5%92%8Ci-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">9.++i和i++的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-return-%E5%92%8C-Break-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">10.return 和 Break 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-text">变量与方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F"><span class="toc-text">1.变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E7%B1%BB"><span class="toc-text">2.构造函数的作用，分为哪几类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E7%9B%B8%E5%85%B3"><span class="toc-text">String 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java-%E4%B8%AD%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB"><span class="toc-text">1.Java 中操作字符串有哪些类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%EF%BC%9F"><span class="toc-text">2.如何将字符串反转？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-text">3.如何将字符串转换为数组？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-String-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD"><span class="toc-text">4.String 类的常用方法都</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-text">5.什么是字符串常量池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="toc-text">6.String为什么是不可变的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF-String-%E7%B1%BB%EF%BC%9F"><span class="toc-text">7.是否可以继承 String 类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-String-%E5%92%8C-new-String-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8.String 和 new String() 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD"><span class="toc-text">对象相等判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.&#x3D;&#x3D; 和 equals 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84-hashCode-%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%88%99-equals-%E4%B9%9F%E4%B8%80%E5%AE%9A%E4%B8%BA-true%EF%BC%8C%E5%AF%B9%E5%90%97%EF%BC%9F"><span class="toc-text">2.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E5%90%8E%EF%BC%8ChashCode%E6%96%B9%E6%B3%95%E4%B9%9F%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99"><span class="toc-text">3.为什么重写equals方法后，hashCode方法也必须重写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">1.面向对象的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%E6%9C%BA%E5%88%B6%EF%BC%9FJava%E8%AF%AD%E8%A8%80%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%EF%BC%9F"><span class="toc-text">2.什么是多态机制？Java语言是如何实现多态的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.多态的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-text">类与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">1.抽象类的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-text">2.抽象类必须要有抽象方法吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%83%BD%E4%BD%BF%E7%94%A8-final-%E4%BF%AE%E9%A5%B0%E5%90%97%EF%BC%9F"><span class="toc-text">3.抽象类能使用 final 修饰吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%99%AE%E9%80%9A%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4.普通类和抽象类有哪些区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5.接口和抽象类有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Java%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">6.Java中接口的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">7.抽象类的意义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B"><span class="toc-text">1.什么是泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B3%9B%E5%9E%8B%E4%B8%ADextends%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.泛型中extends和super的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-text">3.泛型擦除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java-%E4%B8%AD-IO-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-text">1. Java 中 IO 流分为几种？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-BIO%E3%80%81NIO%E3%80%81AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2. BIO、NIO、AIO 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Files-%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">3. Files 的常用方法都有哪些？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9B%B8%E5%85%B3"><span class="toc-text">包装类相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB"><span class="toc-text">1.基本类型和包装类型区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Integer-a-127-%E4%B8%8E-Integer-b-127%E7%9B%B8%E7%AD%89%E5%90%97"><span class="toc-text">2.Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8"><span class="toc-text">集合容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.集合和数组的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Java-%E5%AE%B9%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">2.Java 容器都有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Collection-%E5%92%8C-Collections-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3. Collection 和 Collections 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-List%E3%80%81Set%E3%80%81Map-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4.List、Set、Map 之间的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-HashMap-%E5%92%8C-Hashtable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5. HashMap 和 Hashtable 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-HashMap-%E5%92%8C-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">5.HashMap 和 ConcurrentHashMap 的区别是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E4%BD%BF%E7%94%A8-HashMap-%E8%BF%98%E6%98%AF-TreeMap%EF%BC%9F"><span class="toc-text">6. 如何决定使用 HashMap 还是 TreeMap？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%AF%B4%E4%B8%80%E4%B8%8B-HashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">7. 说一下 HashMap 的实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-HashMap-%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">为什么说 HashMap 不是线程安全的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">HashMap 的扩容机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%AF%B4%E4%B8%80%E4%B8%8B-HashSet-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">8. 说一下 HashSet 的实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-ArrayList-%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">9.ArrayList 的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">10.ArrayList的扩容机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-ArrayList-%E5%92%8C-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">11.ArrayList 和 LinkedList 的区别是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-ArrayList-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">12. ArrayList 和 Vector 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-ArrayList-%E5%92%8C-Array%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">13. ArrayList 和 Array有何区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%92%8C-List-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-text">14. 如何实现数组和 List 之间的转换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E5%9C%A8-Queue-%E4%B8%AD-poll-%E5%92%8C-remove-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">15. 在 Queue 中 poll()和 remove()有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E7%B1%BB%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">16. 哪些集合类是线程安全的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">17. 迭代器 Iterator 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-Iterator-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">18. Iterator 怎么使用？有什么特点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-Iterator-%E5%92%8C-ListIterator-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">19. Iterator 和 ListIterator 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E6%80%8E%E4%B9%88%E7%A1%AE%E4%BF%9D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%EF%BC%9F"><span class="toc-text">20. 怎么确保一个集合不能被修改？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E6%80%8E%E6%A0%B7%E5%AF%B9List-%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-text">21.怎样对List 排序？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-text">1. 什么是反射？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-text">2. 什么是 Java 序列化？什么情况下需要序列化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-text">3. 动态代理是什么？有哪些应用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-text">4. 怎么实现动态代理？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-text">值传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BD%93%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%A2%AB%E5%BD%93%E4%BD%9C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%8E%EF%BC%8C%E6%AD%A4%E6%96%B9%E6%B3%95%E5%8F%AF%E6%94%B9%E5%8F%98%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%B9%B6%E5%8F%AF%E8%BF%94%E5%9B%9E%E5%8F%98%E5%8C%96%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E9%87%8C%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-text">1.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-text">2.为什么 Java 中只有值传递？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3.值传递和引用传递有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D"><span class="toc-text">对象拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%EF%BC%9F"><span class="toc-text">1. 为什么要使用克隆？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%9F"><span class="toc-text">2. 如何实现对象克隆？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">3. 深拷贝和浅拷贝区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">4.如何实现深拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Web"><span class="toc-text">Java Web</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JSP-%E5%92%8C-servlet-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1. JSP 和 servlet 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JSP-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2. JSP 有哪些内置对象？作用分别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B4%E4%B8%80%E4%B8%8B-JSP-%E7%9A%84-4-%E7%A7%8D%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-text">3. 说一下 JSP 的 4 种作用域？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-session-%E5%92%8C-cookie-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4. session 和 cookie 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AF%B4%E4%B8%80%E4%B8%8B-session-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">5. 说一下 session 的工作原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A6%81%E6%AD%A2-cookie-%E8%83%BD%E5%AE%9E%E7%8E%B0-session-%E8%BF%98%E8%83%BD%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-text">6. 如果客户端禁止 cookie 能实现 session 还能用吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-servlet-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">7. servlet 的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">8. 什么是 XSS 攻击，如何避免？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">9. 什么是 CSRF 攻击，如何避免？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-throw-%E5%92%8C-throws-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1. throw 和 throws 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-try-catch-finally-%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C-catch-%E4%B8%AD-return-%E4%BA%86%EF%BC%8Cfinally-%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-text">2. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-final%E3%80%81finally%E3%80%81finalize-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3. final、finally、finalize 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-try-catch-finally-%E4%B8%AD%E5%93%AA%E4%B8%AA%E9%83%A8%E5%88%86%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%EF%BC%9F"><span class="toc-text">4. try-catch-finally 中哪个部分可以省略？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">5. 常见的异常类有哪些？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.Http和https的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-http-%E5%93%8D%E5%BA%94%E7%A0%81"><span class="toc-text">2.http 响应码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-forward-%E5%92%8C-redirect-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3. forward 和 redirect 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%AE%80%E8%BF%B0-tcp-%E5%92%8C-udp%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4. 简述 tcp 和 udp的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-tcp-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">5. tcp 为什么要三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">6. get 和 post 请求有哪些区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="toc-text">7. 如何实现跨域？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%AF%B4%E4%B8%80%E4%B8%8B-JSONP-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">8. 说一下 JSONP 实现原理？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%86%9F%E6%82%89%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">1. 说一下你熟悉的设计模式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2. 简单工厂和抽象工厂有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81"><span class="toc-text">3.单例模式代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E9%9D%A2%E8%AF%95"><span class="toc-text">实际面试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">1.请简述一下面向接口编程的意义</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148432/" title="MyBatis 拦截器">MyBatis 拦截器</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148434/" title="MyBatis 集成druid数据源">MyBatis 集成druid数据源</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1166366203/" title="SQL调优">SQL调优</a><time datetime="2024-07-16T16:00:00.000Z" title="发表于 2024-07-17 00:00:00">2024-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3109398172/" title="ContextHolder">ContextHolder</a><time datetime="2024-07-11T16:00:00.000Z" title="发表于 2024-07-12 00:00:00">2024-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2889834893/" title="SpringCloud Feign">SpringCloud Feign</a><time datetime="2024-07-01T16:00:00.000Z" title="发表于 2024-07-02 00:00:00">2024-07-02</time></div></div></div></div></div></div></main><footer id="footer" style="background: #47577e"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '2N3fEF3CzNAzKwVbFlhSTUuM-gzGzoHsz',
      appKey: '9m41Klhi8IgsrNrbyMnoCHrN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>