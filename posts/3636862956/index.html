<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL面试题 | Eric</title><meta name="author" content="Eric"><meta name="copyright" content="Eric"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、索引相关1、索引是什么?索引是一种数据结构，可以帮助我们快速的进行数据查找。 2、索引的数据结构?索引的数据结构和具体存储引擎的实现有关，在 MySQL 中使用较多的索引有 Hash 索引，B+ 树索引等，而我们经常使用的 InnoDB 存储引擎的默认索引实现为：B+ 树索引。  MyISAM"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://ericwjian.github.io/posts/3636862956/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4dfa2c883c8c4c23f4866185de932236";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-21 09:23:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Eric"><span class="site-name">Eric</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">MySQL面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-10T16:00:00.000Z" title="发表于 2022-06-11 00:00:00">2022-06-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-21T01:23:52.026Z" title="更新于 2023-09-21 09:23:52">2023-09-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="一、索引相关"><a href="#一、索引相关" class="headerlink" title="一、索引相关"></a>一、索引相关</h1><h2 id="1、索引是什么"><a href="#1、索引是什么" class="headerlink" title="1、索引是什么?"></a>1、索引是什么?</h2><p>索引是一种<code>数据结构</code>，可以帮助我们快速的进行数据查找。</p>
<h2 id="2、索引的数据结构"><a href="#2、索引的数据结构" class="headerlink" title="2、索引的数据结构?"></a>2、索引的数据结构?</h2><p>索引的数据结构和具体存储引擎的实现有关，在 MySQL 中使用较多的索引有 <code>Hash 索引</code>，<code>B+ 树索引</code>等，而我们经常使用的 <code>InnoDB 存储引擎</code>的默认索引实现为：B+ 树索引。</p>
<ul>
<li><p>MyISAM 和 InnoDB 都是使用 B+ 树实现主键索引、唯一索引和非主键索引。</p>
</li>
<li><p>InnoDB 是聚集索引, MyISAM 是非聚集索引。</p>
</li>
</ul>
<h2 id="3、索引的优缺点？"><a href="#3、索引的优缺点？" class="headerlink" title="3、索引的优缺点？"></a>3、索引的优缺点？</h2><p><strong>索引的优点</strong></p>
<ul>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>帮助服务器避免排序和临时表。</li>
<li>将随机 IO 变为顺序 IO。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
</ul>
<p><strong>索引的缺点</strong></p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<h2 id="4、MySQL的索引种类"><a href="#4、MySQL的索引种类" class="headerlink" title="4、MySQL的索引种类"></a>4、MySQL的索引种类</h2><ol>
<li>从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index 全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式</li>
<li>从<code>应用层次</code>来分：主键索引、唯一索引，普通索引，复合索引</li>
<li>根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。</li>
</ol>
<blockquote>
<p>平时讲的索引类型一般是指在应用层次的划分。</p>
</blockquote>
<ol>
<li>主键索引：主键索引就是专门为主键字段创建的索引，也属于索引的一种（不允许有空值）。</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值。</li>
<li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。</li>
<li>复合索引：<code>联合索引又叫复合索引</code>， 多列值组成一个索引，专门用于组合搜索，其效率大于索引合并(遵循<code>最左前缀</code>原则)</li>
</ol>
<h2 id="5、Innodb为什么要用自增id作为主键？"><a href="#5、Innodb为什么要用自增id作为主键？" class="headerlink" title="5、Innodb为什么要用自增id作为主键？"></a>5、Innodb为什么要用自增id作为主键？</h2><ul>
<li><p>如果表使用<code>自增主键</code>，那么每次插入新的记录，<code>记录就会顺序添加到当前索引节点的后续位置</code>，当一页写满，就会自动开辟一个新的页。</p>
</li>
<li><p>如果使用非自增主键（如果身份证号或学号等），<code>由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置</code>， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过 OPTIMIZE TABLE（optimize table）来重建表并优化填充页面。</p>
</li>
<li><p>OPTIMIZE TABLE tableName：整理表空间、碎片。</p>
</li>
</ul>
<h2 id="6、BTree索引和B-Tree索引的区别"><a href="#6、BTree索引和B-Tree索引的区别" class="headerlink" title="6、BTree索引和B+Tree索引的区别"></a>6、BTree索引和B+Tree索引的区别</h2><p><strong>B-Tree索引（MySQL使用B+Tree）</strong></p>
<p>B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。</p>
<p><strong>特点:</strong></p>
<ul>
<li>一个节点，多个 k-v对</li>
<li>从左向右，升序</li>
<li>一个key只会出现在一个节点（内节点或叶子节点）中，数据不会重复。</li>
</ul>
<img src="/posts/3636862956/image-20220627210941086.png" class="" title="img">

<p><strong>B+Tree索引</strong></p>
<p>是B-Tree的改进版本，同时也是数据库索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。</p>
<p><strong>特点：</strong></p>
<ul>
<li>一个节点，多个 k-v对</li>
<li>从左向右，升序</li>
<li>B+ 树 内节点，无data</li>
<li>B+ 树：所有key都会出现在叶子节点中（数据会重复）</li>
<li>B+树：相邻的节点有指针相互指向连接（双向）</li>
</ul>
<img src="/posts/3636862956/image-20220627210925187-165926004420619.png" class="" title="img">



<h2 id="7、Hash-索引和-B-树索引有什么区别或者说优劣呢"><a href="#7、Hash-索引和-B-树索引有什么区别或者说优劣呢" class="headerlink" title="7、Hash 索引和 B+ 树索引有什么区别或者说优劣呢?"></a>7、Hash 索引和 B+ 树索引有什么区别或者说优劣呢?</h2><blockquote>
<p>Hash 索引和 B+ 树索引的底层实现原理</p>
</blockquote>
<ul>
<li>hash 索引底层就是 hash 表，进行查找时，调用一次 hash 函数就可以获取到相应的键值，之后进行回表查询获得实际数据。</li>
<li>B+ 树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</li>
</ul>
<blockquote>
<p>不同点：</p>
</blockquote>
<ul>
<li><code>hash 索引进行等值查询更快(一般情况下)，但是却无法进行范围查询，索引的顺序无法保证</code>。</li>
<li><code>hash 索引不支持使用索引进行排序，索引的顺序无法保证</code>。</li>
<li>hash 索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为 hash 函数的不可预测。</li>
<li>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询</li>
<li>hash 索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，<code>发生 hash 碰撞</code>，此时效率可能极差。而 B+ 树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li>
<li>虽然可以快速定位，但是没有顺序，IO复杂度高；</li>
<li>适合等值查询，如=、in()、&lt;=&gt;，不支持范围查询 ；</li>
<li>因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成排序 ；</li>
<li>Hash索引在查询等值时非常快 ；</li>
<li>因为Hash索引始终索引的所有列的全部内容，所以不支持部分索引列的匹配查找 ；</li>
</ul>
<p>因此，在大多数情况下，直接选择 B+ 树索引可以获得稳定且较好的查询速度。而不需要使用 hash 索引。</p>
<h2 id="8、-索引为什么使用B-树而不是B树"><a href="#8、-索引为什么使用B-树而不是B树" class="headerlink" title="8、 索引为什么使用B+树而不是B树"></a>8、 索引为什么使用B+树而不是B树</h2><blockquote>
<p>索引在计算机中的位置</p>
</blockquote>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。判断一种数据结构作为索引的优劣主要是看在查询过程中的磁盘IO渐进复杂度，一个好的索引应该是<code>尽量减少磁盘IO操作次数</code>。</p>
<blockquote>
<p>为什么使用B+树</p>
</blockquote>
<ol>
<li><p>B树只适合随机检索，而<code>B+树同时支持随机检索和顺序检索</code>;</p>
</li>
<li><p><code>B+树空间利用率更高</code></p>
<p>因为B+树的<code>内部节点（非叶子节点，也称索引节点）</code>不存储数据，<code>只存储索引值</code>，相比较B树来说，B+树一个节点可存储更多的索引值，使得整颗B+树变得更矮，减少I/O次数，磁盘读写代价更低，I/O读写次数是影响索引检索效率的最大因素;</p>
</li>
<li><p><code>B+树查询效率更加稳定</code></p>
<p>因为在B+树中，<code>顺序检索比较明显</code>，随机检索时，由于B+树所有的 data 域（结点中存储数据元素的部分）都在页节点，<code>任何关键字的查找都必须走一条从根节点到叶节点的路</code>，<code>所有关键字的查找路径相同</code>，导致每一个关键字的查询效率基本相同，时间复杂度固定为 O(log n)；而B树搜索有可能会在非叶子节点结束，约靠近根节点的记录查找时间越短，其性能等价于在关键字全集内做一次二分查找，查询时间复杂度不固定，与 key 在树中的位置有关，最好情况为O(1)；</p>
</li>
<li><p><code>B+树范围查询性能更优</code></p>
<p>因为<code>B+树的叶子节点使用了指针顺序（链表）从小到大地连接在一起</code>，B+树叶节点两两相连可大大增加区间访问性，只要遍历叶子节点就可以实现整棵树的遍历，而B树的叶子节点是相互独立的，每个节点 key（索引）和 data 在一起，则无法查找区间；</p>
</li>
<li><p><code>B+树增删文件（节点）时，效率更高</code></p>
<p>因为B+树的叶子节点包含了所有关键字，并以有序的链表结构存储。</p>
</li>
</ol>
<h2 id="9、MyISAM和InnoDB实现B-树索引方式的区别是什么？"><a href="#9、MyISAM和InnoDB实现B-树索引方式的区别是什么？" class="headerlink" title="9、MyISAM和InnoDB实现B+树索引方式的区别是什么？"></a>9、MyISAM和InnoDB实现B+树索引方式的区别是什么？</h2><ol>
<li><p>MyISAM，索引文件和数据文件是分离的，B+Tree叶节点的data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为 <code>非聚簇索引</code>。</p>
</li>
<li><p>InnoDB，其<code>数据文件本身就是索引文件</code>，其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”或者聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<code>在根据主键索引搜索时，直接找到key所在的节点即可取出数据；根据辅助索引查找时，则需要先取出主键的值，再走一遍主键索引</code>。 因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
</li>
</ol>
<p>总结：InnoDB 主键索引使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。</p>
<h2 id="10、什么是聚簇索引"><a href="#10、什么是聚簇索引" class="headerlink" title="10、什么是聚簇索引"></a>10、什么是聚簇索引</h2><p>聚簇索引就是基于主键创建的索引，除了主键索引以外的索引都称为非聚簇索引；聚簇索引的每个叶子节点都存储了这个表的行数据，聚簇索引并不仅仅是一种索引类型，更是一种数据存储方式；</p>
<p>聚簇索引就是按照每张表的<code>主键</code>构造一棵B+树，同时叶子节点中存放的就是整张表的行记录数据。</p>
<p>在 InnoDB 中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则MySQL自动为InnoDB表生成一个隐含字段来建立聚簇索引，这个字段长度为6个字节，类型为长整形。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<h2 id="11、聚簇索引和非聚簇索引的区别"><a href="#11、聚簇索引和非聚簇索引的区别" class="headerlink" title="11、聚簇索引和非聚簇索引的区别"></a>11、聚簇索引和非聚簇索引的区别</h2><blockquote>
<ul>
<li>聚簇索引： 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</li>
<li>非聚簇索引：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置</li>
</ul>
</blockquote>
<ul>
<li>聚簇索引的叶子节点存放的是主键值和数据行，支持覆盖索引</li>
<li>非聚簇索引的叶子节点存放的是主键值或数据记录的地址（InnoDB辅助索引的data域存储相应记录主键的值，MyISAM辅助索引的data域保存数据记录的地址）</li>
</ul>
<h2 id="12、非聚簇索引一定会回表查询吗"><a href="#12、非聚簇索引一定会回表查询吗" class="headerlink" title="12、非聚簇索引一定会回表查询吗?"></a>12、非聚簇索引一定会回表查询吗?</h2><p><code>不一定，这涉及到查询语句所要求的字段是否全部命中了索引</code>，如果全部命中了索引，那么就不必再进行回表查询。</p>
<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行<code>select age from employee where age &lt; 20</code> 的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p>
<h2 id="13、覆盖索引是什么？"><a href="#13、覆盖索引是什么？" class="headerlink" title="13、覆盖索引是什么？"></a>13、覆盖索引是什么？</h2><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称 之为“<code>覆盖索引</code>”。</p>
<p>我们知道在InnoDB存储引 擎中，如果不是主键索引，叶子节点存储的是主键值。最终还是要“回表”，也就是要通过主键再查找一次,这样就 会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<h2 id="14、联合索引是什么-为什么需要注意联合索引中的顺序"><a href="#14、联合索引是什么-为什么需要注意联合索引中的顺序" class="headerlink" title="14、联合索引是什么?为什么需要注意联合索引中的顺序?"></a>14、联合索引是什么?为什么需要注意联合索引中的顺序?</h2><p><code>MySQL 可以使用多个字段同时建立一个索引，叫做联合索引</code>。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>
<p>具体原因为：</p>
<p>MySQL 使用索引时需要索引有序，假设现在建立了 “name,age,school” 的联合索引，那么索引的排序为：先按照name排序，如果 name 相同，则按照 age 排序，如果 age 的值也相等，则按照 school 进行排序。</p>
<p>当进行查询时，此时索引仅仅按照 name 严格有序，因此必须首先使用 name 字段进行等值查询，之后对于匹配到的列而言，其按照 age 字段严格有序，此时可以使用 age 字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p>
<h2 id="15、索引失效情况"><a href="#15、索引失效情况" class="headerlink" title="15、索引失效情况"></a>15、索引失效情况</h2><ol>
<li><p><code>like 以通配符 % 开头索引失效</code></p>
<p>在查询语句中使用 LIKE 关键字进行查询时，如果匹配字符串的第一个字符为“%”，索引不会被使用。如果“%”不是在第一个位置，索引就会被使用。</p>
</li>
<li><p>查询语句中使用复合索引 （<code>最左前缀</code>）</p>
<p>复合(l联合)索引是在表的多个字段上创建一个索引，只有查询条件中使用了这些字段中的第一个字段，索引才会被使用。（也就是最佳左前缀匹配法，索引的顺序是不能调整的，能调整的是 where 条件的顺序）。</p>
</li>
<li><p><code>OR 前后只要存在非索引的列，都会导致索引失效</code> </p>
<p>查询语句只有OR关键字时，如果OR前后的两个条件的列都是索引，那么查询中将使用索引。如果OR前后有一个条件的列不是索引，那么查询中将不使用索引。</p>
</li>
<li><p><code>计算，函数，类型转换(手动或自动)会导致索引失效</code></p>
</li>
<li><p><code>范围条件右边的索引会失效</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 创建一个联合索引， 注意字段的顺序</span></span><br><span class="line">create index idx<span class="emphasis">_age_</span>classid<span class="emphasis">_name on student(age,classid,name);</span></span><br><span class="line"><span class="emphasis"># 执行计划</span></span><br><span class="line"><span class="emphasis">EXPLAIN SELECT SQL_</span>NO<span class="emphasis">_CACHE * FROM student</span></span><br><span class="line"><span class="emphasis">WHERE student .age = 30 AND student .classId &gt; 20 AND student .name = &#x27;abc&#x27; ;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 再创建一个联合索引，与上面的索引对比字段顺序变了</span></span><br><span class="line"><span class="emphasis">create index idx_</span>age<span class="emphasis">_name_</span>classid on student(age,name,classid); </span><br><span class="line"><span class="section"># 再执行一模一样的执行计划</span></span><br><span class="line">EXPLAIN SELECT SQL<span class="emphasis">_NO_</span>CACHE * FROM student</span><br><span class="line">WHERE student .age = 30 AND student .classId &gt; 20 AND student .name = &#x27;abc&#x27; ;</span><br><span class="line"></span><br><span class="line"><span class="section"># 测试结果：两个执行计划虽然都用到了索引，但是：</span></span><br><span class="line"><span class="bullet">-</span> 第一个没用全，只用到了联合索引“idx<span class="emphasis">_age_</span>classid<span class="emphasis">_name” 的age和classid。</span></span><br><span class="line"><span class="emphasis">- 第二个把联合索引“idx_</span>age<span class="emphasis">_name_</span>classid”的age，name和classid都用上了。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>is null可以使用索引，is not null无法使用索引</code></p>
</li>
<li><p><code>不等于(!= 或者&lt;&gt;)导致索引失效</code></p>
</li>
<li><p><code>使用in导致索引失效</code>。</p>
</li>
<li><p>当 mysql 分析全表扫描比使用索引快的时候不使用索引。</p>
</li>
</ol>
<p>以上情况，MySQL无法使用索引。</p>
<h2 id="16、创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因"><a href="#16、创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因" class="headerlink" title="16、创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?"></a>16、创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?</h2><p>MySQL 提供了 <code>explain </code>命令来查看语句的执行计划，MySQL 在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引，例如<code>possilbe_key，key，key_len</code>等字段，分别说明了此语句可能会使用的索引，实际使用的索引以及使用的索引长度。</p>
<p>“执行计划”中需要知道的几个“关键字”</p>
<ul>
<li><p>id ：编号</p>
</li>
<li><p>select_type ：查询类型</p>
</li>
<li><p>table ：表</p>
</li>
<li><p>type ：类型</p>
</li>
<li><p>possible_keys ：预测用到的索引</p>
</li>
<li><p>key ：实际使用的索引</p>
</li>
<li><p>key_len ：实际使用索引的长度</p>
</li>
<li><p>ref ：表之间的引用</p>
</li>
<li><p>rows ：通过索引查询到的数据量</p>
</li>
<li><p>Extra ：额外的信息</p>
</li>
</ul>
<h2 id="17、索引在什么情况下遵循最左前缀的规则？"><a href="#17、索引在什么情况下遵循最左前缀的规则？" class="headerlink" title="17、索引在什么情况下遵循最左前缀的规则？"></a>17、索引在什么情况下遵循最左前缀的规则？</h2><p>在建立了联合索引的前提条件下，数据库会一直从左向右的顺序依次查找，直到遇到了范围查询(&gt;,&lt;,between,like等)</p>
<h1 id="二、事务相关"><a href="#二、事务相关" class="headerlink" title="二、事务相关"></a>二、事务相关</h1><h2 id="1、什么是事务"><a href="#1、什么是事务" class="headerlink" title="1、什么是事务?"></a>1、什么是事务?</h2><p>事务是一系列的数据库操作，他们要符合 ACID 特性，事务是数据库应用的基本单位。MySQL 事务主要用于处理操作量大，复杂度高的数据。</p>
<h2 id="2、ACID是什么"><a href="#2、ACID是什么" class="headerlink" title="2、ACID是什么?"></a>2、ACID是什么?</h2><ul>
<li><p><code>A=Atomicity</code>：原子性，就是要么全部成功，要么全部失败。不可能只执行一部分操作。</p>
</li>
<li><p><code>C=Consistency</code>：一致性，系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态，不会存在中间状态。</p>
</li>
<li><p><code>I=Isolation</code>：隔离性，通常来说：一个事务在完全提交之前，对其他事务是不可见的.注意前面的通常来说加了红色，意味着有例外情况。</p>
</li>
<li><p><code>D=Durability</code>：持久性，一旦事务提交，那么就永远是这样子了，哪怕系统崩溃也不会影响到这个事务的结果。</p>
</li>
</ul>
<h2 id="3、MySQL中为什么要有事务回滚机制？"><a href="#3、MySQL中为什么要有事务回滚机制？" class="headerlink" title="3、MySQL中为什么要有事务回滚机制？"></a>3、MySQL中为什么要有事务回滚机制？</h2><p>而在 MySQL 中，<code>恢复机制是通过回滚日志（undo log）实现的</code>，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。<code>当事务已经被提交之后，就无法再次回滚了</code>。</p>
<p>回滚日志作用：</p>
<ol>
<li>能够在发生错误或者用户执行 <code>rollback </code>时提供回滚相关的信息</li>
<li>在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。</li>
</ol>
<h2 id="4、数据库并发事务会带来哪些问题？"><a href="#4、数据库并发事务会带来哪些问题？" class="headerlink" title="4、数据库并发事务会带来哪些问题？"></a>4、数据库并发事务会带来哪些问题？</h2><p>数据库并发事务会带来 <code>脏读、不可重复读、幻读</code> 这四个常见问题，其中：</p>
<p><code>脏读</code>：<code>A 事务</code>读取到了 <code>B 事务</code>未提交的内容，但是之后B事务满足一致性等特性而做了回滚操作，那么读取事务得到的结果就是脏数据了。</p>
<p><code>不可重复读</code>：当设置T2事务只能读取 T1 事务已经提交的部分，T2 读取一个数据，然后T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><code>幻读</code>：A 事务读取了一个范围的内容，而同时 B 事务在此期间插入（删除）了一条数据。造成”幻觉”。</p>
<h2 id="5、MySQL-的事务隔离级别了解吗"><a href="#5、MySQL-的事务隔离级别了解吗" class="headerlink" title="5、MySQL 的事务隔离级别了解吗?"></a>5、MySQL 的事务隔离级别了解吗?</h2><p>MySQL 的四种隔离级别如下：</p>
<ul>
<li><code>未提交读(READ UNCOMMITTED)</code>：<code>事务</code>中发生了修改，即使没有提交，<code>其他事务</code>也是可见的，可能会导致脏读、幻读或不可重复读。</li>
<li><code>已提交读(READ COMMITTED)</code>：对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的，举例就是对于一个数A原来是50，然后提交修改成100，这个时候另一个事务在A提交修改之前，读取的A是50，刚读取完，A就被修改成100，这个时候另一个事务再进行读取发现A就突然变成100了；可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li><code>可重复读(REPEATABLE READ)</code>：就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的；可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><code>可串行化(SERIALIZABLE)</code>：在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比如不会发生脏读和幻读；该级别可以防止脏读、不可重复读以及幻读</li>
</ul>
<img src="/posts/3636862956/image-20220811184247053.png" class="" title="image-20220811184247053">

<p><code>innodb 在可重复读的隔离级别下，通过 创建 快照读，来避免幻读的发生。</code></p>
<h2 id="6、Innodb使用的是哪种隔离级别呢"><a href="#6、Innodb使用的是哪种隔离级别呢" class="headerlink" title="6、Innodb使用的是哪种隔离级别呢?"></a>6、Innodb使用的是哪种隔离级别呢?</h2><p><code>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重复读）</code></p>
<p><code>原因</code>： 与 SQL 标准不同的地方在于InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别 下使用的是 Next-Key Lock 锁算法 ，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以 说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要 求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别。</p>
<p><code>InnoDB 存储引擎在分布式事务 的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。</code></p>
<h1 id="三、锁相关"><a href="#三、锁相关" class="headerlink" title="三、锁相关"></a>三、锁相关</h1><h2 id="1、对-MySQL-的锁了解吗"><a href="#1、对-MySQL-的锁了解吗" class="headerlink" title="1、对 MySQL 的锁了解吗?"></a>1、对 MySQL 的锁了解吗?</h2><p><code>当数据库有并发事务的时候,可能会产生数据的不一致,这时候需要一些机制来保证访问的次序,锁机制就是这样的一个机制.</code></p>
<p>就像酒店的房间,如果大家随意进出,就会出现多人抢夺同一个房间的情况,而在房间上装上锁,申请到钥匙的人才可以</p>
<p>入住并且将房间锁起来,其他人只有等他使用完毕才可以再次使用。</p>
<h2 id="2、MySQL-锁的分类"><a href="#2、MySQL-锁的分类" class="headerlink" title="2、MySQL 锁的分类"></a>2、MySQL 锁的分类</h2><p>Mysql中锁的分类按照不同类型的划分可以分成不同的锁：</p>
<p>按照 <code>锁的粒度</code> 划分可以分成：</p>
<ul>
<li>行锁</li>
<li>表锁</li>
<li>页锁</li>
</ul>
<p>按照 <code>使用的方式 </code>划分可以分为：</p>
<ul>
<li>共享锁</li>
<li>排它锁</li>
</ul>
<p>按照 <code>思想 </code>的划分：</p>
<ul>
<li>乐观锁</li>
<li>悲观锁</li>
</ul>
<h2 id="3、行级锁、表级锁、页级锁的描述与特点"><a href="#3、行级锁、表级锁、页级锁的描述与特点" class="headerlink" title="3、行级锁、表级锁、页级锁的描述与特点"></a>3、行级锁、表级锁、页级锁的描述与特点</h2><p><code>行级锁</code>：</p>
<ul>
<li>描述：行级锁是mysql中锁定粒度最细的一种锁。表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁</li>
<li>特点：开销大，加锁慢，会出现死锁。发生锁冲突的概率最低，并发度也最高。</li>
</ul>
<p><code>表级锁：</code></p>
<ul>
<li>描述：表级锁是mysql中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分mysql引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）</li>
<li>特点： 开销小，加锁快，不会出现死锁。发生锁冲突的概率最高，并发度也最低。</li>
</ul>
<p><code>页级锁：</code></p>
<ul>
<li><p>描述：页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。BDB 支持页级锁。</p>
</li>
<li><p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>
</li>
</ul>
<h2 id="4、共享锁-、-排他锁的描述"><a href="#4、共享锁-、-排他锁的描述" class="headerlink" title="4、共享锁 、 排他锁的描述"></a>4、共享锁 、 排他锁的描述</h2><p><code>共享锁：</code></p>
<blockquote>
<p>描述：</p>
</blockquote>
<ul>
<li>共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。</li>
<li>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。</li>
</ul>
<blockquote>
<p>用法：</p>
</blockquote>
<ul>
<li>SELECT … LOCK IN SHARE MODE;</li>
<li>在查询语句后面增加LOCK IN SHARE MODE，MySQL 就会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</li>
</ul>
<p><code>排他锁：</code></p>
<blockquote>
<p>描述：</p>
</blockquote>
<ul>
<li>排他锁又称写锁、独占锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</li>
</ul>
<blockquote>
<p>用法：</p>
</blockquote>
<ul>
<li>SELECT … FOR UPDATE;</li>
<li>在查询语句后面增加FOR UPDATE，MySQL 就会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。</li>
</ul>
<blockquote>
<p>用上面的例子来说就是用户的行为有两种,一种是来看房,多个用户一起看房是可以接受的. 一种是真正的入住一晚,在这期间,无论是想入住的还是想看房的都不可以.</p>
</blockquote>
<h2 id="5、悲观锁与乐观锁"><a href="#5、悲观锁与乐观锁" class="headerlink" title="5、悲观锁与乐观锁"></a>5、悲观锁与乐观锁</h2><p>**乐观锁(Optimistic Lock)**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</p>
<p>乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>
<p>**悲观锁(Pessimistic Lock)**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<h2 id="6、数据库悲观锁和乐观锁的原理和应用场景分别有什么？"><a href="#6、数据库悲观锁和乐观锁的原理和应用场景分别有什么？" class="headerlink" title="6、数据库悲观锁和乐观锁的原理和应用场景分别有什么？"></a>6、数据库悲观锁和乐观锁的原理和应用场景分别有什么？</h2><p><code>悲观锁</code>，先获取锁，再进行业务操作，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。当数据库执行SELECT … FOR UPDATE时会获取被select中的数据行的行锁，select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p>
<p><code>乐观锁</code>，先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过。Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p>
<h2 id="7、MySQL常用存储引擎的锁机制？"><a href="#7、MySQL常用存储引擎的锁机制？" class="headerlink" title="7、MySQL常用存储引擎的锁机制？"></a>7、MySQL常用存储引擎的锁机制？</h2><ul>
<li><p>MyISAM和MEMORY采用表级锁(table-level locking)</p>
</li>
<li><p>BDB采用页面锁(page-level locking)或表级锁，默认为页面锁</p>
</li>
<li><p>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</p>
</li>
</ul>
<h2 id="8、InnoDB-存储引擎有几种锁算法？"><a href="#8、InnoDB-存储引擎有几种锁算法？" class="headerlink" title="8、InnoDB 存储引擎有几种锁算法？"></a>8、InnoDB 存储引擎有几种锁算法？</h2><ul>
<li>Record Lock — 单个行记录上的锁；</li>
<li>Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；</li>
<li>Next-Key Lock — 锁定一个范围，包括记录本身。</li>
</ul>
<h2 id="9、什么是死锁？"><a href="#9、什么是死锁？" class="headerlink" title="9、什么是死锁？"></a>9、什么是死锁？</h2><p>是指二个或者二个以上的进程在执行时候，因为争夺资源造成相互等待的现象，进程一直处于等待中，无法得到释放，这种状态就叫做死锁。</p>
<h2 id="10、死锁出现的案列？"><a href="#10、死锁出现的案列？" class="headerlink" title="10、死锁出现的案列？"></a>10、死锁出现的案列？</h2><p>批量入库，存在则更新，不存在则插入，insert into tab(xx,xx) on duplicate key update xx=‘xx’。</p>
<h2 id="11、如何处理死锁？"><a href="#11、如何处理死锁？" class="headerlink" title="11、如何处理死锁？"></a>11、如何处理死锁？</h2><ol>
<li>通过innodblockwait_timeout来设置超时时间，一直等待直到超时</li>
<li>发起死锁检测，发现死锁之后，主动回滚死锁中的事务，不需要其他事务继续</li>
</ol>
<h2 id="12、如何避免死锁？"><a href="#12、如何避免死锁？" class="headerlink" title="12、如何避免死锁？"></a>12、如何避免死锁？</h2><ol>
<li>为了在单个innodb表上执行多个并发写入操作时避免死锁，可以在事务开始时，通过为预期要修改行，使用select …for update语句来获取必要的锁，即使这些行的更改语句是在之后才执行的</li>
<li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时在申请排他锁。因为这时候当用户在申请排他锁时，其他事务可能又已经获得了相同记录的共享锁</li>
<li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发获取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li>
<li>通过 select …lock in share mode获取行的读锁后，如果当前事务在需要对该记录进行更新操作，则很有可能造成死锁</li>
<li>改变事务隔离级别</li>
</ol>
<h2 id="13、Innodb默认是如何对待死锁的？"><a href="#13、Innodb默认是如何对待死锁的？" class="headerlink" title="13、Innodb默认是如何对待死锁的？"></a>13、Innodb默认是如何对待死锁的？</h2><p>innodb默认是使用设置死锁时间来让死锁超时的策略，默认<code>innodblockwait_timeout</code>设置的时长是50s</p>
<h2 id="14、如何开启死锁检测？"><a href="#14、如何开启死锁检测？" class="headerlink" title="14、如何开启死锁检测？"></a>14、如何开启死锁检测？</h2><p>设置<code>innodbdeadlockdetect</code>设置为on可以主动检测死锁，在innodb中这个值默认就是on开启的状态</p>
<h2 id="15、什么是全局锁？它的应用场景有哪些？"><a href="#15、什么是全局锁？它的应用场景有哪些？" class="headerlink" title="15、什么是全局锁？它的应用场景有哪些？"></a>15、什么是全局锁？它的应用场景有哪些？</h2><p>全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全库逻辑备份，这个命令可以使用整个库处于只读状态，使用该命令之后，数据更新语句，数据定义语句，更新类事务的提交语句等操作都会被阻塞。</p>
<h2 id="16、使用全局锁会导致的问题？"><a href="#16、使用全局锁会导致的问题？" class="headerlink" title="16、使用全局锁会导致的问题？"></a>16、使用全局锁会导致的问题？</h2><ul>
<li>如果在主库备份，在备份期间不能更新，业务停止，所以更新业务会处于等待状态</li>
<li>如果在从库备份，在备份期间不能执行主库同步的binlog，导致主从延迟</li>
</ul>
<h2 id="17、优化锁方面你有什么建议？"><a href="#17、优化锁方面你有什么建议？" class="headerlink" title="17、优化锁方面你有什么建议？"></a>17、优化锁方面你有什么建议？</h2><ul>
<li>尽量使用较低的隔离级别。</li>
<li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。</li>
<li>选择合理的事务大小，小事务发生锁冲突的几率也更小。</li>
<li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</li>
<li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会。</li>
<li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li>
<li>不要申请超过实际需要的锁级别。</li>
<li>除非必须，查询时不要显示加锁。 MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能；MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作。</li>
<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li>
</ul>
<h1 id="四、存储引擎相关"><a href="#四、存储引擎相关" class="headerlink" title="四、存储引擎相关"></a>四、存储引擎相关</h1><h2 id="1、MySQL-支持哪些存储引擎"><a href="#1、MySQL-支持哪些存储引擎" class="headerlink" title="1、MySQL 支持哪些存储引擎?"></a>1、MySQL 支持哪些存储引擎?</h2><p>MySQL 支持多种存储引擎，比如 InnoDB，MyISAM，Memory，Archive等等。在大多数的情况下，直接选择使用 InnoDB 引擎都是最合适的，<code>InnoDB </code>也是 MySQL 的默认存储引擎。</p>
<h2 id="2、InnoDB-和-MyISAM-有什么区别"><a href="#2、InnoDB-和-MyISAM-有什么区别" class="headerlink" title="2、InnoDB 和 MyISAM 有什么区别?"></a>2、InnoDB 和 MyISAM 有什么区别?</h2><p><code>InnoDB</code></p>
<ul>
<li>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</li>
<li>实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读。</li>
<li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</li>
<li>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</li>
<li>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</li>
</ul>
<p><code>MyISAM</code></p>
<ul>
<li>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</li>
<li>提供了大量的特性，包括压缩表、空间数据索引等。</li>
<li><code>不支持事务</code>。</li>
<li>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。</li>
</ul>
<p><code>总结：</code></p>
<ul>
<li>InnoDB 支持事物，而 MyISAM 不支持事物</li>
<li>InnoDB 支持行级锁，表锁，而 MyISAM 支持表级锁</li>
<li>InnoDB 支持 MVCC，而 MyISAM 不支持</li>
<li>InnoDB 支持外键，而 MyISAM 不支持</li>
<li>InnoDB5.7之前不支持全文索引，而 MyISAM 支持</li>
<li>nnoDB必须有主键，没有指定会默认生成一个隐藏列作为主键，而MyISAM可以没有</li>
</ul>
<h2 id="3、你了解MySQL的内部构造吗？一般可以分为哪两个部分？"><a href="#3、你了解MySQL的内部构造吗？一般可以分为哪两个部分？" class="headerlink" title="3、你了解MySQL的内部构造吗？一般可以分为哪两个部分？"></a>3、你了解MySQL的内部构造吗？一般可以分为哪两个部分？</h2><p>可以分为<code>服务层</code>和<code>存储引擎层</code>两部分，其中：</p>
<blockquote>
<p>服务层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
</blockquote>
<blockquote>
<p>存储引擎层负责数据的存储和提取。 其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始成为了默认的存储引擎。</p>
</blockquote>
<img src="/posts/3636862956/165642991105129.png" class="" title="在这里插入图片描述">

<h2 id="4、说一下MySQL是如何执行一条SQL的？具体步骤有哪些？"><a href="#4、说一下MySQL是如何执行一条SQL的？具体步骤有哪些？" class="headerlink" title="4、说一下MySQL是如何执行一条SQL的？具体步骤有哪些？"></a>4、说一下MySQL是如何执行一条SQL的？具体步骤有哪些？</h2><p><strong>Server层按顺序执行sql的步骤为：</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.客户端请求-&gt;</span><br><span class="line">2.连接器（验证用户身份，给予权限） -&gt;</span><br><span class="line">3.查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt;</span><br><span class="line">4.分析器（对SQL进行词法分析和语法分析操作） -&gt;</span><br><span class="line">5.优化器（主要对执行的sql优化选择最优的执行方案方法） -&gt;</span><br><span class="line">6.执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-&gt;</span><br><span class="line">7.去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</span><br></pre></td></tr></table></figure>

<p><strong>简单概括：</strong></p>
<ul>
<li>连接器：管理连接、权限验证；</li>
<li>查询缓存：命中缓存则直接返回结果；</li>
<li>分析器：对SQL进行词法分析、语法分析；（判断查询的SQL字段是否存在也是在这步）</li>
<li>优化器：执行计划生成、选择索引；</li>
<li>执行器：操作引擎、返回结果；</li>
<li>存储引擎：存储数据、提供读写接口。</li>
</ul>
<h2 id="5、SQL-的执行顺序？"><a href="#5、SQL-的执行顺序？" class="headerlink" title="5、SQL 的执行顺序？"></a>5、SQL 的执行顺序？</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">    <span class="operator">&lt;</span> select_list <span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    <span class="operator">&lt;</span> left_table <span class="operator">&gt;</span> <span class="operator">&lt;</span> join_type <span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">JOIN</span> <span class="operator">&lt;</span> right_table <span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span> join_condition <span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="operator">&lt;</span> where_condition <span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    <span class="operator">&lt;</span> group_by_list <span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    <span class="operator">&lt;</span> having_condition <span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    <span class="operator">&lt;</span> order_by_condition <span class="operator">&gt;</span></span><br><span class="line">LIMIT <span class="operator">&lt;</span> limit_number <span class="operator">&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它的执行顺序你知道吗？这道题就给你一个回答。</p>
<p><strong>FROM 连接</strong></p>
<blockquote>
<p>首先，对 SELECT 语句执行查询时，对FROM 关键字两边的表执行连接，会形成笛卡尔积，这时候会产生一个虚表VT1(virtual table)</p>
</blockquote>
<p><strong>ON 过滤</strong></p>
<blockquote>
<p>然后对 FROM 连接的结果进行 ON 筛选，创建 VT2，把符合记录的条件存在 VT2 中。</p>
</blockquote>
<p><strong>JOIN 连接</strong></p>
<blockquote>
<p>第三步，如果是 OUTER JOIN(left join、right join) ，那么这一步就将添加外部行，如果是 left join 就把 ON 过滤条件的左表添加进来，如果是 right join ，就把右表添加进来，从而生成新的虚拟表 VT3。</p>
</blockquote>
<p><strong>WHERE 过滤</strong></p>
<blockquote>
<p>第四步，是执行 WHERE 过滤器，对上一步生产的虚拟表引用 WHERE 筛选，生成虚拟表 VT4。</p>
</blockquote>
<p><strong>GROUP BY</strong></p>
<blockquote>
<p>根据 group by 字句中的列，会对 VT4 中的记录进行分组操作，产生虚拟机表 VT5。果应用了group by，那么后面的所有步骤都只能得到的 VT5 的列或者是聚合函数（count、sum、avg等）。</p>
</blockquote>
<p><strong>HAVING</strong></p>
<blockquote>
<p>紧跟着 GROUP BY 字句后面的是 HAVING，使用 HAVING 过滤，会把符合条件的放在 VT6</p>
</blockquote>
<p><strong>SELECT</strong></p>
<blockquote>
<p>第七步才会执行 SELECT 语句，将 VT6 中的结果按照 SELECT 进行刷选，生成 VT7</p>
</blockquote>
<p><strong>DISTINCT</strong></p>
<blockquote>
<p>在第八步中，会对 TV7 生成的记录进行去重操作，生成 VT8。事实上如果应用了 group by 子句那么 distinct 是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。</p>
</blockquote>
<p><strong>ORDER BY</strong></p>
<blockquote>
<p>应用 order by 子句。按照 order_by_condition 排序 VT8，此时返回的一个游标，而不是虚拟表。sql 是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。</p>
</blockquote>
<h2 id="6、简述触发器、函数、视图、存储过程？"><a href="#6、简述触发器、函数、视图、存储过程？" class="headerlink" title="6、简述触发器、函数、视图、存储过程？"></a>6、简述触发器、函数、视图、存储过程？</h2><ul>
<li><strong>触发器</strong>：使用触发器可以定制用户对表进行【增、删、改】操作时前后的行为,触发器无法由用户直接调用，而知由于对表的【增/删/改】操作被动引发的</li>
<li><strong>函数</strong>：是MySQL数据库提供的内部函数(当然也可以自定义函数)。这些内部函数可以帮助用户更加方便-的处理表中的数据</li>
<li><strong>视图</strong>：视图是虚拟表或逻辑表，它被定义为具有连接的SQL SELECT查询语句。</li>
<li><strong>存储过程</strong>：存储过程是存储在数据库目录中的一坨的声明性SQL语句，数据库中的一个重要对象,有效提高了程序的性能</li>
</ul>
<h2 id="7、听说过视图吗？那游标呢？"><a href="#7、听说过视图吗？那游标呢？" class="headerlink" title="7、听说过视图吗？那游标呢？"></a>7、听说过视图吗？那游标呢？</h2><ul>
<li><p>视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能 游标是对查询出来的结果集作为一个单元来有效的处理。</p>
</li>
<li><p>一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p>
</li>
</ul>
<h2 id="8、视图的作用是什么？可以更改吗？"><a href="#8、视图的作用是什么？可以更改吗？" class="headerlink" title="8、视图的作用是什么？可以更改吗？"></a>8、视图的作用是什么？可以更改吗？</h2><p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的 sql 操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。</p>
<p>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。</p>
<p>创建视图：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> xxx <span class="keyword">as</span> xxxx</span><br></pre></td></tr></table></figure>

<p>对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</p>
<h1 id="五、表结构相关"><a href="#五、表结构相关" class="headerlink" title="五、表结构相关"></a>五、表结构相关</h1><h2 id="1、为什么要尽量设定一个主键"><a href="#1、为什么要尽量设定一个主键" class="headerlink" title="1、为什么要尽量设定一个主键?"></a>1、为什么要尽量设定一个主键?</h2><p>主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的 ID 列作为主键.设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p>
<h2 id="2、主键使用自增-ID-还是-UUID"><a href="#2、主键使用自增-ID-还是-UUID" class="headerlink" title="2、主键使用自增 ID 还是 UUID?"></a>2、主键使用自增 ID 还是 UUID?</h2><p>推荐使用自增ID，不要使用 UUID。</p>
<blockquote>
<p>因为在 InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.</p>
</blockquote>
<p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p>
<h2 id="3、字段为什么要求定义为not-null"><a href="#3、字段为什么要求定义为not-null" class="headerlink" title="3、字段为什么要求定义为not null?"></a>3、字段为什么要求定义为not null?</h2><p>null 值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p>
<h2 id="4、如果要存储用户的密码散列-应该使用什么字段进行存储"><a href="#4、如果要存储用户的密码散列-应该使用什么字段进行存储" class="headerlink" title="4、如果要存储用户的密码散列,应该使用什么字段进行存储?"></a>4、如果要存储用户的密码散列,应该使用什么字段进行存储?</h2><p>密码散列，用户身份证号等固定长度的字符串应该使用 <strong>char</strong> 而不是 <strong>varchar</strong> 来存储，这样可以节省空间且提高检索效率。</p>
<h2 id="5、说一说Drop、Delete与Truncate的共同点和区别"><a href="#5、说一说Drop、Delete与Truncate的共同点和区别" class="headerlink" title="5、说一说Drop、Delete与Truncate的共同点和区别?"></a>5、说一说Drop、Delete与Truncate的共同点和区别?</h2><ul>
<li>Drop直接删掉表;</li>
<li>Truncate删除表中数据，再插入时自增长id又从1开始 ;</li>
<li>Delete删除表中数据，可以加where字句。</li>
</ul>
<h2 id="6、数据库中的主键、超键、候选键、外键是什么？"><a href="#6、数据库中的主键、超键、候选键、外键是什么？" class="headerlink" title="6、数据库中的主键、超键、候选键、外键是什么？"></a>6、数据库中的主键、超键、候选键、外键是什么？</h2><ul>
<li><strong>超键</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键</li>
<li><strong>候选键</strong>：不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是键了！</li>
<li><strong>主键</strong>：用户选作元组标识的一个候选键程序主键</li>
<li><strong>外键</strong>：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。</li>
</ul>
<h1 id="六、其他问题"><a href="#六、其他问题" class="headerlink" title="六、其他问题"></a>六、其他问题</h1><h2 id="1、MySQL-中的-varchar-和-char-有什么区别"><a href="#1、MySQL-中的-varchar-和-char-有什么区别" class="headerlink" title="1、MySQL 中的 varchar 和 char 有什么区别?"></a>1、MySQL 中的 varchar 和 char 有什么区别?</h2><p>char 是一个定长字段，假如申请了char(10) 的空间，那么无论实际存储多少内容。该字段都占用 10 个字符，而 varchar 是变长的，也就是说申请的只是最大长度，占用的空间为实际字符长度 +1，最后一个字符存储使用了多长的空间</p>
<p>在检索效率上来讲，char &gt; varchar，因此在使用中，如果确定某个字段的值的长度，可以使用 char，否则应该尽量使用 varchar。例如存储用户 MD5 加密后的密码，则应该使用 char。</p>
<h2 id="2、varchar-10-和-int-10-代表什么含义"><a href="#2、varchar-10-和-int-10-代表什么含义" class="headerlink" title="2、varchar(10) 和 int(10) 代表什么含义?"></a>2、varchar(10) 和 int(10) 代表什么含义?</h2><p>varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度,而int的10只是代表了展示的长度,不足10位以0填充.也就是说,varchar(10) 和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.</p>
<h2 id="3、MySQL的binlog有有几种录入格式-分别有什么区别"><a href="#3、MySQL的binlog有有几种录入格式-分别有什么区别" class="headerlink" title="3、MySQL的binlog有有几种录入格式?分别有什么区别?"></a>3、MySQL的binlog有有几种录入格式?分别有什么区别?</h2><p>有三种格式：statement、row 和 mixed.</p>
<ul>
<li>statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.</li>
<li>row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.</li>
<li>mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.</li>
</ul>
<h2 id="4、超大分页怎么处理"><a href="#4、超大分页怎么处理" class="headerlink" title="4、超大分页怎么处理?"></a>4、超大分页怎么处理?</h2><p>超大的分页一般从两个方向上来解决.：</p>
<ul>
<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于<code>select * from table where age &gt; 20 limit 1000000,10</code>这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以<code>select * from table where id &gt; 1000000 limit 10</code>,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li>
<li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li>
</ul>
<h2 id="5、说一说三个范式"><a href="#5、说一说三个范式" class="headerlink" title="5、说一说三个范式?"></a>5、说一说三个范式?</h2><ul>
<li>第一范式: 每个列都不可以再拆分。</li>
<li>第二范式: 非主键列完全依赖于主键，而不能是依赖于主键的一部分。</li>
<li>第三范式: 非主键列只依赖于主键，不依赖于其他非主键。</li>
</ul>
<blockquote>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能，事实上我们经常会为了性能而妥协数据库的设计。</p>
</blockquote>
<h2 id="6、left-join、right-join以及inner-join的区别"><a href="#6、left-join、right-join以及inner-join的区别" class="headerlink" title="6、left join、right join以及inner join的区别?"></a>6、left join、right join以及inner join的区别?</h2><ul>
<li>left join：左关联，主表在左边，右边为从表。如果左侧的主表中没有关联字段，会用null 填满</li>
<li>right join：右关联 主表在右边和letf join相反</li>
<li>inner join： 内关联只会显示主表和从表相关联的字段，不会出现null</li>
</ul>
<h2 id="union-和-union-all-的区别"><a href="#union-和-union-all-的区别" class="headerlink" title="union 和 union all 的区别"></a>union 和 union all 的区别</h2><ol>
<li><code>union</code>: 对两个结果集进行并集操作, 不包括重复行,相当于distinct, 同时进行默认规则的排序;</li>
<li><code>union all</code>: 对两个结果集进行并集操作, 包括重复行, 即所有的结果全部显示, 不管是不是重复;</li>
<li>使用union all的执行效率要比union高。</li>
</ol>
<h2 id="7、什么是数据库约束-常见的约束有哪几种"><a href="#7、什么是数据库约束-常见的约束有哪几种" class="headerlink" title="7、什么是数据库约束,常见的约束有哪几种?"></a>7、什么是数据库约束,常见的约束有哪几种?</h2><p>数据库约束用于保证数据库、表数据的完整性（正确性和一致性）。<br>可以通过定义约束\索引\触发器来保证数据的完整性。总体来讲,约束可以分为:</p>
<ul>
<li>主键约束：primary key；</li>
<li>外键约束：foreign key；</li>
<li>唯一约束：unique；</li>
<li>检查约束：check；</li>
<li>空值约束：not null；</li>
<li>默认值约束：default；</li>
</ul>
<h2 id="8、什么是sql注入？"><a href="#8、什么是sql注入？" class="headerlink" title="8、什么是sql注入？"></a>8、什么是sql注入？</h2><p>SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。</p>
<h2 id="9、简述数据库的读写分离？"><a href="#9、简述数据库的读写分离？" class="headerlink" title="9、简述数据库的读写分离？"></a>9、简述数据库的读写分离？</h2><p>读写分离为了确保数据库产品的稳数据定性，很多数据库拥有双机热备功能。也就是，第一台数据库服务器，是对外提供增删改业务的生产服务器；第二台数据库服务器，主要进行读的操作。</p>
<h2 id="10、MySQL数据库cpu飙升的话，要怎么处理呢？"><a href="#10、MySQL数据库cpu飙升的话，要怎么处理呢？" class="headerlink" title="10、MySQL数据库cpu飙升的话，要怎么处理呢？"></a>10、MySQL数据库cpu飙升的话，要怎么处理呢？</h2><p>排查过程：</p>
<ol>
<li>使用top 命令观察，确定是mysqld导致还是其他原因。</li>
<li>如果是mysqld导致的，show processlist，查看session情况，确定是不是有消耗资源的sql在运行。</li>
<li>找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大。</li>
</ol>
<p>处理：</p>
<ol>
<li>kill 掉这些线程(同时观察 cpu 使用率是否下降)，</li>
<li>进行相应的调整(比如说加索引、改 sql、改内存参数)</li>
<li>重新跑这些 SQL。</li>
</ol>
<h2 id="11、MYSQL的主从延迟，你怎么解决？"><a href="#11、MYSQL的主从延迟，你怎么解决？" class="headerlink" title="11、MYSQL的主从延迟，你怎么解决？"></a>11、MYSQL的主从延迟，你怎么解决？</h2><p><strong>主从复制分了五个步骤进行：</strong></p>
<img src="/posts/3636862956/165643097380035.png" class="" title="在这里插入图片描述">

<ul>
<li>步骤一：主库的更新事件(update、insert、delete)被写到binlog</li>
<li>步骤二：从库发起连接，连接到主库。</li>
<li>步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。</li>
<li>步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log</li>
<li>步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db</li>
</ul>
<p><strong>主从同步延迟的原因：</strong></p>
<p>一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取binlog的线程仅有一个，当某个SQL在从服务器上执行的时间稍长 或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。</p>
<p><strong>主从同步延迟的解决办法：</strong></p>
<ul>
<li>主服务器要负责更新操作，对安全性的要求比从服务器要高，所以有些设置参数可以修改，比如<code>sync_binlog=1，innodb_flush_log_at_trx_commit = 1</code> 之类的设置等。</li>
<li>选择更好的硬件设备作为slave。</li>
<li>把一台从服务器当度作为备份使用， 而不提供查询， 那边他的负载下来了， 执行relay log 里面的SQL效率自然就高了。</li>
<li>增加从服务器，这个目的还是分散读的压力，从而降低服务器负载。</li>
</ul>
<h2 id="12、MySQL如何分库分表？"><a href="#12、MySQL如何分库分表？" class="headerlink" title="12、MySQL如何分库分表？"></a>12、MySQL如何分库分表？</h2><h3 id="什么是分库分表"><a href="#什么是分库分表" class="headerlink" title="什么是分库分表"></a>什么是分库分表</h3><p>分库分表方案是对<code>关系型数据库</code>数据存储和访问机制的一种补充。<br>分库：将一个库的数据拆分到多个相同的库中，访问的时候访问一个库<br>分表：把一个表的数据放到多个表中，操作对应的某个表就行</p>
<h3 id="分库分表的几种方式"><a href="#分库分表的几种方式" class="headerlink" title="分库分表的几种方式"></a>分库分表的几种方式</h3><img src="/posts/3636862956/image-20220731123716250.png" class="" title="image-20220731123716250">

<h4 id="1-垂直拆分"><a href="#1-垂直拆分" class="headerlink" title="1.垂直拆分"></a>1.垂直拆分</h4><ul>
<li>垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</li>
<li>垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中</li>
</ul>
<p>(1) <strong>数据库垂直拆分</strong></p>
<img src="/posts/3636862956/16592553096213.jpeg" class="" width="2">

<p>根据业务拆分，如图，电商系统，拆分成订单库，会员库，商品库</p>
<p>(2)<strong>表垂直拆分</strong></p>
<img src="/posts/3636862956/16592555136636.jpeg" class="" width="3">

<p>根据业务去拆分表，如图，把user表拆分成user_base表和user_info表，use_base负责存储登录，user_info负责存储基本用户信息.</p>
<p><strong>垂直拆分特点</strong><br>1.每个库（表）的结构都不一样<br>2.每个库（表）的数据至少一列一样<br>3.每个库（表）的并集是全量数据</p>
<p><strong>垂直拆分优缺点</strong></p>
<p><strong>优点：</strong><br>1.拆分后业务清晰（专库专用按业务拆分）<br>2.数据维护简单，按业务不同，业务放到不同机器上</p>
<p><strong>缺点:</strong><br>1.如果单表的数据量，写读压力大<br>2.受某种业务决定，或者被限制，也就是说一个业务往往会影响到数据库的瓶颈（性能问题，如双十一抢购）<br>3.部分业务无法关联join，只能通过java程序接口去调用，提高了开发复杂度</p>
<h4 id="2-水平拆分"><a href="#2-水平拆分" class="headerlink" title="2. 水平拆分"></a>2. 水平拆分</h4><ul>
<li>水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。</li>
<li>水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。</li>
</ul>
<p><strong>(1) 数据库水平拆分</strong></p>
<img src="/posts/3636862956/se,x_16.jpeg" class="" title="img">

<p>如图，按会员库拆分，拆分成会员1库，会员2库，以userId拆分，userId尾号0-5为1库<br>6-9为2库，还有其他方式，进行取模，偶数放到1库，奇数放到2库</p>
<p><strong>(2) 表水平拆分</strong></p>
<img src="/posts/3636862956/165925579225711.jpeg" class="" width="5">

<p>如图把users表拆分成users1表和users2表，以userId拆分，进行取模，偶数放到users1表，奇数放到users2表</p>
<p><strong>水平拆分特点</strong><br>1.每个库（表）的结构都一样<br>2.每个库（表）的数据都不一样<br>3.每个库（表）的并集是全量数据</p>
<p><strong>水平拆分优缺点</strong></p>
<p><strong>优点</strong>：<br>1.单库/单表的数据保持在一定量（减少），有助于性能提高<br>2.提高了系统的稳定性和负载能力<br>3.拆分表的结构相同，程序改造较少。</p>
<p><strong>缺点</strong>:<br>1.数据的扩容很有难度维护量大<br>2.拆分规则很难抽象出来<br>3.分片事务的一致性问题部分业务无法关联join，只能通过java程序接口去调用</p>
<p><strong>常用的分库分表中间件：</strong></p>
<ul>
<li>sharding-jdbc</li>
<li>Mycat</li>
</ul>
<p><strong>分库分表可能遇到的问题：</strong></p>
<ul>
<li>事务问题：需要用分布式事务</li>
<li>跨节点Join的问题：解决这一问题可以分两次查询实现</li>
<li>跨节点的<code>count,order by,group by</code>以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。</li>
<li>数据迁移，容量规划，扩容等问题</li>
<li>ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制，最简单可以考虑UUID</li>
<li>跨分片的排序分页问题</li>
</ul>
<h2 id="13、count-1-、count-与count-列名-的执行区别"><a href="#13、count-1-、count-与count-列名-的执行区别" class="headerlink" title="13、count(1)、count(*)与count(列名)的执行区别"></a>13、count(1)、count(*)与count(列名)的执行区别</h2><p><strong>执行效果上 ：</strong></p>
<ul>
<li>count(*)：包括了所有的列，相当于行数，在统计结果的时候， 不会忽略列值为NULL</li>
<li>count(1)：包括了忽略所有列，用1代表代码行，在统计结果的时候， 不会忽略列值为NULL</li>
<li>count(列名)：只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数， 即某个字段值为NULL时，不统计。</li>
</ul>
<p><strong>执行效率上：</strong></p>
<ul>
<li>列名为主键，count(列名)会比count(1)快</li>
<li>列名不为主键，count(1)会比count(列名)快</li>
<li>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）</li>
<li>如果有主键，则 select count（主键）的执行效率是最优的</li>
<li>如果表只有一个字段，则 select count（*）最优。</li>
</ul>
<h2 id="14、sql中null与空值的区别"><a href="#14、sql中null与空值的区别" class="headerlink" title="14、sql中null与空值的区别"></a>14、sql中null与空值的区别</h2><ol>
<li>占用空间区别：空值(’’)的长度是0，是不占用空间的；而的NULL长度是NULL，是占用空间的</li>
<li>插入/查询方式区别：NULL值查询使用is null/is not null查询，而空值(’’)可以使用=或者!=、&lt;、&gt;等算术运算符。</li>
<li>COUNT 和 IFNULL函数：使用 COUNT(字段) 统计会过滤掉 NULL 值，但是不会过滤掉空值。</li>
<li>索引字段说明：在有NULL值的字段上使用常用的索引，如普通索引、复合索引、全文索引等不会使索引失效。在官网查看在空间索引的情况下，说明了 索引列必须为NOT NULL。</li>
</ol>
<h1 id="七、优化相关"><a href="#七、优化相关" class="headerlink" title="七、优化相关"></a>七、优化相关</h1><h2 id="1、日常工作中你是怎么优化SQL的？"><a href="#1、日常工作中你是怎么优化SQL的？" class="headerlink" title="1、日常工作中你是怎么优化SQL的？"></a>1、日常工作中你是怎么优化SQL的？</h2><blockquote>
<p>表结构优化</p>
</blockquote>
<ol>
<li><p>尽量使用数字型字段<br>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
</li>
<li><p>尽可能的使用 varchar 代替 char<br>变长字段存储空间小，可以节省存储空间。</p>
</li>
<li><p>当索引列大量重复数据时，可以把索引删除掉<br>比如有一列是性别，几乎只有男、女、未知，这样的索引是无效的。</p>
</li>
</ol>
<blockquote>
<p>查询语句优化</p>
</blockquote>
<ol>
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符</li>
<li>应尽量避免在 where 子句中使用 or 来连接条件</li>
<li>任何查询也不要出现select *</li>
<li>避免在 where 子句中对字段进行 null 值判断</li>
</ol>
<blockquote>
<p>索引优化</p>
</blockquote>
<ol>
<li>对作为查询条件和 order by的字段建立索引</li>
<li>避免建立过多的索引，多使用组合索引</li>
</ol>
<blockquote>
<p>慢查询优化</p>
</blockquote>
<ol>
<li>分析语句，是否加载了不必要的字段/数据</li>
<li>分析 SQL 执行句话，是否命中索引等</li>
<li>如果 SQL 很复杂，优化 SQL 结构</li>
<li>如果表数据量太大，考虑分表</li>
</ol>
<h2 id="2、慢查询日志"><a href="#2、慢查询日志" class="headerlink" title="2、慢查询日志"></a>2、慢查询日志</h2><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;long_query_time&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> long_query_time <span class="operator">|</span> <span class="number">10.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>

<p>通过慢查询日志，可以查找出哪些查询语句的执行效率低，以便进行优化。</p>
<p>如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</p>
<h3 id="1、启动和设置慢查询日志"><a href="#1、启动和设置慢查询日志" class="headerlink" title="1、启动和设置慢查询日志"></a>1、启动和设置慢查询日志</h3><blockquote>
<p>查看是否开启慢查询日志功能</p>
</blockquote>
<ul>
<li><p>slow_query_log：慢查询开启状态</p>
</li>
<li><p>slow_query_log_file：慢查询日志存放的位置（一般设置为 MySQL 的数据存放目录）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span>  variables <span class="keyword">like</span> &quot;slow_query%&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name       <span class="operator">|</span> <span class="keyword">Value</span>                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> slow_query_log      <span class="operator">|</span> <span class="keyword">ON</span>                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_query_log_file <span class="operator">|</span> DESKTOP<span class="operator">-</span>V0CPOJE<span class="operator">-</span>slow.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+--------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>开启慢查询日志功能</p>
</blockquote>
<p><strong>方式一：配置文件开启(永久有效)</strong></p>
<p>将 log_slow_queries 选项和 long_query_time 选项加入到配置文件的 [mysqld] 组中。格式如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">show_query_log</span>=<span class="string">on/off  # 开启或关闭</span></span><br><span class="line"><span class="attr">log-slow-queries</span>=<span class="string">dir/filename</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="string">n</span></span><br><span class="line"><span class="attr">log_output</span>=<span class="string">file</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>dir 参数指定慢查询日志的存储路径，如果不指定存储路径，慢查询日志将默认存储到 MySQL 数据库的数据文件夹下。</li>
<li>filename 参数指定日志的文件名，生成日志文件的完整名称为 filename-slow.log。 如果不指定文件名，默认文件名为 hostname-slow.log，hostname 是 MySQL 服务器的主机名。</li>
<li>“n”参数是设定的时间值，该值的单位是秒。如果不设置 long_query_time 选项，默认时间为 10 秒。</li>
</ul>
<p><strong>方式二：命令开启慢查询日志</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启或关闭</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">GLOBAL slow_query_log=on/off; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 全局和当前session都要修改</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">GLOBAL long_query_time=1;</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">long_query_time=1;</span></span><br></pre></td></tr></table></figure>







































</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io">Eric</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io/posts/3636862956/">https://ericwjian.github.io/posts/3636862956/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericwjian.github.io" target="_blank">Eric</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1973909180/" title="SpringBoot 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringBoot 面试题</div></div></a></div><div class="next-post pull-right"><a href="/posts/382343019/" title="RabbitMQ面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RabbitMQ面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2037477332/" title="面试其他问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">面试其他问题</div></div></a></div><div><a href="/posts/1514862636/" title="实际面试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">实际面试</div></div></a></div><div><a href="/posts/1514862635/" title="数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">数据结构</div></div></a></div><div><a href="/posts/742890947/" title="Mybatis 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">Mybatis 面试题</div></div></a></div><div><a href="/posts/1636770274/" title="SpringMVC 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">SpringMVC 面试题</div></div></a></div><div><a href="/posts/1218378067/" title="Spring面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">Spring面试题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Eric</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/wangjian_uuid" target="_blank" title="Gitee"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:358070983@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=358070983&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3"><span class="toc-text">一、索引相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1、索引是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">2、索引的数据结构?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">3、索引的优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E7%A7%8D%E7%B1%BB"><span class="toc-text">4、MySQL的索引种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Innodb%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%87%AA%E5%A2%9Eid%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="toc-text">5、Innodb为什么要用自增id作为主键？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81BTree%E7%B4%A2%E5%BC%95%E5%92%8CB-Tree%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">6、BTree索引和B+Tree索引的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Hash-%E7%B4%A2%E5%BC%95%E5%92%8C-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%88%96%E8%80%85%E8%AF%B4%E4%BC%98%E5%8A%A3%E5%91%A2"><span class="toc-text">7、Hash 索引和 B+ 树索引有什么区别或者说优劣呢?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81-%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AFB%E6%A0%91"><span class="toc-text">8、 索引为什么使用B+树而不是B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81MyISAM%E5%92%8CInnoDB%E5%AE%9E%E7%8E%B0B-%E6%A0%91%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">9、MyISAM和InnoDB实现B+树索引方式的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">10、什么是聚簇索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">11、聚簇索引和非聚簇索引的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97"><span class="toc-text">12、非聚簇索引一定会回表查询吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">13、覆盖索引是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-text">14、联合索引是什么?为什么需要注意联合索引中的顺序?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5"><span class="toc-text">15、索引失效情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E5%88%9B%E5%BB%BA%E7%9A%84%E7%B4%A2%E5%BC%95%E6%9C%89%E6%B2%A1%E6%9C%89%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%88%B0-%E6%88%96%E8%80%85%E8%AF%B4%E6%80%8E%E4%B9%88%E6%89%8D%E5%8F%AF%E4%BB%A5%E7%9F%A5%E9%81%93%E8%BF%99%E6%9D%A1%E8%AF%AD%E5%8F%A5%E8%BF%90%E8%A1%8C%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">16、创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E7%B4%A2%E5%BC%95%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%81%B5%E5%BE%AA%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-text">17、索引在什么情况下遵循最左前缀的规则？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3"><span class="toc-text">二、事务相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="toc-text">1、什么是事务?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81ACID%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">2、ACID是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81MySQL%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">3、MySQL中为什么要有事务回滚机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">4、数据库并发事务会带来哪些问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81MySQL-%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-text">5、MySQL 的事务隔离级别了解吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Innodb%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%93%AA%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%91%A2"><span class="toc-text">6、Innodb使用的是哪种隔离级别呢?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%94%81%E7%9B%B8%E5%85%B3"><span class="toc-text">三、锁相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%AF%B9-MySQL-%E7%9A%84%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-text">1、对 MySQL 的锁了解吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81MySQL-%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">2、MySQL 锁的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%A1%8C%E7%BA%A7%E9%94%81%E3%80%81%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-text">3、行级锁、表级锁、页级锁的描述与特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%85%B1%E4%BA%AB%E9%94%81-%E3%80%81-%E6%8E%92%E4%BB%96%E9%94%81%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text">4、共享锁 、 排他锁的描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">5、悲观锁与乐观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">6、数据库悲观锁和乐观锁的原理和应用场景分别有什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81MySQL%E5%B8%B8%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">7、MySQL常用存储引擎的锁机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81InnoDB-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E5%87%A0%E7%A7%8D%E9%94%81%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">8、InnoDB 存储引擎有几种锁算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">9、什么是死锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E6%AD%BB%E9%94%81%E5%87%BA%E7%8E%B0%E7%9A%84%E6%A1%88%E5%88%97%EF%BC%9F"><span class="toc-text">10、死锁出现的案列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">11、如何处理死锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">12、如何避免死锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81Innodb%E9%BB%98%E8%AE%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9%E5%BE%85%E6%AD%BB%E9%94%81%E7%9A%84%EF%BC%9F"><span class="toc-text">13、Innodb默认是如何对待死锁的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%EF%BC%9F"><span class="toc-text">14、如何开启死锁检测？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%A8%E5%B1%80%E9%94%81%EF%BC%9F%E5%AE%83%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">15、什么是全局锁？它的应用场景有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E9%94%81%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">16、使用全局锁会导致的问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E4%BC%98%E5%8C%96%E9%94%81%E6%96%B9%E9%9D%A2%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%EF%BC%9F"><span class="toc-text">17、优化锁方面你有什么建议？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9B%B8%E5%85%B3"><span class="toc-text">四、存储引擎相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81MySQL-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">1、MySQL 支持哪些存储引擎?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81InnoDB-%E5%92%8C-MyISAM-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">2、InnoDB 和 MyISAM 有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%BD%A0%E4%BA%86%E8%A7%A3MySQL%E7%9A%84%E5%86%85%E9%83%A8%E6%9E%84%E9%80%A0%E5%90%97%EF%BC%9F%E4%B8%80%E8%88%AC%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E5%93%AA%E4%B8%A4%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F"><span class="toc-text">3、你了解MySQL的内部构造吗？一般可以分为哪两个部分？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8BMySQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1SQL%E7%9A%84%EF%BC%9F%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">4、说一下MySQL是如何执行一条SQL的？具体步骤有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81SQL-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">5、SQL 的执行顺序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%AE%80%E8%BF%B0%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">6、简述触发器、函数、视图、存储过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%90%AC%E8%AF%B4%E8%BF%87%E8%A7%86%E5%9B%BE%E5%90%97%EF%BC%9F%E9%82%A3%E6%B8%B8%E6%A0%87%E5%91%A2%EF%BC%9F"><span class="toc-text">7、听说过视图吗？那游标呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%94%B9%E5%90%97%EF%BC%9F"><span class="toc-text">8、视图的作用是什么？可以更改吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3"><span class="toc-text">五、表结构相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%BD%E9%87%8F%E8%AE%BE%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%94%AE"><span class="toc-text">1、为什么要尽量设定一个主键?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%BB%E9%94%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E-ID-%E8%BF%98%E6%98%AF-UUID"><span class="toc-text">2、主键使用自增 ID 还是 UUID?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E6%AE%B5%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82%E5%AE%9A%E4%B9%89%E4%B8%BAnot-null"><span class="toc-text">3、字段为什么要求定义为not null?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%A6%82%E6%9E%9C%E8%A6%81%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E7%9A%84%E5%AF%86%E7%A0%81%E6%95%A3%E5%88%97-%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E5%AD%98%E5%82%A8"><span class="toc-text">4、如果要存储用户的密码散列,应该使用什么字段进行存储?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4Drop%E3%80%81Delete%E4%B8%8ETruncate%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">5、说一说Drop、Delete与Truncate的共同点和区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%B8%BB%E9%94%AE%E3%80%81%E8%B6%85%E9%94%AE%E3%80%81%E5%80%99%E9%80%89%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">6、数据库中的主键、超键、候选键、外键是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-text">六、其他问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81MySQL-%E4%B8%AD%E7%9A%84-varchar-%E5%92%8C-char-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">1、MySQL 中的 varchar 和 char 有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81varchar-10-%E5%92%8C-int-10-%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89"><span class="toc-text">2、varchar(10) 和 int(10) 代表什么含义?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81MySQL%E7%9A%84binlog%E6%9C%89%E6%9C%89%E5%87%A0%E7%A7%8D%E5%BD%95%E5%85%A5%E6%A0%BC%E5%BC%8F-%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">3、MySQL的binlog有有几种录入格式?分别有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-text">4、超大分页怎么处理?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%B8%89%E4%B8%AA%E8%8C%83%E5%BC%8F"><span class="toc-text">5、说一说三个范式?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81left-join%E3%80%81right-join%E4%BB%A5%E5%8F%8Ainner-join%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">6、left join、right join以及inner join的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#union-%E5%92%8C-union-all-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">union 和 union all 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BA%A6%E6%9D%9F-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-text">7、什么是数据库约束,常见的约束有哪几种?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFsql%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-text">8、什么是sql注入？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E7%AE%80%E8%BF%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%9F"><span class="toc-text">9、简述数据库的读写分离？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81MySQL%E6%95%B0%E6%8D%AE%E5%BA%93cpu%E9%A3%99%E5%8D%87%E7%9A%84%E8%AF%9D%EF%BC%8C%E8%A6%81%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%91%A2%EF%BC%9F"><span class="toc-text">10、MySQL数据库cpu飙升的话，要怎么处理呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81MYSQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">11、MYSQL的主从延迟，你怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81MySQL%E5%A6%82%E4%BD%95%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="toc-text">12、MySQL如何分库分表？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-text">什么是分库分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">分库分表的几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86"><span class="toc-text">1.垂直拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86"><span class="toc-text">2. 水平拆分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81count-1-%E3%80%81count-%E4%B8%8Ecount-%E5%88%97%E5%90%8D-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">13、count(1)、count(*)与count(列名)的执行区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81sql%E4%B8%ADnull%E4%B8%8E%E7%A9%BA%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">14、sql中null与空值的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3"><span class="toc-text">七、优化相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96SQL%E7%9A%84%EF%BC%9F"><span class="toc-text">1、日常工作中你是怎么优化SQL的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-text">2、慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%90%AF%E5%8A%A8%E5%92%8C%E8%AE%BE%E7%BD%AE%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-text">1、启动和设置慢查询日志</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148432/" title="MyBatis 拦截器">MyBatis 拦截器</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148434/" title="MyBatis 集成druid数据源">MyBatis 集成druid数据源</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1166366203/" title="SQL调优">SQL调优</a><time datetime="2024-07-16T16:00:00.000Z" title="发表于 2024-07-17 00:00:00">2024-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3109398172/" title="ContextHolder">ContextHolder</a><time datetime="2024-07-11T16:00:00.000Z" title="发表于 2024-07-12 00:00:00">2024-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2889834893/" title="SpringCloud Feign">SpringCloud Feign</a><time datetime="2024-07-01T16:00:00.000Z" title="发表于 2024-07-02 00:00:00">2024-07-02</time></div></div></div></div></div></div></main><footer id="footer" style="background: #47577e"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '2N3fEF3CzNAzKwVbFlhSTUuM-gzGzoHsz',
      appKey: '9m41Klhi8IgsrNrbyMnoCHrN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>