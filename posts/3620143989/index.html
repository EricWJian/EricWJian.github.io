<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RocketMq 面试题 | Eric</title><meta name="author" content="Eric"><meta name="copyright" content="Eric"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2022 RocketMQ精选面试题50道1、 多个mq如何选型？   MQ 描述    RabbitMQ erlang开发，对消息堆积的支持并不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降。每秒钟可以处理几万到十几万条消息。   RocketMQ java开发，面向互联网集群"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://ericwjian.github.io/posts/3620143989/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4dfa2c883c8c4c23f4866185de932236";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RocketMq 面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-29 10:21:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Eric"><span class="site-name">Eric</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">RocketMq 面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-10T16:00:00.000Z" title="发表于 2022-06-11 00:00:00">2022-06-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-29T02:21:31.402Z" title="更新于 2024-09-29 10:21:31">2024-09-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RocketMq 面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="2022-RocketMQ精选面试题50道"><a href="#2022-RocketMQ精选面试题50道" class="headerlink" title="2022 RocketMQ精选面试题50道"></a>2022 RocketMQ精选面试题50道</h1><h3 id="1、-多个mq如何选型？"><a href="#1、-多个mq如何选型？" class="headerlink" title="1、 多个mq如何选型？"></a>1、 多个mq如何选型？</h3><table>
<thead>
<tr>
<th align="left">MQ</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RabbitMQ</td>
<td align="left">erlang开发，对消息堆积的支持并不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降。每秒钟可以处理几万到十几万条消息。</td>
</tr>
<tr>
<td align="left">RocketMQ</td>
<td align="left">java开发，面向互联网集群化功能丰富，对在线业务的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，每秒钟大概能处理几十万条消息。</td>
</tr>
<tr>
<td align="left">Kafka</td>
<td align="left">Scala开发，面向日志功能丰富，性能最高。当你的业务场景中，每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。</td>
</tr>
<tr>
<td align="left">ActiveMQ</td>
<td align="left">java开发，简单，稳定，性能不如前面三个。小型系统用也ok，但是不推荐。推荐用互联网主流的。</td>
</tr>
</tbody></table>
<h3 id="2、-为什么要使用MQ？"><a href="#2、-为什么要使用MQ？" class="headerlink" title="2、 为什么要使用MQ？"></a>2、 为什么要使用MQ？</h3><p>因为项目比较大，做了分布式系统，所有远程服务调用请求都是<strong>同步执行</strong>经常出问题，所以引入了mq</p>
<table>
<thead>
<tr>
<th align="left">作用</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">解耦</td>
<td align="left">系统耦合度降低，没有强依赖关系</td>
</tr>
<tr>
<td align="left">异步</td>
<td align="left">不需要同步执行的远程调用可以有效提高响应时间</td>
</tr>
<tr>
<td align="left">削峰</td>
<td align="left">请求达到峰值后，后端service还可以保持固定消费速率消费，不会被压垮</td>
</tr>
</tbody></table>
<h3 id="3、-RocketMQ由哪些角色组成，每个角色作用和特点是什么？"><a href="#3、-RocketMQ由哪些角色组成，每个角色作用和特点是什么？" class="headerlink" title="3、 RocketMQ由哪些角色组成，每个角色作用和特点是什么？"></a>3、 RocketMQ由哪些角色组成，每个角色作用和特点是什么？</h3><table>
<thead>
<tr>
<th align="left">角色</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Nameserver</td>
<td align="left">无状态，动态列表；这也是和zookeeper的重要区别之一。zookeeper是有状态的。</td>
</tr>
<tr>
<td align="left">Producer</td>
<td align="left">消息生产者，负责发消息到Broker。</td>
</tr>
<tr>
<td align="left">Broker</td>
<td align="left">就是MQ本身，负责收发消息、持久化消息等。</td>
</tr>
<tr>
<td align="left">Consumer</td>
<td align="left">消息消费者，负责从Broker上拉取消息进行消费，消费完进行ack。</td>
</tr>
</tbody></table>
<h3 id="4、-RocketMQ中的Topic和JMS的queue有什么区别？"><a href="#4、-RocketMQ中的Topic和JMS的queue有什么区别？" class="headerlink" title="4、 RocketMQ中的Topic和JMS的queue有什么区别？"></a>4、 RocketMQ中的Topic和JMS的queue有什么区别？</h3><p>queue就是来源于数据结构的FIFO队列。而Topic是个抽象的概念，每个Topic底层对应N个queue，而数据也真实存在queue上的。</p>
<h3 id="5、-RocketMQ-Broker中的消息被消费后会立即删除吗？"><a href="#5、-RocketMQ-Broker中的消息被消费后会立即删除吗？" class="headerlink" title="5、 RocketMQ Broker中的消息被消费后会立即删除吗？"></a>5、 RocketMQ Broker中的消息被消费后会立即删除吗？</h3><p>不会，每条消息都会持久化到CommitLog中，每个Consumer连接到Broker后会维持消费进度信息，当有消息消费后只是当前Consumer的消费进度（CommitLog的offset）更新了。</p>
<h4 id="追问：那么消息会堆积吗？什么时候清理过期消息？"><a href="#追问：那么消息会堆积吗？什么时候清理过期消息？" class="headerlink" title="追问：那么消息会堆积吗？什么时候清理过期消息？"></a>追问：那么消息会堆积吗？什么时候清理过期消息？</h4><p>4.6版本默认48小时后会删除不再使用的CommitLog文件</p>
<ul>
<li>检查这个文件最后访问时间</li>
<li>判断是否大于过期时间</li>
<li>指定时间删除，默认凌晨4点</li>
</ul>
<h3 id="6、-RocketMQ消费模式有几种？"><a href="#6、-RocketMQ消费模式有几种？" class="headerlink" title="6、 RocketMQ消费模式有几种？"></a>6、 RocketMQ消费模式有几种？</h3><p>消费模型由Consumer决定，消费维度为Topic。</p>
<ul>
<li><p>集群消费</p>
<ol>
<li>一条消息只会被同Group中的一个Consumer消费</li>
<li>多个Group同时消费一个Topic时，每个Group都会有一个Consumer消费到数据</li>
</ol>
</li>
<li><p>广播消费 </p>
<ol>
<li>消息将对一 个Consumer Group 下的各个 Consumer 实例都消费一遍。即即使这些 Consumer 属于同一个Consumer Group ，消息也会被 Consumer Group 中的每个 Consumer 都消费一次。</li>
</ol>
</li>
</ul>
<h3 id="7、-消费消息是push还是pull？"><a href="#7、-消费消息是push还是pull？" class="headerlink" title="7、 消费消息是push还是pull？"></a>7、 消费消息是push还是pull？</h3><p>RocketMQ没有真正意义的push，都是pull，虽然有push类，但实际底层实现采用的是<strong>长轮询机制</strong>，即拉取方式 broker端属性 longPollingEnable 标记是否开启长轮询。默认开启</p>
<p>源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//&#123;@link org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#pullMessage()&#125;</span><br><span class="line">//看到没，这是一只披着羊皮的狼，名字叫PushConsumerImpl，实际干的确是pull的活。</span><br><span class="line"></span><br><span class="line">//拉取消息，结果放到pullCallback里</span><br><span class="line">this.pullAPIWrapper.pullKernelImpl(pullCallback);</span><br></pre></td></tr></table></figure>

<h4 id="追问：为什么要主动拉取消息而不使用事件监听方式？"><a href="#追问：为什么要主动拉取消息而不使用事件监听方式？" class="headerlink" title="追问：为什么要主动拉取消息而不使用事件监听方式？"></a>追问：为什么要主动拉取消息而不使用事件监听方式？</h4><p>事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送。</p>
<p>如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多，同时又不能被其他consumer消费的情况。而pull的方式可以根据当前自身情况来pull，不会造成过多的压力而造成瓶颈。所以采取了pull的方式。</p>
<h3 id="8、-broker如何处理拉取请求的？"><a href="#8、-broker如何处理拉取请求的？" class="headerlink" title="8、 broker如何处理拉取请求的？"></a>8、 broker如何处理拉取请求的？</h3><p>Consumer首次请求Broker</p>
<ul>
<li>Broker中是否有符合条件的消息</li>
<li>有 -&gt;</li>
<li>响应Consumer</li>
<li>等待下次Consumer的请求</li>
<li>没有</li>
<li>DefaultMessageStore#ReputMessageService#run方法</li>
<li>PullRequestHoldService 来Hold连接，每个5s执行一次检查pullRequestTable有没有消息，有的话立即推送</li>
<li>每隔1ms检查commitLog中是否有新消息，有的话写入到pullRequestTable</li>
<li>当有新消息的时候返回请求</li>
<li>挂起consumer的请求，即不断开连接，也不返回数据</li>
<li>使用consumer的offset，</li>
</ul>
<h3 id="9、-RocketMQ如何做负载均衡？"><a href="#9、-RocketMQ如何做负载均衡？" class="headerlink" title="9、 RocketMQ如何做负载均衡？"></a>9、 RocketMQ如何做负载均衡？</h3><p>通过Topic在多Broker中分布式存储实现。</p>
<h4 id="producer端"><a href="#producer端" class="headerlink" title="producer端"></a>producer端</h4><p>发送端指定message queue发送消息到相应的broker，来达到写入时的负载均衡</p>
<ul>
<li>提升写入吞吐量，当多个producer同时向一个broker写入数据的时候，性能会下降</li>
<li>消息分布在多broker中，为负载消费做准备</li>
</ul>
<p><strong>默认策略是随机选择：</strong></p>
<ul>
<li>producer维护一个index</li>
<li>每次取节点会自增</li>
<li>index向所有broker个数取余</li>
<li>自带容错策略</li>
</ul>
<p><strong>其他实现：</strong></p>
<ul>
<li>SelectMessageQueueByHash</li>
<li>hash的是传入的args</li>
<li>SelectMessageQueueByRandom</li>
<li>SelectMessageQueueByMachineRoom 没有实现</li>
</ul>
<p>也可以自定义实现<strong>MessageQueueSelector</strong>接口中的select方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue select(final List&lt;MessageQueue&gt; mqs, final Message msg, final Object arg);</span><br></pre></td></tr></table></figure>

<h4 id="consumer端"><a href="#consumer端" class="headerlink" title="consumer端"></a>consumer端</h4><p>采用的是平均分配算法来进行负载均衡。</p>
<p><strong>其他负载均衡算法</strong></p>
<p>平均分配策略(默认)(AllocateMessageQueueAveragely) 环形分配策略(AllocateMessageQueueAveragelyByCircle) 手动配置分配策略(AllocateMessageQueueByConfig) 机房分配策略(AllocateMessageQueueByMachineRoom) 一致性哈希分配策略(AllocateMessageQueueConsistentHash) 靠近机房策略(AllocateMachineRoomNearby)</p>
<h5 id="追问：当消费负载均衡consumer和queue不对等的时候会发生什么？"><a href="#追问：当消费负载均衡consumer和queue不对等的时候会发生什么？" class="headerlink" title="追问：当消费负载均衡consumer和queue不对等的时候会发生什么？"></a>追问：当消费负载均衡consumer和queue不对等的时候会发生什么？</h5><p>Consumer和queue会优先平均分配，如果Consumer少于queue的个数，则会存在部分Consumer消费多个queue的情况，如果Consumer等于queue的个数，那就是一个Consumer消费一个queue，如果Consumer个数大于queue的个数，那么会有部分Consumer空余出来，白白的浪费了。</p>
<h3 id="10、-消息重复消费"><a href="#10、-消息重复消费" class="headerlink" title="10、 消息重复消费"></a><code>10、</code> 消息重复消费</h3><p>影响消息正常发送和消费的<strong>重要原因是网络的不确定性。</strong></p>
<p><strong>引起重复消费的原因</strong></p>
<ul>
<li>ACK</li>
</ul>
<p>正常情况下在consumer真正消费完消息后应该发送ack，通知broker该消息已正常消费，从queue中剔除</p>
<p>当ack因为网络原因无法发送到broker，broker会认为词条消息没有被消费，此后会开启消息重投机制把消息再次投递到consumer</p>
<ul>
<li>消费模式</li>
</ul>
<p>在CLUSTERING模式下，消息在broker中会保证相同group的consumer消费一次，但是针对不同group的consumer会推送多次</p>
<p><strong>解决方案</strong></p>
<ul>
<li>数据库表</li>
</ul>
<p>处理消息前，使用消息主键在表中带有约束的字段中insert</p>
<ul>
<li>Map</li>
</ul>
<p>单机时可以使用map <em>ConcurrentHashMap</em> -&gt; putIfAbsent  guava cache</p>
<ul>
<li>Redis</li>
</ul>
<p>分布式锁搞起来。</p>
<h3 id="11、-如何让RocketMQ保证消息的顺序消费"><a href="#11、-如何让RocketMQ保证消息的顺序消费" class="headerlink" title="11、 如何让RocketMQ保证消息的顺序消费"></a>11、 如何让RocketMQ保证消息的顺序消费</h3><p>你们线上业务用消息中间件的时候，是否需要保证消息的顺序性?</p>
<p>如果不需要保证消息顺序，为什么不需要?假如我有一个场景要保证消息的顺序，你们应该如何保证?</p>
<p>首先多个queue只能保证单个queue里的顺序，queue是典型的FIFO，天然顺序。多个queue同时消费是无法绝对保证消息的有序性的。所以总结如下：</p>
<p>同一topic，同一个QUEUE，发消息的时候一个线程去发送消息，消费的时候 一个线程去消费一个queue里的消息。</p>
<h4 id="追问：怎么保证消息发到同一个queue？"><a href="#追问：怎么保证消息发到同一个queue？" class="headerlink" title="追问：怎么保证消息发到同一个queue？"></a>追问：怎么保证消息发到同一个queue？</h4><p>Rocket MQ给我们提供了MessageQueueSelector接口，可以自己重写里面的接口，实现自己的算法，举个最简单的例子：判断 <code>i % 2 == 0</code> ，那就都放到queue1里，否则放到queue2里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    Message message = new Message(&quot;orderTopic&quot;, (&quot;hello!&quot; +i).getBytes());</span><br><span class="line">    producer.send(</span><br><span class="line">        //要发的那条消息</span><br><span class="line">message,</span><br><span class="line">        //queue 选择器 ，向 topic中的哪个queue去写消息</span><br><span class="line">        newMessageQueueSelector() &#123;</span><br><span class="line">            //手动 选择一个queue</span><br><span class="line">@Override</span><br><span class="line">            publicMessageQueue select(</span><br><span class="line">                //当前topic 里面包含的所有queue</span><br><span class="line">                List&lt;MessageQueue&gt;mqs,</span><br><span class="line">                //具体要发的那条消息</span><br><span class="line">Message msg,</span><br><span class="line">                //对应到 send（） 里的 args，也就是2000前面的那个0</span><br><span class="line">Object arg) &#123;</span><br><span class="line">                //向固定的一个queue里写消息，比如这里就是向第一个queue里写消息</span><br><span class="line">                if (Integer.parseInt(arg.toString()) % 2 == 0) &#123;</span><br><span class="line">                    return mqs.get(0);</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    return mqs.get(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        //自定义参数：0</span><br><span class="line">        //2000代表2000毫秒超时时间</span><br><span class="line">        i, 2000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12、-RocketMQ如何保证消息不丢失"><a href="#12、-RocketMQ如何保证消息不丢失" class="headerlink" title="12、 RocketMQ如何保证消息不丢失"></a>12、 RocketMQ如何保证消息不丢失</h3><p>首先在如下三个部分都可能会出现丢失消息的情况：</p>
<ul>
<li>Producer端</li>
<li>Broker端</li>
<li>Consumer端</li>
</ul>
<h4 id="Producer端如何保证消息不丢失"><a href="#Producer端如何保证消息不丢失" class="headerlink" title="Producer端如何保证消息不丢失"></a>Producer端如何保证消息不丢失</h4><ul>
<li>采取send()同步发消息，发送结果是同步感知的。</li>
<li>发送失败后可以重试，设置重试次数。默认3次。 producer.setRetryTimesWhenSendFailed(10);</li>
<li>集群部署，比如发送失败了的原因可能是当前Broker宕机了，重试的时候会发送到其他Broker上。</li>
</ul>
<h4 id="Broker端如何保证消息不丢失"><a href="#Broker端如何保证消息不丢失" class="headerlink" title="Broker端如何保证消息不丢失"></a>Broker端如何保证消息不丢失</h4><ul>
<li>修改刷盘策略为同步刷盘。默认情况下是异步刷盘的。 flushDiskType = SYNC_FLUSH</li>
<li>集群部署，主从模式，高可用。</li>
</ul>
<h4 id="Consumer端如何保证消息不丢失"><a href="#Consumer端如何保证消息不丢失" class="headerlink" title="Consumer端如何保证消息不丢失"></a>Consumer端如何保证消息不丢失</h4><ul>
<li>完全消费正常后在进行手动ack确认。</li>
</ul>
<h3 id="13、-rocketMQ的消息堆积如何处理"><a href="#13、-rocketMQ的消息堆积如何处理" class="headerlink" title="13、 rocketMQ的消息堆积如何处理"></a>13、 rocketMQ的消息堆积如何处理</h3><p>下游消费系统如果宕机了，导致几百万条消息在消息中间件里积压，此时怎么处理?</p>
<p>你们线上是否遇到过消息积压的生产故障?如果没遇到过，你考虑一下如何应对?</p>
<p>首先要找到是什么原因导致的消息堆积，是Producer太多了，Consumer太少了导致的还是说其他情况，总之先定位问题。</p>
<p>然后看下消息消费速度是否正常，正常的话，可以通过上线更多consumer临时解决消息堆积问题</p>
<h4 id="追问：如果Consumer和Queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？"><a href="#追问：如果Consumer和Queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？" class="headerlink" title="追问：如果Consumer和Queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？"></a>追问：如果Consumer和Queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？</h4><ul>
<li>准备一个临时的topic</li>
<li>queue的数量是堆积的几倍</li>
<li>queue分布到多Broker中</li>
<li>上线一台Consumer做消息的搬运工，把原来Topic中的消息挪到新的Topic里，不做业务逻辑处理，只是挪过去</li>
<li>上线N台Consumer同时消费临时Topic中的数据</li>
<li>改bug</li>
<li>恢复原来的Consumer，继续消费之前的Topic</li>
</ul>
<h4 id="追问：堆积时间过长消息超时了？"><a href="#追问：堆积时间过长消息超时了？" class="headerlink" title="追问：堆积时间过长消息超时了？"></a>追问：堆积时间过长消息超时了？</h4><p>RocketMQ中的消息只会在commitLog被删除的时候才会消失，不会超时。也就是说未被消费的消息不会存在超时删除这情况。</p>
<h4 id="追问：堆积的消息会不会进死信队列？"><a href="#追问：堆积的消息会不会进死信队列？" class="headerlink" title="追问：堆积的消息会不会进死信队列？"></a>追问：堆积的消息会不会进死信队列？</h4><p>不会，消息在消费失败后会进入重试队列（%RETRY%+ConsumerGroup），18次（默认18次，网上所有文章都说是16次，无一例外。但是我没搞懂为啥是16次，这不是18个时间吗 ？）才会进入死信队列（%DLQ%+ConsumerGroup）。</p>
<p>源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public classMessageStoreConfig &#123;</span><br><span class="line">    //每隔如下时间会进行重试，到最后一次时间重试失败的话就进入死信队列了。</span><br><span class="line"> private String messageDelayLevel = &quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14、-RocketMQ在分布式事务支持这块机制的底层原理"><a href="#14、-RocketMQ在分布式事务支持这块机制的底层原理" class="headerlink" title="14、 RocketMQ在分布式事务支持这块机制的底层原理?"></a>14、 RocketMQ在分布式事务支持这块机制的底层原理?</h3><p>你们用的是RocketMQ?RocketMQ很大的一个特点是对分布式事务的支持，你说说他在分布式事务支持这块机制的底层原理?</p>
<p>分布式系统中的事务可以使用TCC（Try、Confirm、Cancel）、2pc来解决分布式系统中的消息原子性</p>
<p>RocketMQ 4.3+提供分布事务功能，通过 RocketMQ 事务消息能达到分布式事务的最终一致</p>
<p><strong>RocketMQ实现方式：</strong></p>
<p><strong>Half Message：</strong>预处理消息，当broker收到此类消息后，会存储到RMQ_SYS_TRANS_HALF_TOPIC的消息消费队列中</p>
<p><strong>检查事务状态：</strong>Broker会开启一个定时任务，消费RMQ_SYS_TRANS_HALF_TOPIC队列中的消息，每次执行任务会向消息发送者确认事务执行状态（提交、回滚、未知），如果是未知，Broker会定时去回调在重新检查。</p>
<p><strong>超时：</strong>如果超过回查次数，默认回滚消息。</p>
<p>也就是他并未真正进入Topic的queue，而是用了临时queue来放所谓的half message，等提交事务后才会真正的将half message转移到topic下的queue。</p>
<h3 id="15、-如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现"><a href="#15、-如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现" class="headerlink" title="15、 如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现?"></a>15、 如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现?</h3><p>我个人觉得从以下几个点回答吧：</p>
<ul>
<li>需要考虑能快速扩容、天然支持集群</li>
<li>持久化的姿势</li>
<li>高可用性</li>
<li>数据0丢失的考虑</li>
<li>服务端部署简单、client端使用简单</li>
</ul>
<h3 id="16、-看过RocketMQ-的源码没有。如果看过，说说你对RocketMQ-源码的理解"><a href="#16、-看过RocketMQ-的源码没有。如果看过，说说你对RocketMQ-源码的理解" class="headerlink" title="16、 看过RocketMQ 的源码没有。如果看过，说说你对RocketMQ 源码的理解?"></a>16、 看过RocketMQ 的源码没有。如果看过，说说你对RocketMQ 源码的理解?</h3><p>要真让我说，我会吐槽蛮烂的，首先没任何注释，可能是之前阿里巴巴写了中文注释，捐赠给apache后，apache觉得中文注释不能留，自己又懒得写英文注释，就都给删了。里面比较典型的设计模式有单例、工厂、策略、门面模式。单例工厂无处不在，策略印象深刻比如发消息和消费消息的时候queue的负载均衡就是N个策略算法类，有随机、hash等，这也是能够快速扩容天然支持集群的必要原因之一。持久化做的也比较完善，采取的CommitLog来落盘，同步异步两种方式。</p>
<h3 id="17、-高吞吐量下如何优化生产者和消费者的性能"><a href="#17、-高吞吐量下如何优化生产者和消费者的性能" class="headerlink" title="17、 高吞吐量下如何优化生产者和消费者的性能?"></a>17、 高吞吐量下如何优化生产者和消费者的性能?</h3><h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><ul>
<li>同一group下，多机部署，并行消费</li>
<li>单个Consumer提高消费线程个数</li>
<li>批量消费</li>
<li>消息批量拉取</li>
<li>业务逻辑批量处理</li>
</ul>
<h4 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h4><ul>
<li>网卡调优</li>
<li>jvm调优</li>
<li>多线程与cpu调优</li>
<li>Page Cache</li>
</ul>
<h3 id="18、-再说说RocketMQ-是如何保证数据的高容错性的"><a href="#18、-再说说RocketMQ-是如何保证数据的高容错性的" class="headerlink" title="18、 再说说RocketMQ 是如何保证数据的高容错性的?"></a>18、 再说说RocketMQ 是如何保证数据的高容错性的?</h3><ul>
<li>在不开启容错的情况下，轮询队列进行发送，如果失败了，重试的时候过滤失败的Broker</li>
<li>如果开启了容错策略，会通过RocketMQ的预测机制来预测一个Broker是否可用</li>
<li>如果上次失败的Broker可用那么还是会选择该Broker的队列</li>
<li>如果上述情况失败，则随机选择一个进行发送</li>
<li>在发送消息的时候会记录一下调用的时间与是否报错，根据该时间去预测broker的可用时间 其实就是send消息的时候queue的选择。源码在如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.rocketmq.client.latency.MQFaultStrategy#selectOneMessageQueue()</span><br></pre></td></tr></table></figure>

<h3 id="19、-任何一台Broker突然宕机了怎么办？"><a href="#19、-任何一台Broker突然宕机了怎么办？" class="headerlink" title="19、 任何一台Broker突然宕机了怎么办？"></a>19、 任何一台Broker突然宕机了怎么办？</h3><p>Broker主从架构以及多副本策略。Master收到消息后会同步给Slave，这样一条消息就不止一份了，Master宕机了还有slave中的消息可用，保证了MQ的可靠性和高可用性。而且Rocket MQ4.5.0开始就支持了Dlegder模式，基于raft的，做到了真正意义的HA。</p>
<h3 id="20、-Broker把自己的信息注册到哪个NameServer上？"><a href="#20、-Broker把自己的信息注册到哪个NameServer上？" class="headerlink" title="20、 Broker把自己的信息注册到哪个NameServer上？"></a>20、 Broker把自己的信息注册到哪个NameServer上？</h3><p>这么问明显在坑你，因为Broker会向所有的NameServer上注册自己的信息，而不是某一个，是每一个，全部！</p>
<h3 id="21、-你们为什么使用mq？具体的使用场景是什么？"><a href="#21、-你们为什么使用mq？具体的使用场景是什么？" class="headerlink" title="21、 你们为什么使用mq？具体的使用场景是什么？"></a>21、 你们为什么使用mq？具体的使用场景是什么？</h3><p>mq的作用很简单，削峰填谷。以电商交易下单的场景来说，正向交易的过程可能涉及到创建订单、扣减库存、扣减活动预算、扣减积分等等。每个接口的耗时如果是100ms，那么理论上整个下单的链路就需要耗费400ms，这个时间显然是太长了。</p>
<p>如果这些操作全部同步处理的话，首先调用链路太长影响接口性能，其次分布式事务的问题很难处理，这时候像扣减预算和积分这种对实时一致性要求没有那么高的请求，完全就可以通过mq异步的方式去处理了。同时，考虑到异步带来的不一致的问题，我们可以通过job去重试保证接口调用成功，而且一般公司都会有核对的平台，比如下单成功但是未扣减积分的这种问题可以通过核对作为兜底的处理方案。</p>
<p>使用mq之后我们的链路变简单了，同时异步发送消息我们的整个系统的抗压能力也上升了。</p>
<h3 id="22、-那你们使用什么mq？基于什么做的选型？"><a href="#22、-那你们使用什么mq？基于什么做的选型？" class="headerlink" title="22、 那你们使用什么mq？基于什么做的选型？"></a>22、 那你们使用什么mq？基于什么做的选型？</h3><p>我们主要调研了几个主流的mq，kafka、rabbitmq、rocketmq、activemq，选型我们主要基于以下几个点去考虑：</p>
<ol>
<li>由于我们系统的qps压力比较大，所以性能是首要考虑的要素。</li>
<li>开发语言，由于我们的开发语言是java，主要是为了方便二次开发。</li>
<li>对于高并发的业务场景是必须的，所以需要支持分布式架构的设计。</li>
<li>功能全面，由于不同的业务场景，可能会用到顺序消息、事务消息等。</li>
</ol>
<p>基于以上几个考虑，我们最终选择了RocketMQ。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Kafka</th>
<th align="left">RocketMQ</th>
<th align="left">RabbitMQ</th>
<th align="left">ActiveMQ</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单机吞吐量</td>
<td align="left">10万级</td>
<td align="left">10万级</td>
<td align="left">万级</td>
<td align="left">万级</td>
</tr>
<tr>
<td align="left">开发语言</td>
<td align="left">Scala</td>
<td align="left">Java</td>
<td align="left">Erlang</td>
<td align="left">Java</td>
</tr>
<tr>
<td align="left">高可用</td>
<td align="left">分布式架构</td>
<td align="left">分布式架构</td>
<td align="left">主从架构</td>
<td align="left">主从架构</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">ms级</td>
<td align="left">ms级</td>
<td align="left">us级</td>
<td align="left">ms级</td>
</tr>
<tr>
<td align="left">功能</td>
<td align="left">只支持主要的MQ功能</td>
<td align="left">顺序消息、事务消息等功能完善</td>
<td align="left">并发强、性能好、延时低</td>
<td align="left">成熟的社区产品、文档丰富</td>
</tr>
</tbody></table>
<h3 id="23、-你上面提到异步发送，那消息可靠性怎么保证？"><a href="#23、-你上面提到异步发送，那消息可靠性怎么保证？" class="headerlink" title="23、 你上面提到异步发送，那消息可靠性怎么保证？"></a>23、 你上面提到异步发送，那消息可靠性怎么保证？</h3><p>消息丢失可能发生在生产者发送消息、MQ本身丢失消息、消费者丢失消息3个方面。</p>
<h3 id="生产者丢失"><a href="#生产者丢失" class="headerlink" title="生产者丢失"></a>生产者丢失</h3><p>生产者丢失消息的可能点在于程序发送失败抛异常了没有重试处理，或者发送的过程成功但是过程中网络闪断MQ没收到，消息就丢失了。</p>
<p>由于同步发送的一般不会出现这样使用方式，所以我们就不考虑同步发送的问题，我们基于异步发送的场景来说。</p>
<p>异步发送分为两个方式：<strong>异步有回调和异步无回调</strong>，无回调的方式，生产者发送完后不管结果可能就会造成消息丢失，而通过异步发送+回调通知+本地消息表的形式我们就可以做出一个解决方案。以下单的场景举例。</p>
<ol>
<li>下单后先保存本地数据和MQ消息表，这时候消息的状态是发送中，如果本地事务失败，那么下单失败，事务回滚。</li>
<li>下单成功，直接返回客户端成功，异步发送MQ消息</li>
<li>MQ回调通知消息发送结果，对应更新数据库MQ发送状态</li>
<li>JOB轮询超过一定时间（时间根据业务配置）还未发送成功的消息去重试</li>
<li>在监控平台配置或者JOB程序处理超过一定次数一直发送不成功的消息，告警，人工介入。</li>
</ol>
<p>一般而言，对于大部分场景来说异步回调的形式就可以了，只有那种需要完全保证不能丢失消息的场景我们做一套完整的解决方案。</p>
<h3 id="MQ丢失"><a href="#MQ丢失" class="headerlink" title="MQ丢失"></a>MQ丢失</h3><p>如果生产者保证消息发送到MQ，而MQ收到消息后还在内存中，这时候宕机了又没来得及同步给从节点，就有可能导致消息丢失。</p>
<p>比如RocketMQ：</p>
<p>RocketMQ分为同步刷盘和异步刷盘两种方式，默认的是异步刷盘，就有可能导致消息还未刷到硬盘上就丢失了，可以通过设置为同步刷盘的方式来保证消息可靠性，这样即使MQ挂了，恢复的时候也可以从磁盘中去恢复消息。</p>
<p>比如Kafka也可以通过配置做到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">acks=all 只有参与复制的所有节点全部收到消息，才返回生产者成功。这样的话除非所有的节点都挂了，消息才会丢失。</span><br><span class="line">replication.factor=N,设置大于1的数，这会要求每个partion至少有2个副本</span><br><span class="line">min.insync.replicas=N，设置大于1的数，这会要求leader至少感知到一个follower还保持着连接</span><br><span class="line">retries=N，设置一个非常大的值，让生产者发送失败一直重试</span><br></pre></td></tr></table></figure>

<p>虽然我们可以通过配置的方式来达到MQ本身高可用的目的，但是都对性能有损耗，怎样配置需要根据业务做出权衡。</p>
<h3 id="消费者丢失"><a href="#消费者丢失" class="headerlink" title="消费者丢失"></a>消费者丢失</h3><p>消费者丢失消息的场景：消费者刚收到消息，此时服务器宕机，MQ认为消费者已经消费，不会重复发送消息，消息丢失。</p>
<p>RocketMQ默认是需要消费者回复ack确认，而kafka需要手动开启配置关闭自动offset。</p>
<p>消费方不返回ack确认，重发的机制根据MQ类型的不同发送时间间隔、次数都不尽相同，如果重试超过次数之后会进入死信队列，需要手工来处理了。（Kafka没有这些）</p>
<h3 id="24、-你说到消费者消费失败的问题，那么如果一直消费失败导致消息积压怎么处理？"><a href="#24、-你说到消费者消费失败的问题，那么如果一直消费失败导致消息积压怎么处理？" class="headerlink" title="24、 你说到消费者消费失败的问题，那么如果一直消费失败导致消息积压怎么处理？"></a>24、 你说到消费者消费失败的问题，那么如果一直消费失败导致消息积压怎么处理？</h3><p>因为考虑到时消费者消费一直出错的问题，那么我们可以从以下几个角度来考虑：</p>
<ol>
<li>消费者出错，肯定是程序或者其他问题导致的，如果容易修复，先把问题修复，让consumer恢复正常消费</li>
<li>如果时间来不及处理很麻烦，做转发处理，写一个临时的consumer消费方案，先把消息消费，然后再转发到一个新的topic和MQ资源，这个新的topic的机器资源单独申请，要能承载住当前积压的消息</li>
<li>处理完积压数据后，修复consumer，去消费新的MQ和现有的MQ数据，新MQ消费完成后恢复原状</li>
</ol>
<h3 id="25、-那如果消息积压达到磁盘上限，消息被删除了怎么办？"><a href="#25、-那如果消息积压达到磁盘上限，消息被删除了怎么办？" class="headerlink" title="25、 那如果消息积压达到磁盘上限，消息被删除了怎么办？"></a>25、 那如果消息积压达到磁盘上限，消息被删除了怎么办？</h3><p>最初，我们发送的消息记录是落库保存了的，而转发发送的数据也保存了，那么我们就可以通过这部分数据来找到丢失的那部分数据，再单独跑个脚本重发就可以了。如果转发的程序没有落库，那就和消费方的记录去做对比，只是过程会更艰难一点。</p>
<h3 id="26、-说了这么多，那你说说RocketMQ实现原理吧？"><a href="#26、-说了这么多，那你说说RocketMQ实现原理吧？" class="headerlink" title="26、 说了这么多，那你说说RocketMQ实现原理吧？"></a>26、 说了这么多，那你说说RocketMQ实现原理吧？</h3><p>RocketMQ由NameServer注册中心集群、Producer生产者集群、Consumer消费者集群和若干Broker（RocketMQ进程）组成，它的架构原理是这样的：</p>
<ol>
<li>Broker在启动的时候去向所有的NameServer注册，并保持长连接，每30s发送一次心跳</li>
<li>Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息</li>
<li>Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费</li>
</ol>
<h3 id="27、-为什么RocketMQ不使用Zookeeper作为注册中心呢？"><a href="#27、-为什么RocketMQ不使用Zookeeper作为注册中心呢？" class="headerlink" title="27、 为什么RocketMQ不使用Zookeeper作为注册中心呢？"></a><code>27、</code> 为什么RocketMQ不使用Zookeeper作为注册中心呢？</h3><p>我认为有以下几个点是不使用zookeeper的原因：</p>
<ol>
<li>根据CAP理论，同时最多只能满足两个点，而zookeeper满足的是CP，也就是说zookeeper并不能保证服务的可用性，zookeeper在进行选举的时候，整个选举的时间太长，期间整个集群都处于不可用的状态，而这对于一个注册中心来说肯定是不能接受的，作为服务发现来说就应该是为可用性而设计。</li>
<li>基于性能的考虑，NameServer本身的实现非常轻量，而且可以通过增加机器的方式水平扩展，增加集群的抗压能力，而zookeeper的写是不可扩展的，而zookeeper要解决这个问题只能通过划分领域，划分多个zookeeper集群来解决，首先操作起来太复杂，其次这样还是又违反了CAP中的A的设计，导致服务之间是不连通的。</li>
<li>持久化的机制来带的问题，ZooKeeper 的 ZAB 协议对每一个写请求，会在每个 ZooKeeper 节点上保持写一个事务日志，同时再加上定期的将内存数据镜像（Snapshot）到磁盘来保证数据的一致性和持久性，而对于一个简单的服务发现的场景来说，这其实没有太大的必要，这个实现方案太重了。而且本身存储的数据应该是高度定制化的。</li>
<li>消息发送应该弱依赖注册中心，而RocketMQ的设计理念也正是基于此，生产者在第一次发送消息的时候从NameServer获取到Broker地址后缓存到本地，如果NameServer整个集群不可用，短时间内对于生产者和消费者并不会产生太大影响。</li>
</ol>
<h3 id="28、-那Broker是怎么保存数据的呢？"><a href="#28、-那Broker是怎么保存数据的呢？" class="headerlink" title="28、 那Broker是怎么保存数据的呢？"></a><code>28、</code> 那Broker是怎么保存数据的呢？</h3><p>RocketMQ主要的存储文件包括commitlog文件、consumequeue文件、indexfile文件。</p>
<p>Broker在收到消息之后，会把消息保存到commitlog的文件当中，而同时在分布式的存储当中，每个broker都会保存一部分topic的数据，同时，每个topic对应的messagequeue下都会生成consumequeue文件用于保存commitlog的物理位置偏移量offset，indexfile中会保存key和offset的对应关系。</p>
<p>CommitLog文件保存于${Rocket_Home}/store/commitlog目录中，从图中我们可以明显看出来文件名的偏移量，每个文件默认1G，写满后自动生成一个新的文件。</p>
<p>由于同一个topic的消息并不是连续的存储在commitlog中，消费者如果直接从commitlog获取消息效率非常低，所以通过consumequeue保存commitlog中消息的偏移量的物理地址，这样消费者在消费的时候先从consumequeue中根据偏移量定位到具体的commitlog物理文件，然后根据一定的规则（offset和文件大小取模）在commitlog中快速定位。</p>
<h3 id="29、-Master和Slave之间是怎么同步数据的呢？"><a href="#29、-Master和Slave之间是怎么同步数据的呢？" class="headerlink" title="29、 Master和Slave之间是怎么同步数据的呢？"></a><code>29、</code> Master和Slave之间是怎么同步数据的呢？</h3><p>而消息在master和slave之间的同步是根据raft协议来进行的：</p>
<ol>
<li>在broker收到消息后，会被标记为uncommitted状态</li>
<li>然后会把消息发送给所有的slave</li>
<li>slave在收到消息之后返回ack响应给master</li>
<li>master在收到超过半数的ack之后，把消息标记为committed</li>
<li>发送committed消息给所有slave，slave也修改状态为committed</li>
</ol>
<h3 id="30、-你知道RocketMQ为什么速度快吗？"><a href="#30、-你知道RocketMQ为什么速度快吗？" class="headerlink" title="30、 你知道RocketMQ为什么速度快吗？"></a><code>30、</code> 你知道RocketMQ为什么速度快吗？</h3><p>是因为使用了顺序存储、Page Cache和异步刷盘。</p>
<ol>
<li>我们在写入commitlog的时候是顺序写入的，这样比随机写入的性能就会提高很多</li>
<li>写入commitlog的时候并不是直接写入磁盘，而是先写入操作系统的PageCache</li>
<li>最后由操作系统异步将缓存中的数据刷到磁盘</li>
</ol>
<h3 id="31、-什么是事务、半事务消息？怎么实现的？"><a href="#31、-什么是事务、半事务消息？怎么实现的？" class="headerlink" title="31、 什么是事务、半事务消息？怎么实现的？"></a><code>31、</code> 什么是事务、半事务消息？怎么实现的？</h3><p>事务消息就是MQ提供的类似XA的分布式事务能力，通过事务消息可以达到分布式事务的最终一致性。</p>
<p>半事务消息就是MQ收到了生产者的消息，但是没有收到二次确认，不能投递的消息。</p>
<p>实现原理如下：</p>
<ol>
<li>生产者先发送一条半事务消息到MQ</li>
<li>MQ收到消息后返回ack确认</li>
<li>生产者开始执行本地事务</li>
<li>如果事务执行成功发送commit到MQ，失败发送rollback</li>
<li>如果MQ长时间未收到生产者的二次确认commit或者rollback，MQ对生产者发起消息回查</li>
<li>生产者查询事务执行最终状态</li>
<li>根据查询事务状态再次提交二次确认</li>
</ol>
<p>最终，如果MQ收到二次确认commit，就可以把消息投递给消费者，反之如果是rollback，消息会保存下来并且在3天后被删除。</p>
<h3 id="32、-为什么要用RocketMq？"><a href="#32、-为什么要用RocketMq？" class="headerlink" title="32、 为什么要用RocketMq？"></a><code>32、</code> 为什么要用RocketMq？</h3><p>总得来说，RocketMq具有以下几个优势：</p>
<p><strong>吞吐量高</strong>：单机吞吐量可达十万级<strong>可用性高</strong>：分布式架构<strong>消息可靠性高</strong>：经过参数优化配置，消息可以做到0丢失<strong>功能支持完善</strong>：MQ功能较为完善，还是分布式的，扩展性好<strong>支持10亿级别的消息堆积</strong>：不会因为堆积导致性能下降<strong>源码是java</strong>：方便我们查看源码了解它的每个环节的实现逻辑，并针对不同的业务场景进行扩展 可靠性高：天生为金融互联网领域而生，对于要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况<strong>稳定性高</strong>：RoketMQ在上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验</p>
<h3 id="33、-RocketMq的部署架构了解吗？"><a href="#33、-RocketMq的部署架构了解吗？" class="headerlink" title="33、 RocketMq的部署架构了解吗？"></a><code>33、</code> RocketMq的部署架构了解吗？</h3><p>这个是rocketMq的集群架构图，里面包含了四个主要部分：<strong>NameServer集群,Producer集群,Cosumer集群以及Broker集群</strong></p>
<p><strong>NameServer 担任路由消息的提供者</strong>。生产者或消费者能够通过NameServer查找各Topic相应的Broker IP列表分别进行发送消息和消费消息。<strong>nameServer由多个无状态的节点构成，节点之间无任何信息同步</strong></p>
<p><strong>broker会定期向NameServer以发送心跳包的方式，轮询向所有NameServer注册以下元数据信息</strong>：</p>
<p>1）broker的基本信息（ip port等）</p>
<p>2）主题topic的地址信息</p>
<p>3）broker集群信息</p>
<p>4）存活的broker信息</p>
<p>5）filter 过滤器</p>
<p>也就是说，每个NameServer注册的信息都是一样的，而且是当前系统中的所有broker的元数据信息</p>
<p><strong>Producer负责生产消息</strong>，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要</p>
<p><strong>Broker，消息中转角色，负责存储消息、转发消息</strong>。在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备</p>
<p><strong>Consumer负责消费消息，一般是后台系统负责异步消费</strong>。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费</p>
<h3 id="34、-它有哪几种部署类型？分别有什么特点？"><a href="#34、-它有哪几种部署类型？分别有什么特点？" class="headerlink" title="34、 它有哪几种部署类型？分别有什么特点？"></a><code>34、</code> 它有哪几种部署类型？分别有什么特点？</h3><p>RocketMQ有4种部署类型</p>
<p>1）单Master</p>
<p>单机模式, 即只有一个Broker, 如果Broker宕机了, 会导致RocketMQ服务不可用, 不推荐使用</p>
<p>2）多Master模式</p>
<p>组成一个集群, 集群每个节点都是Master节点, 配置简单, 性能也是最高, 某节点宕机重启不会影响RocketMQ服务</p>
<p>缺点：如果某个节点宕机了, 会导致该节点存在未被消费的消息在节点恢复之前不能被消费</p>
<p>3）<strong>多Master多Slave模式，异步复制</strong></p>
<p>每个Master配置一个Slave, 多对Master-Slave, Master与Slave消息采用异步复制方式, 主从消息一致只会有毫秒级的延迟</p>
<p>优点是弥补了多Master模式（无slave）下节点宕机后在恢复前不可订阅的问题。在Master宕机后, 消费者还可以从Slave节点进行消费。采用异步模式复制，提升了一定的吞吐量。总结一句就是，<strong>采用多Master多Slave模式，异步复制模式进行部署，系统将会有较低的延迟和较高的吞吐量</strong></p>
<p>缺点就是如果Master宕机, 磁盘损坏的情况下, 如果没有及时将消息复制到Slave, 会导致有<strong>少量消息丢失</strong></p>
<p>4）<strong>多Master多Slave模式，同步双写</strong></p>
<p>与多Master多Slave模式，异步复制方式基本一致，唯一不同的是消息复制采用同步方式，只有master和slave都写成功以后，才会向客户端返回成功</p>
<p>优点：数据与服务都无单点，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高</p>
<p>缺点就是会降低消息写入的效率，并影响系统的吞吐量</p>
<p>实际部署中，一般会根据业务场景的所需要的性能和消息可靠性等方面来选择后两种</p>
<h3 id="35、-你自己部署过RocketMq吗？简单说一下你当时部署的过程"><a href="#35、-你自己部署过RocketMq吗？简单说一下你当时部署的过程" class="headerlink" title="35、 你自己部署过RocketMq吗？简单说一下你当时部署的过程"></a><code>35、</code> 你自己部署过RocketMq吗？简单说一下你当时部署的过程</h3><p>由于我们项目中主要使用rocketMq做链路跟踪功能，因此需要比较高的性能，并且偶尔丢失几条消息也关系不大，所以我们就选择多Master多Slave模式，异步复制方式进行部署</p>
<p>部署过程简单说一下： 我部署的是双master和双slave模式集群，并部署了两个nameserver节点<strong>1）服务器分配</strong>分配是两台服务器，A和B，<strong>其中A服务器部署nameserv1,master1,slave2</strong>;<strong>B服务器部署nameserv2,master2和slave1节点</strong></p>
<p><strong>2）broker的配置</strong>分别配置rocketmq安装目录下四个配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">master1:/conf/2m-2s-async/broker-a.properties</span><br><span class="line">slave2:/conf/2m-2s-async/broker-b-s.properties</span><br><span class="line">master2:/conf/2m-2s-async/broker-b.properties</span><br><span class="line">slave1:/conf/2m-2s-async/broker-a-s.properties</span><br></pre></td></tr></table></figure>


<p><strong>总的思路是</strong>： a.master节点的brokerId为0，slave节点的brokerId为1（大于0即可）； b.同一组broker的broker-Name相同，如master1和slave1都为broker-a; c.每个broker节点配置相同的NameServer; d.复制方式配置：master节点配置为ASYNC-MASTER，slave节点配置为SLAVE即可； e.刷盘方式分为同步刷盘和异步刷盘，为了保证性能而不去考虑少量消息的丢失，因此同意配置为异步刷盘</p>
<p><strong>3）启动集群</strong></p>
<p>a 检查修改参数</p>
<p>启动前分别检查修改runbroker.sh和runserver.sh两个文件中的JVM参数，默认的JAVA_OPT参数的值比较大，若直接启动可能会失败，需要根据实际情况重新配置</p>
<p><strong>b 分别启动两个namerser节点</strong></p>
<p>nohup sh bin/mqnamesrv &gt; /dev/null 2&gt;&amp;1 &amp;</p>
<p><strong>查看日志</strong></p>
<p>tail -f ~/logs/rocketmqlogs/namesrv.log</p>
<p><strong>c 分别启动4个broker节点</strong></p>
<p>maste1</p>
<p>nohup sh bin/mqbroker -c /usr/local/rocketmq/conf/2m-2s-async/broker-a.properties &amp;</p>
<p>slave1</p>
<p>nohup sh bin/mqbroker -c /usr/local/rocketmq/conf/2m-2s-async/broker-a-s.properties &amp;</p>
<p>maste2</p>
<p>nohup sh bin/mqbroker -c /usr/local/rocketmq/conf/2m-2s-async/broker-b.properties &amp;</p>
<p>slave2</p>
<p>nohup sh bin/mqbroker -c /usr/local/rocketmq/conf/2m-2s-async/broker-b-s.properties &amp;</p>
<p><strong>查看日志：</strong></p>
<p>tail -f ~/logs/rocketmqlogs/broker.log</p>
<p>总结：<strong>集群环境部署，主要就是以上三个步骤，需要注意的是过程中broker配置文件的配置正确性，还需要注意一下启动前对jvm参数的检查</strong></p>
<h3 id="36、-rocketmq如何保证高可用性？"><a href="#36、-rocketmq如何保证高可用性？" class="headerlink" title="36、 rocketmq如何保证高可用性？"></a><code>36、</code> rocketmq如何保证高可用性？</h3><p><strong>1）集群化部署NameServer</strong>。Broker集群会将所有的broker基本信息、topic信息以及两者之间的映射关系，轮询存储在每个NameServer中（也就是说每个NameServer存储的信息完全一样）。因此，NameServer集群化，不会因为其中的一两台服务器挂掉，而影响整个架构的消息发送与接收；</p>
<p><strong>2）集群化部署多broker</strong>。producer发送消息到broker的master，若当前的master挂掉，则会自动切换到其他的master</p>
<p>cosumer默认会访问broker的master节点获取消息，那么master节点挂了之后，该怎么办呢？它就会自动切换到同一个broker组的slave节点进行消费</p>
<p>那么你肯定会想到会有这样一个问题：consumer要是直接消费slave节点，那master在宕机前没有来得及把消息同步到slave节点，那这个时候，不就会出现消费者不就取不到消息的情况了？</p>
<p>这样，就引出了下一个措施，来保证消息的高可用性</p>
<p><strong>3）设置同步复制</strong></p>
<p>前面已经提到，消息发送到broker的master节点上，master需要将消息复制到slave节点上，rocketmq提供两种复制方式：同步复制和异步复制</p>
<p>异步复制，就是消息发送到master节点，只要master写成功，就直接向客户端返回成功，后续再异步写入slave节点</p>
<p>同步复制，就是等master和slave都成功写入内存之后，才会向客户端返回成功</p>
<p>那么，要保证高可用性，就需要将复制方式配置成同步复制，这样即使master节点挂了，slave上也有当前master的所有备份数据，那么不仅保证消费者消费到的消息是完整的，并且当master节点恢复之后，也容易恢复消息数据</p>
<p>在master的配置文件中直接配置brokerRole：SYNC_MASTER即可</p>
<h3 id="37、-rocketmq的工作流程是怎样的？"><a href="#37、-rocketmq的工作流程是怎样的？" class="headerlink" title="37、 rocketmq的工作流程是怎样的？"></a><code>37、</code> rocketmq的工作流程是怎样的？</h3><p>RocketMq的工作流程如下：</p>
<p><strong>1）首先启动NameServer</strong>。NameServer启动后监听端口，等待Broker、Producer以及Consumer连上来</p>
<p><strong>2）启动Broker</strong>。启动之后，会跟所有的NameServer建立并保持一个长连接，定时发送心跳包。心跳包中包含当前Broker信息(ip、port等)、Topic信息以及Borker与Topic的映射关系</p>
<p><strong>3）创建Topic</strong>。创建时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic</p>
<p><strong>4）Producer发送消息</strong>。启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic所在的Broker；然后从队列列表中轮询选择一个队列，与队列所在的Broker建立长连接，进行消息的发送</p>
<p><strong>5）Consumer消费消息</strong>。跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，进行消息的消费</p>
<h3 id="38、-RocketMq使用哪种方式消费消息，pull还是push？"><a href="#38、-RocketMq使用哪种方式消费消息，pull还是push？" class="headerlink" title="38、 RocketMq使用哪种方式消费消息，pull还是push？"></a><code>38、</code> RocketMq使用哪种方式消费消息，pull还是push？</h3><p>RocketMq提供两种方式：pull和push进行消息的消费</p>
<p>而RocketMq的push方式，本质上也是采用pull的方式进行实现的。也就是说<strong>这两种方式本质上都是采用consumer轮询从broker拉取消息的</strong></p>
<p>push方式里，consumer把轮询过程封装了一层，并注册了MessageListener监听器。当轮询取到消息后，便唤醒MessageListener的consumeMessage()来消费，对用户而言，感觉好像消息是被推送过来的</p>
<p>其实想想，消息统一都发到了broker，而broker又不会主动去push消息，那么消息肯定都是需要消费者主动去拉的喽~</p>
<h3 id="39、-RocketMq如何负载均衡？"><a href="#39、-RocketMq如何负载均衡？" class="headerlink" title="39、 RocketMq如何负载均衡？"></a><code>39、</code> RocketMq如何负载均衡？</h3><p>1）producer发送消息的负载均衡：默认会轮询向Topic的所有queue发送消息，以达到消息平均落到不同的queue上；而由于queue可以落在不同的broker上，就可以发到不同broker上（当然也可以指定发送到某个特定的queue上）</p>
<p>2）consumer订阅消息的负载均衡：假设有5个队列，两个消费者，则第一个消费者消费3个队列，第二个则消费2个队列，以达到平均消费的效果。而需要注意的是，当consumer的数量大于队列的数量的话，根据rocketMq的机制，多出来的队列不会去消费数据，因此建议consumer的数量小于或者等于queue的数量，避免不必要的浪费</p>
<h3 id="40、-RocketMq的存储机制了解吗？"><a href="#40、-RocketMq的存储机制了解吗？" class="headerlink" title="40、 RocketMq的存储机制了解吗？"></a><code>40、</code> RocketMq的存储机制了解吗？</h3><p>RocketMq采用<strong>文件系统进行消息的存储</strong>，相对于ActiveMq采用关系型数据库进行存储的方式就更直接，性能更高了</p>
<p>RocketMq与Kafka在写消息与发送消息上，继续沿用了Kafka的这两个方面：顺序写和零拷贝</p>
<p><strong>1）顺序写</strong>我们知道，操作系统每次从磁盘读写数据的时候，都需要找到数据在磁盘上的地址，再进行读写。而如果是机械硬盘，寻址需要的时间往往会比较长 而一般来说，如果把数据存储在内存上面，少了寻址的过程，性能会好很多；但Kafka 的数据存储在磁盘上面，依然性能很好，这是为什么呢？ 这是因为，Kafka采用的是顺序写，直接追加数据到末尾。实际上，磁盘顺序写的性能极高，在磁盘个数一定，转数一定的情况下，基本和内存速度一致 因此，磁盘的顺序写这一机制，极大地保证了Kafka本身的性能<strong>2）零拷贝</strong>比如：读取文件，再用socket发送出去这一过程</p>
<p>buffer = File.read Socket.send(buffer)</p>
<p>传统方式实现： 先读取、再发送，实际会经过以下四次复制 1、将磁盘文件，读取到操作系统内核缓冲区Read Buffer 2、将内核缓冲区的数据，复制到应用程序缓冲区Application Buffer 3、将应用程序缓冲区Application Buffer中的数据，复制到socket网络发送缓冲区 4、将Socket buffer的数据，复制到网卡，由网卡进行网络传输</p>
<p>传统方式，读取磁盘文件并进行网络发送，经过的四次数据copy是非常繁琐的 重新思考传统IO方式，会注意到在读取磁盘文件后，不需要做其他处理，直接用网络发送出去的这种场景下，第二次和第三次数据的复制过程，不仅没有任何帮助，反而带来了巨大的开销。那么这里使用了零拷贝，也就是说，直接由内核缓冲区Read Buffer将数据复制到网卡，省去第二步和第三步的复制。 图片 那么采用零拷贝的方式发送消息，必定会大大减少读取的开销，使得RocketMq读取消息的性能有一个质的提升</p>
<p>此外，还需要再提一点，零拷贝技术采用了MappedByteBuffer内存映射技术，采用这种技术有一些限制，其中有一条就是传输的文件不能超过2G，这也就是为什么RocketMq的存储消息的文件CommitLog的大小规定为1G的原因</p>
<p>小结：<strong>RocketMq采用文件系统存储消息，并采用顺序写写入消息，使用零拷贝发送消息，极大得保证了RocketMq的性能</strong></p>
<h3 id="41、-RocketMq的存储结构是怎样的？"><a href="#41、-RocketMq的存储结构是怎样的？" class="headerlink" title="41、 RocketMq的存储结构是怎样的？"></a><code>41、</code> RocketMq的存储结构是怎样的？</h3><p>如图所示，消息生产者发送消息到broker，都是会按照顺序存储在CommitLog文件中，每个commitLog文件的大小为1G</p>
<p>CommitLog-存储所有的消息元数据，包括Topic、QueueId以及message</p>
<p>CosumerQueue-消费逻辑队列：存储消息在CommitLog的offset</p>
<p>IndexFile-索引文件：存储消息的key和时间戳等信息，使得RocketMq可以采用key和时间区间来查询消息</p>
<p>也就是说，rocketMq将消息均存储在CommitLog中，并分别提供了CosumerQueue和IndexFile两个索引，来快速检索消息</p>
<h3 id="42、-RocketMq如何进行消息的去重？"><a href="#42、-RocketMq如何进行消息的去重？" class="headerlink" title="42、 RocketMq如何进行消息的去重？"></a><code>42、</code> RocketMq如何进行消息的去重？</h3><p>我们知道，只要通过网络交换数据，就无法避免因为网络不可靠而造成的消息重复这个问题。比如说RocketMq中，当consumer消费完消息后，因为网络问题未及时发送ack到broker,broker就不会删掉当前已经消费过的消息，那么，该消息将会被重复投递给消费者去消费</p>
<p>虽然rocketMq保证了同一个消费组只能消费一次，但会被不同的消费组重复消费，因此这种重复消费的情况不可避免</p>
<p>RocketMq本身并不保证消息不重复，这样肯定会因为每次的判断，导致性能打折扣，所以它将去重操作直接放在了消费端：</p>
<p>1）消费端处理消息的业务逻辑保持幂等性。那么不管来多少条重复消息，可以实现处理的结果都一样</p>
<p>2）还可以建立一张日志表，使用消息主键作为表的主键，在处理消息前，先insert表，再做消息处理。这样可以避免消息重复消费</p>
<h3 id="43、-为什么使用MQ？优点？常用场景？"><a href="#43、-为什么使用MQ？优点？常用场景？" class="headerlink" title="43、 为什么使用MQ？优点？常用场景？"></a><code>43、</code> 为什么使用MQ？优点？常用场景？</h3><ul>
<li>简答</li>
<li><strong>异步处理</strong> - 相比于传统的串行、并行方式，提高了系统吞吐量。</li>
<li><strong>应用解耦</strong> - 系统间通过消息通信，不用关心其他系统的处理。</li>
<li><strong>流量削锋</strong> - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li>
<li><strong>日志处理</strong> - 解决大量日志传输。</li>
<li><strong>消息通讯</strong> - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li>
<li>详答</li>
</ul>
<p>主要是： <code>解耦</code> 、 <code>异步</code> 、 <code>削峰</code> 。</p>
<ul>
<li><strong>解耦</strong>： A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃…A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</li>
</ul>
<p>就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。</p>
<ul>
<li><strong>异步</strong>： A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。</li>
<li><strong>削峰</strong>： 减少高峰时期对服务器压力。</li>
</ul>
<h3 id="44、-使用MQ有什么缺点？"><a href="#44、-使用MQ有什么缺点？" class="headerlink" title="44、 使用MQ有什么缺点？"></a><code>44、</code> 使用MQ有什么缺点？</h3><ul>
<li><strong>系统可用性降低</strong>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 B、C、D三个系统的接口就好了，人 A、B、C、D四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整，MQ一挂，整套系统崩溃的，你不就完了？如何保证消息队列的高可用，可以点击这里查看。</li>
<li><strong>系统复杂度提高</strong>硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</li>
<li><strong>一致性问题</strong>A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 B、C、D 三个系统那里，B、D两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。</li>
</ul>
<p>所以消息队列实际是一种非常复杂的架构，引入MQ有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，系统复杂度提升了一个数量级，也许是复杂了10倍。但是关键时刻，还是得用的。</p>
<h3 id="45、-Kafka、ActiveMQ、RabbitMQ、RocketMQ-的区别？"><a href="#45、-Kafka、ActiveMQ、RabbitMQ、RocketMQ-的区别？" class="headerlink" title="45、 Kafka、ActiveMQ、RabbitMQ、RocketMQ 的区别？"></a><code>45、</code> Kafka、ActiveMQ、RabbitMQ、RocketMQ 的区别？</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">ActiveMQ</th>
<th align="left">RabbitMQ</th>
<th align="left">RocketMQ</th>
<th align="left">Kafka</th>
<th align="left">ZeroMQ</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单机吞吐量</td>
<td align="left">比RabbitMQ低</td>
<td align="left">2.6w/s（消息做持久化）</td>
<td align="left">11.6w/s</td>
<td align="left">17.3w/s</td>
<td align="left">29w/s</td>
</tr>
<tr>
<td align="left">开发语言</td>
<td align="left">Java</td>
<td align="left">Erlang</td>
<td align="left">Java</td>
<td align="left">Scala/Java</td>
<td align="left">C</td>
</tr>
<tr>
<td align="left">主要维护者</td>
<td align="left">Apache</td>
<td align="left">Mozilla/Spring</td>
<td align="left">Alibaba</td>
<td align="left">Apache</td>
<td align="left">iMatix，创始人已去世</td>
</tr>
<tr>
<td align="left">成熟度</td>
<td align="left">成熟</td>
<td align="left">成熟</td>
<td align="left">开源版本不够成熟</td>
<td align="left">比较成熟</td>
<td align="left">只有C、PHP等版本成熟</td>
</tr>
<tr>
<td align="left">订阅形式</td>
<td align="left">点对点(p2p)、广播（发布-订阅）</td>
<td align="left">提供了4种：direct, topic ,Headers和fanout。fanout就是广播模式</td>
<td align="left">基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式</td>
<td align="left">基于topic以及按照topic进行正则匹配的发布订阅模式</td>
<td align="left">点对点(p2p)</td>
</tr>
<tr>
<td align="left">持久化</td>
<td align="left">支持少量堆积</td>
<td align="left">支持少量堆积</td>
<td align="left">支持大量堆积</td>
<td align="left">支持大量堆积</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">顺序消息</td>
<td align="left">不支持</td>
<td align="left">不支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">性能稳定性</td>
<td align="left">好</td>
<td align="left">好</td>
<td align="left">一般</td>
<td align="left">较差</td>
<td align="left">很好</td>
</tr>
<tr>
<td align="left">集群方式</td>
<td align="left">支持简单集群模式，比如’主-备’，对高级集群模式支持不好。</td>
<td align="left">支持简单集群，’复制’模式，对高级集群模式支持不好。</td>
<td align="left">常用 多对’Master-Slave’ 模式，开源版本需手动切换Slave变成Master</td>
<td align="left">天然的‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">管理界面</td>
<td align="left">一般</td>
<td align="left">较好</td>
<td align="left">一般</td>
<td align="left">无</td>
<td align="left">无</td>
</tr>
</tbody></table>
<p>综上，各种对比之后，有如下建议：</p>
<p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p>
<p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p>
<p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给  Apache ，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p>
<p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p>
<p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>
<h3 id="46、-消息队列如何选型"><a href="#46、-消息队列如何选型" class="headerlink" title="46、 消息队列如何选型?"></a><code>46、</code> 消息队列如何选型?</h3><ol>
<li>如果消息队列不是将要构建系统的重点，对消息队列功能和性能没有很高的要求，只需要一个快速上手易于维护的消息队列，建议使用RabbitMQ。</li>
<li>如果系统使用消息队列主要场景是处理在线业务，比如在交易系统中用消息队列传递订单，需要低延迟和高稳定性，建议使用RocketMQ。</li>
<li>如果需要处理海量的消息，像收集日志、监控信息或是埋点这类数据，或是你的应用场景大量使用了大数据、流计算相关的开源产品，那Kafka是最适合的消息队列。</li>
</ol>
<h3 id="47、-MQ-有哪些常见问题？如何解决这些问题？"><a href="#47、-MQ-有哪些常见问题？如何解决这些问题？" class="headerlink" title="47、 MQ 有哪些常见问题？如何解决这些问题？"></a><code>47、</code> MQ 有哪些常见问题？如何解决这些问题？</h3><p>MQ 的常见问题有：</p>
<ul>
<li><strong>消息的顺序问题</strong></li>
</ul>
<p>消息有序指的是可以按照消息的发送顺序来消费。</p>
<p>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</p>
<p>解决方案：</p>
<ul>
<li>保证生产者 - MQServer - 消费者是一对一对一的关系</li>
</ul>
<p>缺陷：</p>
<ul>
<li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li>
<li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。 （2）通过合理的设计或者将问题分解来规避。</li>
<li>不关注乱序的应用实际大量存在</li>
<li>队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</li>
<li><strong>消息的重复问题</strong></li>
</ul>
<p>造成消息重复的根本原因是：网络不可达。</p>
<p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<p>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</p>
<h3 id="48、-依托消息中间件如何实现异步？"><a href="#48、-依托消息中间件如何实现异步？" class="headerlink" title="48、 依托消息中间件如何实现异步？"></a><code>48、</code> 依托消息中间件如何实现异步？</h3><p>引入了MQ后，用来的依赖关系转移了，从系统之间的依赖，变成系统都依赖MQ</p>
<p>A调用B，只需要向MQ发送一条消息，A就认为自己的工作完成了。不用像之前调用B一样等着B处理一堆的业务逻辑和数据库操作。</p>
<p>B会从MQ中读取A发送的特定消息，完成自己该做的事情。</p>
<p>这样就实现了A异步调用B</p>
<h3 id="49、-RocketMQ消息是push还是pull？"><a href="#49、-RocketMQ消息是push还是pull？" class="headerlink" title="49、 RocketMQ消息是push还是pull？"></a><code>49、</code> RocketMQ消息是push还是pull？</h3><p>RocketMQ没有真正意义的push，都是pull，虽然有push类，但实际底层实现采用的是<strong>长轮询机制</strong>，即拉取方式 broker端属性 longPollingEnable 标记是否开启长轮询。默认开启</p>
<p>源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// &#123;@link org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#pullMessage()&#125;</span><br><span class="line">// 看到没，这是一只披着羊皮的狼，名字叫PushConsumerImpl，实际干的确是pull的活。</span><br><span class="line">// 拉取消息，结果放到pullCallback里</span><br><span class="line">this.pullAPIWrapper.pullKernelImpl(pullCallback);</span><br></pre></td></tr></table></figure>

<h3 id="50、-为什么要主动拉取消息而不使用事件监听方式？"><a href="#50、-为什么要主动拉取消息而不使用事件监听方式？" class="headerlink" title="50、 为什么要主动拉取消息而不使用事件监听方式？"></a><code>50、</code> 为什么要主动拉取消息而不使用事件监听方式？</h3><p>事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送。</p>
<p>如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在 Consumer 端堆积过多，同时又不能被其他 Consumer 消费的情况。而 pull 的方式可以根据当前自身情况来 pull，不会造成过多的压力而造成瓶颈。所以采取了 pull 的方式。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io">Eric</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io/posts/3620143989/">https://ericwjian.github.io/posts/3620143989/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericwjian.github.io" target="_blank">Eric</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2914853936/" title="Redis面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis面试题</div></div></a></div><div class="next-post pull-right"><a href="/posts/2083621419/" title="Java 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2037477332/" title="面试其他问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">面试其他问题</div></div></a></div><div><a href="/posts/1514862636/" title="实际面试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">实际面试</div></div></a></div><div><a href="/posts/1514862635/" title="数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">数据结构</div></div></a></div><div><a href="/posts/742890947/" title="Mybatis 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">Mybatis 面试题</div></div></a></div><div><a href="/posts/1636770274/" title="SpringMVC 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">SpringMVC 面试题</div></div></a></div><div><a href="/posts/1218378067/" title="Spring面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-11</div><div class="title">Spring面试题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Eric</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/wangjian_uuid" target="_blank" title="Gitee"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:358070983@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=358070983&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-RocketMQ%E7%B2%BE%E9%80%89%E9%9D%A2%E8%AF%95%E9%A2%9850%E9%81%93"><span class="toc-text">2022 RocketMQ精选面试题50道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-%E5%A4%9A%E4%B8%AAmq%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B%EF%BC%9F"><span class="toc-text">1、 多个mq如何选型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8MQ%EF%BC%9F"><span class="toc-text">2、 为什么要使用MQ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81-RocketMQ%E7%94%B1%E5%93%AA%E4%BA%9B%E8%A7%92%E8%89%B2%E7%BB%84%E6%88%90%EF%BC%8C%E6%AF%8F%E4%B8%AA%E8%A7%92%E8%89%B2%E4%BD%9C%E7%94%A8%E5%92%8C%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">3、 RocketMQ由哪些角色组成，每个角色作用和特点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81-RocketMQ%E4%B8%AD%E7%9A%84Topic%E5%92%8CJMS%E7%9A%84queue%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4、 RocketMQ中的Topic和JMS的queue有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81-RocketMQ-Broker%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%A2%AB%E6%B6%88%E8%B4%B9%E5%90%8E%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%88%A0%E9%99%A4%E5%90%97%EF%BC%9F"><span class="toc-text">5、 RocketMQ Broker中的消息被消费后会立即删除吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%EF%BC%9A%E9%82%A3%E4%B9%88%E6%B6%88%E6%81%AF%E4%BC%9A%E5%A0%86%E7%A7%AF%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%B8%85%E7%90%86%E8%BF%87%E6%9C%9F%E6%B6%88%E6%81%AF%EF%BC%9F"><span class="toc-text">追问：那么消息会堆积吗？什么时候清理过期消息？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81-RocketMQ%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-text">6、 RocketMQ消费模式有几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E6%98%AFpush%E8%BF%98%E6%98%AFpull%EF%BC%9F"><span class="toc-text">7、 消费消息是push还是pull？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%BB%E5%8A%A8%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">追问：为什么要主动拉取消息而不使用事件监听方式？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81-broker%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%8B%89%E5%8F%96%E8%AF%B7%E6%B1%82%E7%9A%84%EF%BC%9F"><span class="toc-text">8、 broker如何处理拉取请求的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81-RocketMQ%E5%A6%82%E4%BD%95%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9F"><span class="toc-text">9、 RocketMQ如何做负载均衡？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#producer%E7%AB%AF"><span class="toc-text">producer端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#consumer%E7%AB%AF"><span class="toc-text">consumer端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%EF%BC%9A%E5%BD%93%E6%B6%88%E8%B4%B9%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1consumer%E5%92%8Cqueue%E4%B8%8D%E5%AF%B9%E7%AD%89%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">追问：当消费负载均衡consumer和queue不对等的时候会发生什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81-%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-text">10、 消息重复消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81-%E5%A6%82%E4%BD%95%E8%AE%A9RocketMQ%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="toc-text">11、 如何让RocketMQ保证消息的顺序消费</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%EF%BC%9A%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E5%8F%91%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AAqueue%EF%BC%9F"><span class="toc-text">追问：怎么保证消息发到同一个queue？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81-RocketMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-text">12、 RocketMQ如何保证消息不丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Producer%E7%AB%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-text">Producer端如何保证消息不丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Broker%E7%AB%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-text">Broker端如何保证消息不丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Consumer%E7%AB%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-text">Consumer端如何保证消息不丢失</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81-rocketMQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-text">13、 rocketMQ的消息堆积如何处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%EF%BC%9A%E5%A6%82%E6%9E%9CConsumer%E5%92%8CQueue%E4%B8%8D%E5%AF%B9%E7%AD%89%EF%BC%8C%E4%B8%8A%E7%BA%BF%E4%BA%86%E5%A4%9A%E5%8F%B0%E4%B9%9F%E5%9C%A8%E7%9F%AD%E6%97%B6%E9%97%B4%E5%86%85%E6%97%A0%E6%B3%95%E6%B6%88%E8%B4%B9%E5%AE%8C%E5%A0%86%E7%A7%AF%E7%9A%84%E6%B6%88%E6%81%AF%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">追问：如果Consumer和Queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%EF%BC%9A%E5%A0%86%E7%A7%AF%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E6%B6%88%E6%81%AF%E8%B6%85%E6%97%B6%E4%BA%86%EF%BC%9F"><span class="toc-text">追问：堆积时间过长消息超时了？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%EF%BC%9A%E5%A0%86%E7%A7%AF%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%BF%9B%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-text">追问：堆积的消息会不会进死信队列？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81-RocketMQ%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E8%BF%99%E5%9D%97%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">14、 RocketMQ在分布式事务支持这块机制的底层原理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81-%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E6%9D%A5%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0"><span class="toc-text">15、 如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81-%E7%9C%8B%E8%BF%87RocketMQ-%E7%9A%84%E6%BA%90%E7%A0%81%E6%B2%A1%E6%9C%89%E3%80%82%E5%A6%82%E6%9E%9C%E7%9C%8B%E8%BF%87%EF%BC%8C%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9RocketMQ-%E6%BA%90%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">16、 看过RocketMQ 的源码没有。如果看过，说说你对RocketMQ 源码的理解?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81-%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-text">17、 高吞吐量下如何优化生产者和消费者的性能?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91"><span class="toc-text">开发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4"><span class="toc-text">运维</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81-%E5%86%8D%E8%AF%B4%E8%AF%B4RocketMQ-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E9%AB%98%E5%AE%B9%E9%94%99%E6%80%A7%E7%9A%84"><span class="toc-text">18、 再说说RocketMQ 是如何保证数据的高容错性的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81-%E4%BB%BB%E4%BD%95%E4%B8%80%E5%8F%B0Broker%E7%AA%81%E7%84%B6%E5%AE%95%E6%9C%BA%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">19、 任何一台Broker突然宕机了怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81-Broker%E6%8A%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BF%A1%E6%81%AF%E6%B3%A8%E5%86%8C%E5%88%B0%E5%93%AA%E4%B8%AANameServer%E4%B8%8A%EF%BC%9F"><span class="toc-text">20、 Broker把自己的信息注册到哪个NameServer上？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81-%E4%BD%A0%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8mq%EF%BC%9F%E5%85%B7%E4%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">21、 你们为什么使用mq？具体的使用场景是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81-%E9%82%A3%E4%BD%A0%E4%BB%AC%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88mq%EF%BC%9F%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%81%9A%E7%9A%84%E9%80%89%E5%9E%8B%EF%BC%9F"><span class="toc-text">22、 那你们使用什么mq？基于什么做的选型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81-%E4%BD%A0%E4%B8%8A%E9%9D%A2%E6%8F%90%E5%88%B0%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%EF%BC%8C%E9%82%A3%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%EF%BC%9F"><span class="toc-text">23、 你上面提到异步发送，那消息可靠性怎么保证？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%A2%E5%A4%B1"><span class="toc-text">生产者丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MQ%E4%B8%A2%E5%A4%B1"><span class="toc-text">MQ丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%A2%E5%A4%B1"><span class="toc-text">消费者丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81-%E4%BD%A0%E8%AF%B4%E5%88%B0%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E9%82%A3%E4%B9%88%E5%A6%82%E6%9E%9C%E4%B8%80%E7%9B%B4%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E5%AF%BC%E8%87%B4%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">24、 你说到消费者消费失败的问题，那么如果一直消费失败导致消息积压怎么处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81-%E9%82%A3%E5%A6%82%E6%9E%9C%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B%E8%BE%BE%E5%88%B0%E7%A3%81%E7%9B%98%E4%B8%8A%E9%99%90%EF%BC%8C%E6%B6%88%E6%81%AF%E8%A2%AB%E5%88%A0%E9%99%A4%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">25、 那如果消息积压达到磁盘上限，消息被删除了怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81-%E8%AF%B4%E4%BA%86%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%8C%E9%82%A3%E4%BD%A0%E8%AF%B4%E8%AF%B4RocketMQ%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%90%A7%EF%BC%9F"><span class="toc-text">26、 说了这么多，那你说说RocketMQ实现原理吧？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81-%E4%B8%BA%E4%BB%80%E4%B9%88RocketMQ%E4%B8%8D%E4%BD%BF%E7%94%A8Zookeeper%E4%BD%9C%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%91%A2%EF%BC%9F"><span class="toc-text">27、 为什么RocketMQ不使用Zookeeper作为注册中心呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81-%E9%82%A3Broker%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">28、 那Broker是怎么保存数据的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81-Master%E5%92%8CSlave%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">29、 Master和Slave之间是怎么同步数据的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81-%E4%BD%A0%E7%9F%A5%E9%81%93RocketMQ%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%9F%E5%BA%A6%E5%BF%AB%E5%90%97%EF%BC%9F"><span class="toc-text">30、 你知道RocketMQ为什么速度快吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%E3%80%81%E5%8D%8A%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">31、 什么是事务、半事务消息？怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E3%80%81-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8RocketMq%EF%BC%9F"><span class="toc-text">32、 为什么要用RocketMq？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E3%80%81-RocketMq%E7%9A%84%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">33、 RocketMq的部署架构了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E3%80%81-%E5%AE%83%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%83%A8%E7%BD%B2%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">34、 它有哪几种部署类型？分别有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E3%80%81-%E4%BD%A0%E8%87%AA%E5%B7%B1%E9%83%A8%E7%BD%B2%E8%BF%87RocketMq%E5%90%97%EF%BC%9F%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%BD%93%E6%97%B6%E9%83%A8%E7%BD%B2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">35、 你自己部署过RocketMq吗？简单说一下你当时部署的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E3%80%81-rocketmq%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%EF%BC%9F"><span class="toc-text">36、 rocketmq如何保证高可用性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37%E3%80%81-rocketmq%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">37、 rocketmq的工作流程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38%E3%80%81-RocketMq%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%EF%BC%8Cpull%E8%BF%98%E6%98%AFpush%EF%BC%9F"><span class="toc-text">38、 RocketMq使用哪种方式消费消息，pull还是push？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E3%80%81-RocketMq%E5%A6%82%E4%BD%95%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9F"><span class="toc-text">39、 RocketMq如何负载均衡？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40%E3%80%81-RocketMq%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">40、 RocketMq的存储机制了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E3%80%81-RocketMq%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">41、 RocketMq的存储结构是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E3%80%81-RocketMq%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%B6%88%E6%81%AF%E7%9A%84%E5%8E%BB%E9%87%8D%EF%BC%9F"><span class="toc-text">42、 RocketMq如何进行消息的去重？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E3%80%81-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8MQ%EF%BC%9F%E4%BC%98%E7%82%B9%EF%BC%9F%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">43、 为什么使用MQ？优点？常用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44%E3%80%81-%E4%BD%BF%E7%94%A8MQ%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">44、 使用MQ有什么缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45%E3%80%81-Kafka%E3%80%81ActiveMQ%E3%80%81RabbitMQ%E3%80%81RocketMQ-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">45、 Kafka、ActiveMQ、RabbitMQ、RocketMQ 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46%E3%80%81-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B"><span class="toc-text">46、 消息队列如何选型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47%E3%80%81-MQ-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">47、 MQ 有哪些常见问题？如何解决这些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48%E3%80%81-%E4%BE%9D%E6%89%98%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%EF%BC%9F"><span class="toc-text">48、 依托消息中间件如何实现异步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49%E3%80%81-RocketMQ%E6%B6%88%E6%81%AF%E6%98%AFpush%E8%BF%98%E6%98%AFpull%EF%BC%9F"><span class="toc-text">49、 RocketMQ消息是push还是pull？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50%E3%80%81-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%BB%E5%8A%A8%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">50、 为什么要主动拉取消息而不使用事件监听方式？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148432/" title="MyBatis 拦截器">MyBatis 拦截器</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148434/" title="MyBatis 集成druid数据源">MyBatis 集成druid数据源</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1166366203/" title="SQL调优">SQL调优</a><time datetime="2024-07-16T16:00:00.000Z" title="发表于 2024-07-17 00:00:00">2024-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3109398172/" title="ContextHolder">ContextHolder</a><time datetime="2024-07-11T16:00:00.000Z" title="发表于 2024-07-12 00:00:00">2024-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2889834893/" title="SpringCloud Feign">SpringCloud Feign</a><time datetime="2024-07-01T16:00:00.000Z" title="发表于 2024-07-02 00:00:00">2024-07-02</time></div></div></div></div></div></div></main><footer id="footer" style="background: #47577e"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '2N3fEF3CzNAzKwVbFlhSTUuM-gzGzoHsz',
      appKey: '9m41Klhi8IgsrNrbyMnoCHrN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>