<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaScript | Eric</title><meta name="author" content="Eric"><meta name="copyright" content="Eric"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="视频地址：  JavaScript1.初识 JavaScript1.1 JavaScript 是什么 JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思）。 脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行。"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://ericwjian.github.io/posts/3424359953/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4dfa2c883c8c4c23f4866185de932236";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-16 10:35:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Eric"><span class="site-name">Eric</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JavaScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2017-11-17T16:00:00.000Z" title="发表于 2017-11-18 00:00:00">2017-11-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-16T02:35:22.830Z" title="更新于 2024-08-16 10:35:22">2024-08-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Sy4y1C7ha">视频地址：</a></p>
<hr>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-初识-JavaScript"><a href="#1-初识-JavaScript" class="headerlink" title="1.初识 JavaScript"></a>1.初识 JavaScript</h2><h3 id="1-1-JavaScript-是什么"><a href="#1-1-JavaScript-是什么" class="headerlink" title="1.1 JavaScript 是什么"></a>1.1 JavaScript 是什么</h3><ul>
<li>JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思）。</li>
<li>脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行。</li>
</ul>
<h3 id="1-2-JavaScript-的作用"><a href="#1-2-JavaScript-的作用" class="headerlink" title="1.2 JavaScript 的作用"></a>1.2 JavaScript 的作用</h3><ul>
<li>表单动态校验（密码强度检测）  （ JS 产生最初的目的 ）。</li>
<li>网页特效。</li>
<li>服务端开发(Node.js)。</li>
<li>桌面程序(Electron)。</li>
<li>App(Cordova) </li>
<li>控制硬件-物联网(Ruff)</li>
<li>游戏开发(cocos2d-js)</li>
</ul>
<h3 id="1-3-HTML-CSS-JS-的关系"><a href="#1-3-HTML-CSS-JS-的关系" class="headerlink" title="1.3 HTML/CSS/JS 的关系"></a>1.3 HTML/CSS/JS 的关系</h3><p><code>HTML/CSS 标记语言--描述类语言</code></p>
<ul>
<li>HTML 决定网页结构和内容( 决定看到什么 )，相当于人的身体。 </li>
<li>CSS 决定网页呈现给用户的模样( 决定好不好看 )， 相当于给人穿衣服、化妆。</li>
</ul>
<p><code>JS 脚本语言--编程类语言</code></p>
<ul>
<li>实现业务逻辑和页面控制( 决定功能 )，相当于人的各种动作 。</li>
</ul>
<h3 id="1-4-浏览器执行-JS-简介"><a href="#1-4-浏览器执行-JS-简介" class="headerlink" title="1.4 浏览器执行 JS 简介"></a>1.4 浏览器执行 JS 简介</h3><p>浏览器分成两部分：<code>渲染引擎</code>和 <code>JS 引擎</code>.</p>
<ul>
<li>渲染引擎：用来解析 HTML 与 CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit.</li>
<li>JS 引擎：也称为 JS 解释器。 用来读取网页中的JavaScript代码，对其处理后运行，比如 chrome  浏览器的 V8.</li>
</ul>
<p>浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言）,然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行 。</p>
<h3 id="1-5-JS-的组成"><a href="#1-5-JS-的组成" class="headerlink" title="1.5 JS 的组成"></a>1.5 JS 的组成</h3><img src="/posts/3424359953/1604374456275.png" class="" width="1604374456275">

<h3 id="1-6-JS-初体验"><a href="#1-6-JS-初体验" class="headerlink" title="1.6 JS 初体验"></a>1.6 JS 初体验</h3><p>JS 有3种书写位置，分别为<code>行内</code>、<code>内嵌</code>和<code>外部</code>。 </p>
<h4 id="1-行内式-JS"><a href="#1-行内式-JS" class="headerlink" title="1.行内式 JS"></a>1.行内式 JS</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我试试&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Hello World&#x27;)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：</p>
<ul>
<li>可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick</li>
<li>注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用<strong>单引号</strong>.</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li><p>可读性差， 在html中编写JS大量代码时，不方便阅读.</p>
</li>
<li><p>引号易错，引号多层嵌套匹配时，非常容易弄混.</p>
</li>
<li><p>使用场景很少，在特殊情况下使用。</p>
</li>
</ul>
<h4 id="2-内嵌-JS"><a href="#2-内嵌-JS" class="headerlink" title="2.内嵌 JS"></a>2.内嵌 JS</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">	<span class="title function_">alert</span>(<span class="string">&#x27;Hello  World~!&#x27;</span>); </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以将多行JS代码写到 &lt;script&gt;  标签中</p>
</li>
<li><p>内嵌 JS 是学习时常用的方式.</p>
</li>
</ul>
<h4 id="3-外部-JS文件"><a href="#3-外部-JS文件" class="headerlink" title="3. 外部 JS文件"></a>3. 外部 JS文件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;my.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用.</li>
<li>引用外部 JS文件的 script 标签中间不可以写代码</li>
<li>适合于JS 代码量比较大的情况</li>
</ul>
<h2 id="2-JavaScript注释"><a href="#2-JavaScript注释" class="headerlink" title="2.JavaScript注释"></a>2.JavaScript注释</h2><h3 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="1. 单行注释"></a>1. 单行注释</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  用来注释单行文字（  快捷键   ctrl  +  /   ）</span></span><br></pre></td></tr></table></figure>

<h3 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="2. 多行注释"></a>2. 多行注释</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* */</span>  用来注释多行文字（ 默认快捷键  alt +  shift  + a ） </span><br><span class="line"><span class="comment">// 快捷键修改为：   ctrl + shift  +  / </span></span><br></pre></td></tr></table></figure>

<h2 id="3-JavaScript-输入输出语句"><a href="#3-JavaScript-输入输出语句" class="headerlink" title="3.JavaScript 输入输出语句"></a>3.JavaScript 输入输出语句</h2><p>为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>归属</th>
</tr>
</thead>
<tbody><tr>
<td><code>alert(msg)</code></td>
<td>浏览器弹出警示框</td>
<td>浏览器</td>
</tr>
<tr>
<td><code>console.log(msg)</code></td>
<td>浏览器控制台打印输出信息</td>
<td>浏览器</td>
</tr>
<tr>
<td><code>prompt(info)</code></td>
<td>浏览器弹出输入框，用户可以输入</td>
<td>浏览器</td>
</tr>
</tbody></table>
<p><code>注意：</code>alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。</p>
<p><code>console.dir()</code>: 输出对象的详细信息，直接展开</p>
<h2 id="4-变量概述"><a href="#4-变量概述" class="headerlink" title="4.变量概述"></a>4.变量概述</h2><h3 id="1-本质"><a href="#1-本质" class="headerlink" title="1.本质"></a>1.本质</h3><p>变量是程序在内存中申请的一块用来存放数据的空间。</p>
<h3 id="2-变量的使用"><a href="#2-变量的使用" class="headerlink" title="2. 变量的使用"></a>2. 变量的使用</h3><p>变量在使用时分为两步： 1. 声明变量   2. 赋值 </p>
<h4 id="1-声明变量"><a href="#1-声明变量" class="headerlink" title="1. 声明变量"></a>1. 声明变量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  声明变量  </span></span><br><span class="line"><span class="keyword">var</span> age; <span class="comment">//  声明一个 名称为age 的变量     </span></span><br></pre></td></tr></table></figure>

<ul>
<li>var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配 内存空间，不需要程序员管。</li>
<li>age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间。</li>
</ul>
<h4 id="2-赋值"><a href="#2-赋值" class="headerlink" title="2. 赋值"></a>2. 赋值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">10</span>; <span class="comment">// 给 age  这个变量赋值为 10     </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>= 用来把右边的值赋给左边的变量空间中   此处代表赋值的意思。</p>
</li>
<li><p>变量值是程序员保存到变量空间里的值。</p>
</li>
</ul>
<h4 id="3-变量的初始化"><a href="#3-变量的初始化" class="headerlink" title="3. 变量的初始化"></a>3. 变量的初始化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age  = <span class="number">18</span>;  <span class="comment">// 声明变量同时赋值为 18          </span></span><br></pre></td></tr></table></figure>

<p>声明一个变量并赋值， 我们称之为变量的初始化。</p>
<h3 id="3-变量语法扩展"><a href="#3-变量语法扩展" class="headerlink" title="3.变量语法扩展"></a>3.变量语法扩展</h3><h4 id="1-更新变量"><a href="#1-更新变量" class="headerlink" title="1.更新变量"></a>1.更新变量</h4><p>一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>; </span><br><span class="line">age = <span class="number">81</span>;   <span class="comment">// 最后的结果就是81因为18 被覆盖掉了       </span></span><br></pre></td></tr></table></figure>

<h4 id="2-同时声明多个变量"><a href="#2-同时声明多个变量" class="headerlink" title="2.同时声明多个变量"></a>2.同时声明多个变量</h4><p>同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>,  name = <span class="string">&#x27;zs&#x27;</span>, sex = <span class="number">2</span>;     </span><br></pre></td></tr></table></figure>

<h4 id="3-声明变量特殊情况"><a href="#3-声明变量特殊情况" class="headerlink" title="3.声明变量特殊情况"></a>3.声明变量特殊情况</h4><table>
<thead>
<tr>
<th>情况</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>var age;console.log (age);</code></td>
<td>只声明不赋值</td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>console.log(age)</code></td>
<td>不声明不赋值直接使用</td>
<td>报错</td>
</tr>
<tr>
<td><code>age=10;console.log (age);</code></td>
<td>不声明只赋值</td>
<td><code>10</code></td>
</tr>
</tbody></table>
<p><code>undefined</code> : 未定义的.</p>
<h2 id="5-数据类型"><a href="#5-数据类型" class="headerlink" title="5.数据类型"></a>5.数据类型</h2><h3 id="1-变量的数据类型"><a href="#1-变量的数据类型" class="headerlink" title="1. 变量的数据类型"></a>1. 变量的数据类型</h3><p>变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;        <span class="comment">// 这是一个数字型 </span></span><br><span class="line"><span class="keyword">var</span> areYouOk = <span class="string">&#x27;是的&#x27;</span>;   <span class="comment">// 这是一个字符串     </span></span><br></pre></td></tr></table></figure>

<img src="/posts/3424359953/image-20220512143157439.png" class="" title="image-20220512143157439">

<p>在代码运行时，变量的数据类型是由 JS引擎 <code>根据 = 右边变量值的数据类型来判断</code> 的，运行完毕之后， 变量就确定了数据类型。<br>JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型：</p>
<h3 id="2-数据类型的分类"><a href="#2-数据类型的分类" class="headerlink" title="2. 数据类型的分类"></a>2. 数据类型的分类</h3><p>JS 把数据类型分为两类： </p>
<ul>
<li>简单数据类型 （Number,String,Boolean,Undefined,Null） </li>
<li>复杂数据类型 （object)</li>
</ul>
<h4 id="2-1-简单数据类型（基本数据类型）"><a href="#2-1-简单数据类型（基本数据类型）" class="headerlink" title="2.1 简单数据类型（基本数据类型）"></a>2.1 简单数据类型（基本数据类型）</h4><table>
<thead>
<tr>
<th>简单数据类型</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number</code></td>
<td>数字型，包含整型值和浮点型值，如 21、0.21</td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td>布尔值类型，如 <code>true</code>、<code>false</code>, 等价于 1 和 0</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>String</code></td>
<td>字符串类型，如 “张三” 注意咱们 js 里面，字符串都带引号</td>
<td><code>&quot;&quot;</code></td>
</tr>
<tr>
<td><code>Undefined</code></td>
<td><code>vara;</code>声明了变量<code>a</code>但是没有给值，此时<code>a=undefined</code></td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>Null</code></td>
<td><code>vara=null;</code>声明了变量<code>a</code>为空值</td>
<td><code>null</code></td>
</tr>
</tbody></table>
<h4 id="2-2-数字型-Number"><a href="#2-2-数字型-Number" class="headerlink" title="2.2 数字型 Number"></a>2.2 数字型 Number</h4><p>JavaScript 数字类型既可以用来保存整数值，也可以保存小数(浮点数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">21</span>;       <span class="comment">// 整数 </span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Age</span> = <span class="number">21.3747</span>;  <span class="comment">// 小数     </span></span><br></pre></td></tr></table></figure>

<p><strong>1.数字型进制</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.八进制数字序列范围：0~7 var </span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">07</span>;   <span class="comment">// 对应十进制的7 </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">019</span>;  <span class="comment">// 对应十进制的19 </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="number">08</span>;   <span class="comment">// 对应十进制的8  </span></span><br><span class="line"><span class="comment">// 2.十六进制数字序列范围：0~9以及A~F </span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0xA</span>; </span><br></pre></td></tr></table></figure>

<p>现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加 0x  </p>
<p><strong>2.数字型范围</strong><br>JavaScript中数值的最大和最小值</p>
<ul>
<li>最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308</li>
<li>最小值：Number.MIN_VALUE，这个值为：5e-32</li>
</ul>
<p><strong>3.数字型三个特殊值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="title class_">Infinity</span>);  <span class="comment">// Infinity </span></span><br><span class="line"><span class="title function_">alert</span>(-<span class="title class_">Infinity</span>); <span class="comment">// -Infinity </span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">NaN</span>);       <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Infinity ，代表无穷大，大于任何数值-</li>
<li>-Infinity ，代表无穷小，小于任何数值</li>
<li>NaN ，Not a number，代表一个非数值</li>
</ul>
<p><strong>4.isNaN()</strong> </p>
<p>用来判断一个变量是否为非数字的类型，返回 true 或者 false</p>
<h4 id="2-3-字符串型-String"><a href="#2-3-字符串型-String" class="headerlink" title="2.3 字符串型 String"></a>2.3 字符串型 String</h4><p>字符串型可以是引号中的任意文本，其语法为 双引号 <code>&quot;&quot;</code> 和 单引号<code>&#39;&#39;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strMsg = <span class="string">&quot;我爱北京天安门~&quot;</span>;  <span class="comment">// 使用双引号表示字符串 </span></span><br><span class="line"><span class="keyword">var</span> strMsg2 = <span class="string">&#x27;我爱吃猪蹄~&#x27;</span>;    <span class="comment">// 使用单引号表示字符串 </span></span><br><span class="line"><span class="comment">// 常见错误 </span></span><br><span class="line"><span class="keyword">var</span> strMsg3 = 我爱大肘子;       <span class="comment">// 报错，没使用引号，会被认为是js代码，但js没有这些语法</span></span><br></pre></td></tr></table></figure>

<p>因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用<strong>单引号</strong>。</p>
<p><strong>1.字符串引号嵌套</strong></p>
<p>JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双)</p>
<p><strong>2.字符串转义符</strong></p>
<p>转义符都是 \ 开头的，常用的转义符及其说明如下：</p>
<img src="/posts/3424359953/1604384080499.png" class="" width="1604384080499">

<table>
<thead>
<tr>
<th>转义符</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\n</code></td>
<td>换行符，<code>n</code>是<code>newline</code>的意思</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>斜杠<code>\</code></td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>‘ 单引号</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>“ 双引号</td>
</tr>
<tr>
<td><code>\t</code></td>
<td><code>tab</code>缩进</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>空格，<code>b</code>是<code>blank</code>的意思</td>
</tr>
</tbody></table>
<p><strong>3.字符串长度</strong></p>
<p>字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 <strong>length</strong> 属性可以获取整个字符 串的长度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strMsg = <span class="string">&quot;我是帅气多金的程序猿！&quot;</span>; </span><br><span class="line"><span class="title function_">alert</span>(strMsg.<span class="property">length</span>); <span class="comment">// 显示 11</span></span><br></pre></td></tr></table></figure>

<p><strong>4.字符串拼接</strong></p>
<ul>
<li>多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串</li>
<li>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串</li>
</ul>
<p><code>号总结口诀：数值相加 ，字符相连</code></p>
<p><strong>5.字符串拼接加强</strong></p>
<p>使用模板字符串可以很好的解决字符串拼接时出现的 加号错乱的问题。</p>
<h4 id="2-4-布尔型-Boolean"><a href="#2-4-布尔型-Boolean" class="headerlink" title="2.4  布尔型 Boolean"></a>2.4  布尔型 Boolean</h4><p>布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。</p>
<h4 id="2-5-Undefined-和-Null"><a href="#2-5-Undefined-和-Null" class="headerlink" title="2.5  Undefined 和 Null"></a>2.5  Undefined 和 Null</h4><p>一个声明后没有被赋值的变量会有一个默认值 undefined ( 如果进行相连或者相加时，注意结果）</p>
<p>一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null)</p>
<h3 id="3-获取变量数据类型"><a href="#3-获取变量数据类型" class="headerlink" title="3.获取变量数据类型"></a>3.获取变量数据类型</h3><h4 id="3-1-获取检测变量的数据类型"><a href="#3-1-获取检测变量的数据类型" class="headerlink" title="3.1  获取检测变量的数据类型"></a>3.1  获取检测变量的数据类型</h4><p>typeof 可用来获取检测变量的数据类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">18</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num) <span class="comment">// 结果 number     </span></span><br></pre></td></tr></table></figure>

<h2 id="6-数据类型转换"><a href="#6-数据类型转换" class="headerlink" title="6.数据类型转换"></a>6.数据类型转换</h2><h3 id="1-转换为字符串"><a href="#1-转换为字符串" class="headerlink" title="1.转换为字符串"></a>1.转换为字符串</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td><code>toString()</code></td>
<td>转成字符串</td>
<td><code>var num = 1; alert(num.toString());</code></td>
</tr>
<tr>
<td><code>String(强制转换)</code></td>
<td>转成字符串</td>
<td><code>var num = 1; alert(String(num));</code></td>
</tr>
<tr>
<td><code>加号拼接字符串</code></td>
<td>和字符串拼接的结果都是字符串</td>
<td><code>var num = 1; alert(num + &quot;我是字符串&quot;);</code></td>
</tr>
</tbody></table>
<ul>
<li>toString() 和 String()  使用方式不一样。</li>
<li>三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式， 这一种方式也称之为隐式转换。</li>
</ul>
<h3 id="2-转换为数字型（重点）"><a href="#2-转换为数字型（重点）" class="headerlink" title="2.转换为数字型（重点）"></a>2.转换为数字型（重点）</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td><code>parseInt(string)函数</code></td>
<td>将<code>string</code>类型转成整数数值型</td>
<td><code>parseInt(&#39;78&#39;)</code></td>
</tr>
<tr>
<td><code>parseFloat(string)函数</code></td>
<td>将<code>string</code>类型转成浮点数数值型</td>
<td><code>parseFloat(&#39;78.21&#39;)</code></td>
</tr>
<tr>
<td><code>Number()强制转换函数</code></td>
<td>将<code>string</code>类型转换为数值型</td>
<td><code>Number(&#39;12&#39;)</code></td>
</tr>
<tr>
<td><code>js 隐式转换(- * /)</code></td>
<td>利用算术运算隐式转换为数值型</td>
<td><code>&#39;12&#39; - 0</code></td>
</tr>
</tbody></table>
<ul>
<li>注意 parseInt 和 parseFloat 单词的大小写，这2个是重点</li>
<li>隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型</li>
</ul>
<h3 id="3-转换为布尔型"><a href="#3-转换为布尔型" class="headerlink" title="3.转换为布尔型"></a>3.转换为布尔型</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td><code>Boolean()函数</code></td>
<td>其他类型转成布尔值</td>
<td><code>Boolean(&#39;true&#39;);</code></td>
</tr>
</tbody></table>
<ul>
<li>代表空、否定的值会被转换为 false  ，如  ‘’、0、NaN、null、undefined  </li>
<li>其余值都会被转换为 true</li>
</ul>
<h2 id="7-运算符"><a href="#7-运算符" class="headerlink" title="7.运算符"></a>7.运算符</h2><h3 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1.算数运算符"></a>1.算数运算符</h3><h4 id="1-1-算术运算符概述"><a href="#1-1-算术运算符概述" class="headerlink" title="1.1 算术运算符概述"></a>1.1 算术运算符概述</h4><p>概念：算术运算使用的符号，用于执行两个变量或值的算术运算。 </p>
<h4 id="1-2-浮点数的精度问题"><a href="#1-2-浮点数的精度问题" class="headerlink" title="1.2 浮点数的精度问题"></a>1.2 浮点数的精度问题</h4><p>浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">0.1</span> + <span class="number">0.2</span>;    </span><br><span class="line"><span class="comment">// 结果不是 0.3，而是：0.30000000000000004 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.07</span> * <span class="number">100</span>);  </span><br><span class="line"><span class="comment">// 结果不 是 7， 而是：7.000000000000001</span></span><br></pre></td></tr></table></figure>

<p>所以：<strong>不要直接判断两个浮点数是否相等!</strong>  </p>
<h3 id="2-递增和递减运算符"><a href="#2-递增和递减运算符" class="headerlink" title="2. 递增和递减运算符"></a>2. 递增和递减运算符</h3><h4 id="2-1-递增和递减运算符概述"><a href="#2-1-递增和递减运算符概述" class="headerlink" title="2.1 递增和递减运算符概述"></a>2.1 递增和递减运算符概述</h4><p>如果需要反复给数字变量添加或减去1，可以使用<strong>递增（++）</strong>和<strong>递减（– ）</strong>运算符来完成。<br>在 JavaScript 中，递增（++）和递减（– ）既可以放在变量前面，也可以放在变量后面。放在变量前面时， 我们可以称为<strong>前置递增（递减）运算符</strong>，放在变量后面时，我们可以称为<strong>后置递增（递减）运算符</strong>。<br><code>注意：递增和递减运算符必须和变量配合使用。</code></p>
<h4 id="2-2-前置递增运算符"><a href="#2-2-前置递增运算符" class="headerlink" title="2.2 前置递增运算符"></a>2.2 前置递增运算符</h4><p>++num 前置递增，就是自加1，类似于num =  num + 1，但是 ++num 写起来更简单。<br>使用口诀：<code>先自加，后返回值</code></p>
<h4 id="2-3-后置递增运算符"><a href="#2-3-后置递增运算符" class="headerlink" title="2.3 后置递增运算符"></a>2.3 后置递增运算符</h4><p>num++ 后置递增，就是自加1，类似于num =  num + 1 ，但是 num++ 写起来更简单。<br>使用口诀：<code>先返回原值，后自加</code></p>
<h4 id="2-4-前置递增和后置递增小结"><a href="#2-4-前置递增和后置递增小结" class="headerlink" title="2.4 前置递增和后置递增小结"></a>2.4 前置递增和后置递增小结</h4><ul>
<li>前置递增和后置递增运算符可以简化代码的编写，让变量的值+ 1 比以前写法更简单</li>
<li>单独使用时，运行结果相同</li>
<li>与其他代码联用时，执行结果会不同</li>
<li>后置：先原值运算，后自加（先人后己）</li>
<li>前置：先自加，后运算（先已后人）</li>
<li>开发时，大多使用后置递增/减，并且代码独占一行，例如：num++; 或者 num–;</li>
</ul>
<h3 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="3.比较运算符"></a>3.比较运算符</h3><h4 id="3-1-比较运算符概述"><a href="#3-1-比较运算符概述" class="headerlink" title="3.1 比较运算符概述"></a>3.1 比较运算符概述</h4><p>概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值 （true / false）作为比较运算的结果。</p>
<h4 id="3-2-小结"><a href="#3-2-小结" class="headerlink" title="3.2 =小结"></a>3.2 =小结</h4><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>赋值</td>
<td>把右边给左边</td>
</tr>
<tr>
<td><code>==</code></td>
<td>判断</td>
<td>判断两边值是否相等 (注意此时有隐式转换)</td>
</tr>
<tr>
<td><code>===</code></td>
<td>全等</td>
<td>判断两边的值和数据类型是否完全相同</td>
</tr>
</tbody></table>
<h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4.逻辑运算符"></a>4.逻辑运算符</h3><h4 id="1-逻辑运算符概述"><a href="#1-逻辑运算符概述" class="headerlink" title="1 逻辑运算符概述"></a>1 逻辑运算符概述</h4><p>概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断</p>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>“逻辑与”，简称 “与”  and</td>
<td><code>true &amp;&amp; false</code></td>
</tr>
<tr>
<td>`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td><code>!</code></td>
<td>“逻辑非”，简称 “非”  not</td>
<td><code>!true</code></td>
</tr>
</tbody></table>
<h4 id="2-逻辑与-amp-amp"><a href="#2-逻辑与-amp-amp" class="headerlink" title="2 逻辑与&amp;&amp;"></a>2 逻辑与&amp;&amp;</h4><p>两边都是 true才返回true，否则返回 false</p>
<h4 id="3-逻辑或"><a href="#3-逻辑或" class="headerlink" title="3 逻辑或 ||"></a>3 逻辑或 ||</h4><p>两边都为 false 才返回 false，否则都为true</p>
<h4 id="4-逻辑非-！"><a href="#4-逻辑非-！" class="headerlink" title="4 逻辑非 ！"></a>4 逻辑非 ！</h4><p>逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如true 的相反值是 false</p>
<h4 id="5-短路运算（逻辑中断）"><a href="#5-短路运算（逻辑中断）" class="headerlink" title="5 短路运算（逻辑中断）"></a>5 短路运算（逻辑中断）</h4><p>短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值;</p>
<p>逻辑与</p>
<ul>
<li>语法： 表达式1 &amp;&amp; 表达式2</li>
<li>如果第一个表达式的值为真，则返回表达式2</li>
<li>如果第一个表达式的值为假，则返回表达式1</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">123</span> &amp;&amp; <span class="number">456</span> );  <span class="comment">// 456</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">0</span> &amp;&amp; <span class="number">456</span> ); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">123</span> &amp;&amp; <span class="number">456</span>&amp;&amp; <span class="number">789</span> );  <span class="comment">// 789</span></span><br></pre></td></tr></table></figure>

<h4 id="6-逻辑中断（短路操作）"><a href="#6-逻辑中断（短路操作）" class="headerlink" title="6 逻辑中断（短路操作）"></a>6 逻辑中断（短路操作）</h4><p>逻辑或 </p>
<ul>
<li>语法： 表达式1 || 表达式2</li>
<li>如果第一个表达式的值为真，则返回表达式1</li>
<li>如果第一个表达式的值为假，则返回表达式2</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">123</span> || <span class="number">456</span> );  <span class="comment">//  123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">0</span> ||  <span class="number">456</span> ); <span class="comment">//  456</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">123</span> || <span class="number">456</span> || <span class="number">789</span> );  <span class="comment">//  123</span></span><br></pre></td></tr></table></figure>

<h3 id="5-赋值运算符"><a href="#5-赋值运算符" class="headerlink" title="5.赋值运算符"></a>5.赋值运算符</h3><p>=</p>
<h3 id="6-运算符优先级"><a href="#6-运算符优先级" class="headerlink" title="6.运算符优先级"></a>6.运算符优先级</h3><img src="/posts/3424359953/1604389084588.png" class="" width="1604389084588">

<h2 id="8-流程控制-分支"><a href="#8-流程控制-分支" class="headerlink" title="8.流程控制-分支"></a>8.流程控制-分支</h2><h3 id="1-流程控制"><a href="#1-流程控制" class="headerlink" title="1. 流程控制"></a>1. 流程控制</h3><p>流程控制主要有三种结构，分别是顺序结构、分支结构和循环结构，这三种结构代表三种代码执行的顺序。</p>
<h3 id="2-顺序流程控制"><a href="#2-顺序流程控制" class="headerlink" title="2. 顺序流程控制"></a>2. 顺序流程控制</h3><p>顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行， 程序中大多数的代码都是这样执行的。</p>
<h3 id="3-分支流程控制-if-语句"><a href="#3-分支流程控制-if-语句" class="headerlink" title="3. 分支流程控制 if 语句"></a>3. 分支流程控制 if 语句</h3><p>由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果</p>
<h3 id="4-三元表达式"><a href="#4-三元表达式" class="headerlink" title="4. 三元表达式"></a>4. 三元表达式</h3><p>三元表达式也能做一些简单的条件选择。有三元运算符组成的式子称为三元表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式<span class="number">1</span> ? 表达式<span class="number">2</span> : 表达式<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>执行思路 </p>
<ul>
<li>如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值 </li>
<li>简单理解： 就类似于 if  else （双分支） 的简写</li>
</ul>
<h3 id="5-分支流程控制-switch-语句"><a href="#5-分支流程控制-switch-语句" class="headerlink" title="5. 分支流程控制 switch 语句"></a>5. 分支流程控制 switch 语句</h3><h2 id="9-流程控制-循环"><a href="#9-流程控制-循环" class="headerlink" title="9.流程控制-循环"></a>9.流程控制-循环</h2><h3 id="1-循环"><a href="#1-循环" class="headerlink" title="1. 循环"></a>1. 循环</h3><p>循环目的</p>
<ul>
<li>在实际问题中，有许多具有规律性的重复操作，因此在程序中要完成这类操作就需要重复执行某些语句</li>
</ul>
<h3 id="2-for-循环"><a href="#2-for-循环" class="headerlink" title="2. for 循环"></a>2. for 循环</h3><p>在程序中，一组被重复执行的语句被称之为循环体，能否继续重复执行，取决于循环的终止条件。由循环体 及循环的终止条件组成的语句，被称之为循环语句。</p>
<h3 id="3-while-循环"><a href="#3-while-循环" class="headerlink" title="3.while 循环"></a>3.while 循环</h3><p>① 先执行条件表达式，如果结果为true，则执行循环体代码；如果为false，则退出循环，执行后面代码 </p>
<p>② 执行循环体代码 </p>
<p>③ 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循 环条件为 false 时，整个循环过程才会结束</p>
<h3 id="4-do-while-循环"><a href="#4-do-while-循环" class="headerlink" title="4. do while 循环"></a>4. do while 循环</h3><p>do… while 语句其实是while 语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如 果条件为真，就会重复执行循环体，否则退出循环。 </p>
<p>① 先执行一次循环体代码 </p>
<p>② 再执行条件表达式，如果结果为true，则继续执行循环体代码，如果为false，则退出循环，继续执行后面 代码</p>
<p>注意：先再执行循环体，再判断，我们会发现do…while 循环语句至少会执行一次循环体代码</p>
<h3 id="5-continue-break"><a href="#5-continue-break" class="headerlink" title="5.continue break"></a>5.continue break</h3><h4 id="1-continue-关键字"><a href="#1-continue-关键字" class="headerlink" title="1 continue 关键字"></a>1 continue 关键字</h4><p>continue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中continue 之后的代码就会少执行 一次）。 </p>
<h4 id="2-break-关键字"><a href="#2-break-关键字" class="headerlink" title="2 break 关键字"></a>2 break 关键字</h4><p>break 关键字用于立即跳出整个循环（循环结束）。</p>
<h2 id="10-JavaScript-数组"><a href="#10-JavaScript-数组" class="headerlink" title="10.JavaScript 数组"></a>10.JavaScript 数组</h2><h3 id="1-数组的创建方式"><a href="#1-数组的创建方式" class="headerlink" title="1 数组的创建方式"></a>1 数组的创建方式</h3><p>JS 中创建数组有两种方式：</p>
<ul>
<li>利用 new 创建数组</li>
<li>利用数组字面量创建数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 使用 new 关键字创建数组</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = <span class="keyword">new</span> <span class="title class_">Array</span>() ；</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个新的空数组</span></span><br><span class="line"><span class="comment">//2. 使用数组字面量方式创建空的数组 </span></span><br><span class="line"><span class="keyword">var</span>  数组名 = []； </span><br><span class="line"><span class="comment">//3. 使用数组字面量方式创建带初始值的数组 </span></span><br><span class="line"><span class="keyword">var</span>  数组名 = [<span class="string">&#x27;小白&#x27;</span>,<span class="string">&#x27;小黑&#x27;</span>,<span class="string">&#x27;大黄&#x27;</span>,<span class="string">&#x27;瑞奇&#x27;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="2-获取数组元素"><a href="#2-获取数组元素" class="headerlink" title="2. 获取数组元素"></a>2. 获取数组元素</h3><p>2.1 数组的索引</p>
<p>索引 (下标) ：用来访问数组元素的序号（数组下标从0 开始）。</p>
<img src="/posts/3424359953/1604390967088.png" class="" width="1604390967088">

<h3 id="3-遍历数组"><a href="#3-遍历数组" class="headerlink" title="3.遍历数组"></a>3.遍历数组</h3><p>遍历: 就是把数组中的每个元素从头到尾都访问一次（类似我们每天早上学生的点名）。<br>我们可以通过for 循环索引遍历数组中的每一项</p>
<h4 id="3-1-数组的长度"><a href="#3-1-数组的长度" class="headerlink" title="3.1 数组的长度"></a>3.1 数组的长度</h4><p>使用“<code>数组名.length</code>”可以访问数组元素的数量（数组长度）。</p>
<h3 id="4-数组中新增元素"><a href="#4-数组中新增元素" class="headerlink" title="4. 数组中新增元素"></a>4. 数组中新增元素</h3><h4 id="4-1-通过修改-length-长度新增数组元素"><a href="#4-1-通过修改-length-长度新增数组元素" class="headerlink" title="4.1 通过修改 length 长度新增数组元素"></a>4.1 通过修改 length 长度新增数组元素</h4><ul>
<li>可以通过修改length 长度来实现数组扩容的目的 </li>
<li>length 属性是可读写的</li>
</ul>
<h4 id="4-2-通过修改数组索引新增数组元素"><a href="#4-2-通过修改数组索引新增数组元素" class="headerlink" title="4.2 通过修改数组索引新增数组元素"></a>4.2 通过修改数组索引新增数组元素</h4><ul>
<li>可以通过修改数组索引的方式追加数组元素 </li>
<li>不能直接给数组名赋值，否则会覆盖掉以前的数据</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>];</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">&#x27;hotpink&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<h2 id="11-JavaScript-函数"><a href="#11-JavaScript-函数" class="headerlink" title="11.JavaScript 函数"></a>11.JavaScript 函数</h2><h3 id="1-函数的概念"><a href="#1-函数的概念" class="headerlink" title="1. 函数的概念"></a>1. 函数的概念</h3><p>函数：就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。</p>
<h3 id="2-函数的使用"><a href="#2-函数的使用" class="headerlink" title="2. 函数的使用"></a>2. 函数的使用</h3><p>函数在使用时分为两步：声明函数和调用函数。</p>
<h4 id="2-1-声明函数"><a href="#2-1-声明函数" class="headerlink" title="2.1 声明函数"></a>2.1 声明函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="keyword">function</span> 函数名() &#123;</span><br><span class="line">    <span class="comment">//函数体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>function 是声明函数的关键字,必须小写。</li>
<li>由于函数一般是为了实现某个功能才定义的，所以通常我们将函数名命名为动词，比如 getSum </li>
</ul>
<h4 id="2-2-调用函数"><a href="#2-2-调用函数" class="headerlink" title="2.2 调用函数"></a>2.2 调用函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用函数 </span></span><br><span class="line">函数名(); <span class="comment">// 通过调用函数名来执行函数体代码</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调用的时候千万不要忘记添加小括号</li>
<li>口诀：函数不调用，自己不执行</li>
</ul>
<h3 id="3-函数的参数"><a href="#3-函数的参数" class="headerlink" title="3. 函数的参数"></a>3. 函数的参数</h3><h4 id="3-1-形参和实参"><a href="#3-1-形参和实参" class="headerlink" title="3.1 形参和实参"></a>3.1 形参和实参</h4><p>在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时， 同样也需要传递相应的参数，这些参数被称为实参。</p>
<h4 id="3-2-函数参数的传递过程"><a href="#3-2-函数参数的传递过程" class="headerlink" title="3.2 函数参数的传递过程"></a>3.2 函数参数的传递过程</h4><ol>
<li>调用的时候实参值是传递给形参的</li>
<li>形参简单理解为：不用声明的变量</li>
<li>实参和形参的多个参数之间用逗号（,）分隔</li>
</ol>
<h4 id="3-3-函数形参和实参个数不匹配问题"><a href="#3-3-函数形参和实参个数不匹配问题" class="headerlink" title="3.3 函数形参和实参个数不匹配问题"></a>3.3 函数形参和实参个数不匹配问题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2);</span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">sum</span>(<span class="number">100</span>, <span class="number">200</span>); <span class="comment">// 形参和实参个数相等，输出正确结果 </span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">100</span>, <span class="number">400</span>, <span class="number">500</span>, <span class="number">700</span>); <span class="comment">// 实参个数多于形参，只取到形参的个数 </span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">200</span>); <span class="comment">// 实参个数少于形参，多的形参定义为undefined，结果为NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="4-函数的返回值"><a href="#4-函数的返回值" class="headerlink" title="4. 函数的返回值"></a>4. 函数的返回值</h3><h4 id="4-1-return-语句"><a href="#4-1-return-语句" class="headerlink" title="4.1 return 语句"></a>4.1 return 语句</h4><p>有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。<br>return 语句的语法格式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明函数 </span></span><br><span class="line"><span class="keyword">function</span> 函数名（）&#123; </span><br><span class="line">	... </span><br><span class="line">	<span class="keyword">return</span>  需要返回的值； </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 调用函数 </span></span><br><span class="line">函数名();    <span class="comment">// 此时调用函数就可以得到函数体内return 后面的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-arguments的使用"><a href="#5-arguments的使用" class="headerlink" title="5. arguments的使用"></a>5. arguments的使用</h3><p>当我们不确定有多少个参数传递的时候，可以用arguments 来获取。在JavaScript 中，arguments 实际上 它是当前函数的一个<strong>内置对象</strong>。所有函数都内置了一个arguments 对象，arguments 对象中存储了传递的 <strong>所有实参</strong>。</p>
<h3 id="6-函数的两种声明方式"><a href="#6-函数的两种声明方式" class="headerlink" title="6. 函数的两种声明方式"></a>6. 函数的两种声明方式</h3><h4 id="1-自定义函数方式-命名函数"><a href="#1-自定义函数方式-命名函数" class="headerlink" title="1.自定义函数方式(命名函数)"></a>1.自定义函数方式(命名函数)</h4><p>利用函数关键字 function 自定义函数方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明定义方式 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 调用 </span></span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>因为有名字，所以也被称为命名函数</li>
<li>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</li>
</ul>
<h4 id="2-函数表达式方式-匿名函数）"><a href="#2-函数表达式方式-匿名函数）" class="headerlink" title="2. 函数表达式方式(匿名函数）"></a>2. 函数表达式方式(匿名函数）</h4><p>利用函数表达式方式的写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是函数表达式写法，匿名函数后面跟分号结束 </span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;； </span><br><span class="line"><span class="comment">// 调用的方式，函数调用必须写到函数体下面 </span></span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>因为函数没有名字，所以也被称为匿名函数</li>
<li>这个fn 里面存储的是一个函数</li>
<li>函数表达式方式原理跟声明变量方式是一致的</li>
<li>函数调用的代码必须写到函数体后面</li>
</ul>
<h2 id="12-JavaScript-作用域"><a href="#12-JavaScript-作用域" class="headerlink" title="12.JavaScript 作用域"></a>12.JavaScript 作用域</h2><h3 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h3><h4 id="1-1-作用域概述"><a href="#1-1-作用域概述" class="headerlink" title="1.1 作用域概述"></a>1.1 作用域概述</h4><p>通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这 个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。</p>
<h4 id="1-2-全局作用域"><a href="#1-2-全局作用域" class="headerlink" title="1.2 全局作用域"></a>1.2 全局作用域</h4><h4 id="1-3-局部作用域-（函数作用域）"><a href="#1-3-局部作用域-（函数作用域）" class="headerlink" title="1.3 局部作用域 （函数作用域）"></a>1.3 局部作用域 （函数作用域）</h4><h2 id="13-JavaScript-预解析"><a href="#13-JavaScript-预解析" class="headerlink" title="13.JavaScript 预解析"></a>13.JavaScript 预解析</h2><h3 id="1-预解析"><a href="#1-预解析" class="headerlink" title="1. 预解析"></a>1. 预解析</h3><p>JavaScript 代码是由浏览器中的JavaScript 解析器来执行的。JavaScript解析器在运行JavaScript代码的 时候分为两步：预解析和代码执行。</p>
<ul>
<li>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中 进行提前声明或者定义。</li>
<li>代码执行： 从上到下执行JS语句</li>
</ul>
<h3 id="2-变量预解析和函数预解析"><a href="#2-变量预解析和函数预解析" class="headerlink" title="2. 变量预解析和函数预解析"></a>2. 变量预解析和函数预解析</h3><h4 id="2-1-变量预解析（变量提升）"><a href="#2-1-变量预解析（变量提升）" class="headerlink" title="2.1 变量预解析（变量提升）"></a>2.1 变量预解析（变量提升）</h4><p>预解析也叫做变量、函数提升。<br>变量提升： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。</p>
<h4 id="2-2-函数预解析（函数提升）"><a href="#2-2-函数预解析（函数提升）" class="headerlink" title="2.2 函数预解析（函数提升）"></a>2.2 函数预解析（函数提升）</h4><p>函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</p>
<h2 id="14-JavaScript-对象"><a href="#14-JavaScript-对象" class="headerlink" title="14.JavaScript 对象"></a>14.JavaScript 对象</h2><h3 id="1-创建对象的三种方式"><a href="#1-创建对象的三种方式" class="headerlink" title="1 创建对象的三种方式"></a>1 创建对象的三种方式</h3><p>在 JavaScript中，现阶段我们可以采用三种方式创建对象（object）：</p>
<ul>
<li>利用字面量创建对象</li>
<li>利用 new Object 创建对象</li>
<li>利用构造函数创建对象</li>
</ul>
<h4 id="1-1-利用字面量创建对象"><a href="#1-1-利用字面量创建对象" class="headerlink" title="1.1 利用字面量创建对象"></a>1.1 利用字面量创建对象</h4><p>对象字面量：就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法。<br>{ } 里面采取键值对的形式表示</p>
<ul>
<li>键：相当于属性名</li>
<li>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）</li>
</ul>
<img src="/posts/3424359953/1604393435448.png" class="" width="1604393435448">

<h4 id="1-2-利用new-Object创建对象"><a href="#1-2-利用new-Object创建对象" class="headerlink" title="1.2 利用new Object创建对象"></a>1.2 利用new Object创建对象</h4><img src="/posts/3424359953/1604393471123.png" class="" width="1604393471123">

<ul>
<li>Object() ：第一个字母大写</li>
<li>new Object() ：需要 new 关键字</li>
<li>使用的格式：对象.属性 =  值;</li>
</ul>
<h4 id="1-3-利用构造函数创建对象"><a href="#1-3-利用构造函数创建对象" class="headerlink" title="1.3 利用构造函数创建对象"></a>1.3 利用构造函数创建对象</h4><p>构造函数 ：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与new 运算符一起 使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。<br>在 js 中，使用构造函数要时要注意以下两点：</p>
<ul>
<li>构造函数用于创建某一类对象，其首字母要大写</li>
<li>构造函数要和new 一起使用才有意义</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, sex</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;我的名字叫：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;，年龄：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&#x27;，性别：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">sex</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bigbai = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;大白&#x27;</span>, <span class="number">100</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> smallbai = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小白&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bigbai.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(smallbai.<span class="property">name</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意</p>
<ol>
<li>  构造函数约定首字母大写。</li>
<li>函数内的属性和方法前面需要添加this ，表示当前对象的属性和方法。</li>
<li>  构造函数中不需要return 返回结果。</li>
<li>  当我们创建对象的时候，必须用new 来调用构造函数。</li>
</ol>
<h3 id="2-new关键字"><a href="#2-new关键字" class="headerlink" title="2. new关键字"></a>2. new关键字</h3><p>new 在执行时会做四件事情：</p>
<ol>
<li>在内存中创建一个新的空对象。</li>
<li>让 this 指向这个新的对象。</li>
<li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li>
<li>返回这个新对象（所以构造函数里面不需要return）。</li>
</ol>
<h3 id="3-遍历对象属性"><a href="#3-遍历对象属性" class="headerlink" title="3. 遍历对象属性"></a>3. 遍历对象属性</h3><p>for…in 语句用于对数组或者对象的属性进行循环操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (变量 <span class="keyword">in</span> 对象名字) &#123; </span><br><span class="line">    <span class="comment">// 在此执行代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-JavaScript-内置对象"><a href="#15-JavaScript-内置对象" class="headerlink" title="15.JavaScript 内置对象"></a>15.JavaScript 内置对象</h2><h3 id="1-内置对象"><a href="#1-内置对象" class="headerlink" title="1. 内置对象"></a>1. 内置对象</h3><ul>
<li>JavaScript 中的对象分为3种：自定义对象、内置对象、浏览器对象</li>
<li>前面两种对象是JS 基础 内容，属于 ECMAScript； 第三个浏览器对象属于我们JS 独有的， 我们JS API 讲解</li>
<li>内置对象就是指JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法）</li>
<li>内置对象最大的优点就是帮助我们快速开发</li>
<li>JavaScript 提供了多个内置对象：Math、 Date 、Array、String等</li>
</ul>
<h3 id="3-Math-对象"><a href="#3-Math-对象" class="headerlink" title="3. Math 对象"></a>3. Math 对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">PI</span> <span class="comment">// 圆周率 </span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>() <span class="comment">// 向下取整 </span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">ceil</span>() <span class="comment">// 向上取整 </span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>() <span class="comment">// 四舍五入版 就近取整 注意 -3.5   结果是 -3 </span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>() <span class="comment">// 绝对值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>()/<span class="title class_">Math</span>.<span class="title function_">min</span>() <span class="comment">// 求最大和最小值</span></span><br></pre></td></tr></table></figure>

<h3 id="4-日期对象"><a href="#4-日期对象" class="headerlink" title="4. 日期对象"></a>4. 日期对象</h3><h4 id="4-1-Date-概述"><a href="#4-1-Date-概述" class="headerlink" title="4.1 Date 概述"></a>4.1 Date 概述</h4><ul>
<li>Date 对象和 Math 对象不一样，他是一个构造函数，所以我们需要实例化后才能使用</li>
<li>Date 实例用来处理日期和时间</li>
</ul>
<h4 id="4-2-Date-方法的使用"><a href="#4-2-Date-方法的使用" class="headerlink" title="4.2 Date()方法的使用"></a>4.2 Date()方法的使用</h4><ol>
<li><p>获取当前时间必须实例化</p>
</li>
<li><p>Date() 构造函数的参数</p>
</li>
</ol>
<ul>
<li>如果Date()不写参数，就返回当前时间</li>
<li>如果Date()里面写参数，就返回括号里面输入的时间</li>
</ul>
<h4 id="4-3-日期格式化"><a href="#4-3-日期格式化" class="headerlink" title="4.3 日期格式化"></a>4.3 日期格式化</h4><img src="/posts/3424359953/1604394812083.png" class="" width="1604394812083">

<h3 id="5-数组对象"><a href="#5-数组对象" class="headerlink" title="5. 数组对象"></a>5. 数组对象</h3><h4 id="5-2-检测是否为数组"><a href="#5-2-检测是否为数组" class="headerlink" title="5.2 检测是否为数组"></a>5.2 检测是否为数组</h4><ul>
<li>instanceof 运算符，可以判断一个对象是否属于某种类型</li>
<li>Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">23</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="5-3-添加删除数组元素的方法"><a href="#5-3-添加删除数组元素的方法" class="headerlink" title="5.3 添加删除数组元素的方法"></a>5.3 添加删除数组元素的方法</h4><img src="/posts/3424359953/1604394924574.png" class="" width="1604394924574">

<h4 id="5-4-数组排序"><a href="#5-4-数组排序" class="headerlink" title="5.4 数组排序"></a>5.4 数组排序</h4><img src="/posts/3424359953/1604394963353.png" class="" width="1604394963353">

<h4 id="5-5-数组索引方法"><a href="#5-5-数组索引方法" class="headerlink" title="5.5 数组索引方法"></a>5.5 数组索引方法</h4><img src="/posts/3424359953/1604394985303.png" class="" width="1604394985303">

<h4 id="5-6-数组转换为字符串"><a href="#5-6-数组转换为字符串" class="headerlink" title="5.6 数组转换为字符串"></a>5.6 数组转换为字符串</h4><img src="/posts/3424359953/1604395010915.png" class="" width="1604395010915">

<h4 id="5-7-其他方法"><a href="#5-7-其他方法" class="headerlink" title="5.7 其他方法"></a>5.7 其他方法</h4><img src="/posts/3424359953/1604395042659.png" class="" width="1604395042659">

<h3 id="6-字符串对象"><a href="#6-字符串对象" class="headerlink" title="6. 字符串对象"></a>6. 字符串对象</h3><p>为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和Boolean。<br>基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p>
<h4 id="6-2-字符串的不可变"><a href="#6-2-字符串的不可变" class="headerlink" title="6.2 字符串的不可变"></a>6.2 字符串的不可变</h4><p>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</p>
<h4 id="6-3-根据字符返回位置"><a href="#6-3-根据字符返回位置" class="headerlink" title="6.3 根据字符返回位置"></a>6.3 根据字符返回位置</h4><img src="/posts/3424359953/1604395442486.png" class="" width="1604395442486">

<h4 id="6-4-根据位置返回字符（重点）"><a href="#6-4-根据位置返回字符（重点）" class="headerlink" title="6.4 根据位置返回字符（重点）"></a>6.4 根据位置返回字符（重点）</h4><img src="/posts/3424359953/1604395478234.png" class="" width="1604395478234">

<h4 id="6-5-字符串操作方法（重点）"><a href="#6-5-字符串操作方法（重点）" class="headerlink" title="6.5 字符串操作方法（重点）"></a>6.5 字符串操作方法（重点）</h4><img src="/posts/3424359953/1604395504360.png" class="" width="1604395504360">

<h4 id="6-6-replace-方法"><a href="#6-6-replace-方法" class="headerlink" title="6.6 replace()方法"></a>6.6 replace()方法</h4><p>replace() 方法用于在字符串中用一些字符替换另一些字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(被替换的字符串，要替换为的字符串)；</span><br></pre></td></tr></table></figure>

<h4 id="6-7-split-方法"><a href="#6-7-split-方法" class="headerlink" title="6.7 split()方法"></a>6.7 split()方法</h4><p>split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。</p>
<h2 id="16-Web-APIs"><a href="#16-Web-APIs" class="headerlink" title="16.Web APIs"></a>16.Web APIs</h2><h3 id="1-API"><a href="#1-API" class="headerlink" title="1.API"></a>1.API</h3><p>API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</p>
<p>简单理解： <strong>API</strong> <strong>是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能。</strong></p>
<h3 id="2-Web-API"><a href="#2-Web-API" class="headerlink" title="2.Web API"></a>2.Web API</h3><p><strong>Web API</strong>是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。</p>
<p>现阶段我们主要针对于浏览器讲解常用的 API , 主要针对浏览器做交互效果。</p>
<h2 id="17-DOM"><a href="#17-DOM" class="headerlink" title="17.DOM"></a>17.DOM</h2><h3 id="1-DOM-简介"><a href="#1-DOM-简介" class="headerlink" title="1. DOM 简介"></a>1. DOM 简介</h3><h4 id="1-1-什么是-DOM"><a href="#1-1-什么是-DOM" class="headerlink" title="1.1 什么是 DOM"></a>1.1 什么是 DOM</h4><p>文档对象模型（Document Object Model，简称 DOM），是W3C组织推荐的处理可扩展标记语言（HTML 或者XML）的标准编程接口。<br>W3C 已经定义了一系列的 DOM 接口，通过这些DOM 接口可以改变网页的内容、结构和样式。</p>
<h4 id="1-2-DOM-树"><a href="#1-2-DOM-树" class="headerlink" title="1.2 DOM 树"></a>1.2 DOM 树</h4><img src="/posts/3424359953/1604452369222.png" class="" width="1604452369222">

<ul>
<li>文档：一个页面就是一个文档，DOM 中使用 document 表示</li>
<li>元素：页面中的所有标签都是元素，DOM 中使用 element 表示</li>
<li>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM 中使用 node 表示<br>DOM 把以上内容都看做是对象</li>
</ul>
<h3 id="2-获取元素"><a href="#2-获取元素" class="headerlink" title="2.获取元素"></a>2.获取元素</h3><h4 id="2-1-如何获取页面元素"><a href="#2-1-如何获取页面元素" class="headerlink" title="2.1 如何获取页面元素"></a>2.1 如何获取页面元素</h4><h4 id="2-2-根据-ID-获取"><a href="#2-2-根据-ID-获取" class="headerlink" title="2.2 根据 ID 获取"></a>2.2 根据 ID 获取</h4><p>使用 getElementById() 方法可以获取带有 ID 的元素对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>因为我们文档页面从上往下加载，所以先得有标签所以我们script写到标签的下面</code></p>
<p><strong>使用 console.dir() 可以打印我们获取的元素对象，更好的查看对象里面的属性和方法。</strong></p>
<h4 id="2-3-根据标签名获取"><a href="#2-3-根据标签名获取" class="headerlink" title="2.3 根据标签名获取"></a>2.3 根据标签名获取</h4><p>使用 getElementsByTagName() 方法可以返回带有指定标签名的对象的集合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;标签名&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-4-通过-HTML5-新增的方法获取"><a href="#2-4-通过-HTML5-新增的方法获取" class="headerlink" title="2.4 通过 HTML5 新增的方法获取"></a>2.4 通过 HTML5 新增的方法获取</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(‘类名’)；<span class="comment">// 根据类名返回元素对象集合</span></span><br><span class="line"><span class="number">2.</span> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;选择器&#x27;</span>);        <span class="comment">// 根据指定选择器返回第一个元素对象</span></span><br><span class="line"><span class="number">3.</span> <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;选择器&#x27;</span>);     <span class="comment">// 根据指定选择器返回</span></span><br></pre></td></tr></table></figure>

<p><code>注意:</code><br>querySelector 和 querySelectorAll里面的选择器需要加符号,比如:document.querySelector(‘#nav’);</p>
<h4 id="2-5-获取特殊元素（body，html）"><a href="#2-5-获取特殊元素（body，html）" class="headerlink" title="2.5 获取特殊元素（body，html）"></a>2.5 获取特殊元素（body，html）</h4><p>获取body元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> doucumnet.<span class="property">body</span>  <span class="comment">// 返回body元素对象</span></span><br></pre></td></tr></table></figure>

<p>获取html元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="variable language_">document</span>.<span class="property">documentElement</span>  <span class="comment">// 返回html元素对象</span></span><br></pre></td></tr></table></figure>

<h3 id="3-事件基础"><a href="#3-事件基础" class="headerlink" title="3. 事件基础"></a>3. 事件基础</h3><h4 id="3-1-事件概述"><a href="#3-1-事件概述" class="headerlink" title="3.1 事件概述"></a>3.1 事件概述</h4><p>JavaScript 使我们有能力创建动态页面，而事件是可以被JavaScript 侦测到的行为。</p>
<h4 id="3-2-事件三要素"><a href="#3-2-事件三要素" class="headerlink" title="3.2 事件三要素"></a>3.2 事件三要素</h4><ol>
<li>事件源 （谁）</li>
<li>事件类型 （什么事件）</li>
<li>事件处理程序（做啥）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&#x27;你好吗&#x27;</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-执行事件的步骤"><a href="#3-3-执行事件的步骤" class="headerlink" title="3.3 执行事件的步骤"></a>3.3 执行事件的步骤</h4><ol>
<li>获取事件源</li>
<li>注册事件（绑定事件）</li>
<li>添加事件处理程序（采取函数赋值形式）</li>
</ol>
<p><code>常见的鼠标事件</code></p>
<img src="/posts/3424359953/1604453875713.png" class="" width="1604453875713">

<h3 id="4-操作元素"><a href="#4-操作元素" class="headerlink" title="4.操作元素"></a>4.操作元素</h3><p>JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容 、属性等。</p>
<h4 id="4-1-改变元素内容"><a href="#4-1-改变元素内容" class="headerlink" title="4.1 改变元素内容"></a>4.1 改变元素内容</h4><p><code>element.innerText</code>:<br>从起始位置到终止位置的内容, 但它去除 html 标签， 同时空格和换行也会去掉.<br><code>element.innerHTML</code>:<br>起始位置到终止位置的全部内容，包括 html 标签，同时保留空格和换行.</p>
<h4 id="4-2-常用元素的属性操作"><a href="#4-2-常用元素的属性操作" class="headerlink" title="4.2 常用元素的属性操作"></a>4.2 常用元素的属性操作</h4><ol>
<li>innerText、innerHTML 改变元素内容</li>
<li>src、href</li>
<li>id、alt、title</li>
</ol>
<h4 id="4-3-表单元素的属性操作"><a href="#4-3-表单元素的属性操作" class="headerlink" title="4.3 表单元素的属性操作"></a>4.3 表单元素的属性操作</h4><p>利用 DOM 可以操作如下表单元素的属性：</p>
<blockquote>
<p>type、value、checked、selected、disabled</p>
</blockquote>
<blockquote>
<p>this指向事件函数的调用者</p>
</blockquote>
<h4 id="4-4-样式属性操作"><a href="#4-4-样式属性操作" class="headerlink" title="4.4 样式属性操作"></a>4.4 样式属性操作</h4><p>我们可以通过JS 修改元素的大小、颜色、位置等样式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">style</span>     行内样式操作</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">backgroundcolor</span> = <span class="string">&#x27;purple&#x27;</span> ;</span><br><span class="line">element.<span class="property">className</span> 类名样式操作</span><br></pre></td></tr></table></figure>

<p>注意：<br>1.JS 里面的样式采取<code>驼峰命名法</code> 比如 fontSize、 backgroundColor.<br>2.JS 修改 style 样式操作，产生的是行内样式，CSS 权重比较高.</p>
<h4 id="4-6-自定义属性的操作"><a href="#4-6-自定义属性的操作" class="headerlink" title="4.6 自定义属性的操作"></a>4.6 自定义属性的操作</h4><ol>
<li>获取属性值</li>
</ol>
<ul>
<li><p>element.属性 设置内置属性值</p>
</li>
<li><p>element.getAttribute(‘属性’);主要获得自定义的属性 （标准） 我们程序员自定义的属性</p>
</li>
</ul>
<ol start="2">
<li>设置属性值</li>
</ol>
<ul>
<li>element.属性 = ‘值’ 设置内置属性值。</li>
<li>element.setAttribute(‘属性’, ‘值’);</li>
</ul>
<ol start="3">
<li>移除属性</li>
</ol>
<ul>
<li>element.removeAttribute(‘属性’);</li>
</ul>
<h4 id="4-7-H5自定义属性"><a href="#4-7-H5自定义属性" class="headerlink" title="4.7 H5自定义属性"></a>4.7 H5自定义属性</h4><p>自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</p>
<h5 id="1-设置H5自定义属性"><a href="#1-设置H5自定义属性" class="headerlink" title="1.设置H5自定义属性"></a>1.设置H5自定义属性</h5><p>H5规定自定义属性data-开头做为属性名并且赋值。<br><code>比如 &lt;div data-index=&quot;1&quot;&gt;&lt;/div&gt;</code><br>或者使用 JS 设置<br><code>element.setAttribute(‘data-index’, 2)</code></p>
<h5 id="2-获取H5自定义属性"><a href="#2-获取H5自定义属性" class="headerlink" title="2.获取H5自定义属性"></a>2.获取H5自定义属性</h5><ol>
<li>兼容性获取 element.getAttribute(‘data-index’);</li>
<li>H5新增 element.dataset.index  或者 element.dataset[‘index’] ie 11才开始支持</li>
</ol>
<h3 id="5-节点操作"><a href="#5-节点操作" class="headerlink" title="5. 节点操作"></a>5. 节点操作</h3><h4 id="5-1-节点层级"><a href="#5-1-节点层级" class="headerlink" title="5.1 节点层级"></a>5.1 节点层级</h4><p>1、父级节点</p>
<blockquote>
<p>node.parentNode</p>
</blockquote>
<p>2、子节点</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parentNode.childNodes（标准）</span><br><span class="line">parentNode.children（非标准）</span><br><span class="line">parentNode.firstChild  firstChild 返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。</span><br><span class="line">parentNode.lastChild  lastChild 返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。</span><br><span class="line">parentNode.firstElementChild  firstElementChild 返回第一个子元素节点，找不到则返回null(IE9 以上才支持)。</span><br><span class="line">parentNode.lastElementChild  lastElementChild 返回最后一个子元素节点，找不到则返回null(IE9 以上才支持)。</span><br></pre></td></tr></table></figure>

<p>实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？<br>解决方案：</p>
<ol>
<li>如果想要第一个子元素节点，可以使用 parentNode.chilren[0] </li>
<li>如果想要最后一个子元素节点，可以使用 parentNode.chilren[parentNode.chilren.length - 1] </li>
</ol>
<p>3、兄弟节点</p>
<blockquote>
<p>node.nextSibling</p>
</blockquote>
<p>nextSibling 返回当前元素的下一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点。</p>
<blockquote>
<p>node.previousSibling </p>
</blockquote>
<p>previousSibling 返回当前元素上一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点。</p>
<blockquote>
<p>node.nextElementSibling</p>
</blockquote>
<p>nextElementSibling 返回当前元素下一个兄弟元素节点，找不到则返回null。</p>
<blockquote>
<p>node.previousElementSibling  </p>
</blockquote>
<p>previousElementSibling 返回当前元素上一个兄弟节点，找不到则返回null。</p>
<h4 id="5-4-创建节点"><a href="#5-4-创建节点" class="headerlink" title="5.4 创建节点"></a>5.4 创建节点</h4><blockquote>
<p>document.createElement(‘tagName’)</p>
</blockquote>
<p>document.createElement() 方法创建由 tagName 指定的 HTML 元素。因为这些元素原先不存在， 是根据我们的需求动态生成的，所以我们也称为动态创建元素节点。</p>
<p> 添加节点</p>
<ol>
<li><h4 id="node-appendChild-child"><a href="#node-appendChild-child" class="headerlink" title="node.appendChild(child)"></a>node.appendChild(child)</h4></li>
</ol>
<p>node.appendChild() 方法将一个节点添加到指定父节点的子节点列表末尾。类似于 CSS 里面的 after 伪元素。</p>
<ol start="2">
<li><h4 id="node-insertBefore-child-指定元素"><a href="#node-insertBefore-child-指定元素" class="headerlink" title="node.insertBefore(child, 指定元素)"></a>node.insertBefore(child, 指定元素)</h4></li>
</ol>
<p>node.insertBefore() 方法将一个节点添加到父节点的指定子节点前面。类似于 CSS 里面的 before 伪元素。</p>
<ol start="3">
<li><h4 id="node-removeChild-child"><a href="#node-removeChild-child" class="headerlink" title="node.removeChild(child)"></a>node.removeChild(child)</h4></li>
</ol>
<p>node.removeChild() 方法从 DOM 中删除一个子节点，返回删除的节点</p>
<ol start="4">
<li><h4 id="node-cloneNode"><a href="#node-cloneNode" class="headerlink" title="node.cloneNode()"></a>node.cloneNode()</h4></li>
</ol>
<p>node.cloneNode() 方法返回调用该方法的节点的一个副本。也称为克隆节点/拷贝节点</p>
<ol>
<li>如果括号参数为空或者为 false ，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点。</li>
<li>如果括号参数为 true ，则是深度拷贝，会复制节点本身以及里面所有的子节点。</li>
</ol>
<h4 id="5-8-三种动态创建元素区别"><a href="#5-8-三种动态创建元素区别" class="headerlink" title="5.8 三种动态创建元素区别"></a>5.8 三种动态创建元素区别</h4><ul>
<li>document.write()</li>
<li>element.innerHTML</li>
<li>document.createElement() </li>
</ul>
<p>区别</p>
<ol>
<li>document.write 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘</li>
<li>innerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘</li>
<li>innerHTML 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂</li>
<li>createElement() 创建多个元素效率稍低一点点，但是结构更清晰</li>
</ol>
<h3 id="6-DOM-重点核心"><a href="#6-DOM-重点核心" class="headerlink" title="6. DOM 重点核心"></a>6. DOM 重点核心</h3><p>关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。</p>
<h4 id="6-1-创建"><a href="#6-1-创建" class="headerlink" title="6.1 创建"></a>6.1 创建</h4><ol>
<li>document.write</li>
<li>innerHTML</li>
<li>createElement</li>
</ol>
<h4 id="6-2-增"><a href="#6-2-增" class="headerlink" title="6.2 增"></a>6.2 增</h4><ol>
<li>appendChild</li>
<li>insertBefore</li>
</ol>
<h4 id="6-3-删"><a href="#6-3-删" class="headerlink" title="6.3 删"></a>6.3 删</h4><ol>
<li>removeChild</li>
</ol>
<h4 id="6-4-改"><a href="#6-4-改" class="headerlink" title="6.4 改"></a>6.4 改</h4><p>主要修改dom的元素属性，dom元素的内容、属性, 表单的值等</p>
<ol>
<li>修改元素属性： src、href、title等</li>
<li>修改普通元素内容： innerHTML 、innerText</li>
<li>修改表单元素： value、type、disabled等</li>
<li>修改元素样式： style、className</li>
</ol>
<h4 id="6-5-查"><a href="#6-5-查" class="headerlink" title="6.5 查"></a>6.5 查</h4><p>主要获取查询dom的元素</p>
<ol>
<li>DOM提供的API 方法： getElementById、getElementsByTagName  古老用法 不太推荐</li>
<li>H5提供的新方法：querySelector、querySelectorAll   提倡</li>
<li>利用节点操作获取元素： 父(parentNode)、子(children)、兄(previousElementSibling、 nextElementSibling)  提倡</li>
</ol>
<h4 id="6-6-属性操作"><a href="#6-6-属性操作" class="headerlink" title="6.6 属性操作"></a>6.6 属性操作</h4><p>主要针对于自定义属性。</p>
<ol>
<li>setAttribute：设置dom的属性值</li>
<li>getAttribute：得到dom的属性值</li>
<li>removeAttribute移除属性</li>
</ol>
<h4 id="6-7-事件操作"><a href="#6-7-事件操作" class="headerlink" title="6.7 事件操作"></a>6.7 事件操作</h4><img src="/posts/3424359953/1604457644946.png" class="" width="1604457644946">



<h2 id="18-事件高级"><a href="#18-事件高级" class="headerlink" title="18.事件高级"></a>18.事件高级</h2><h3 id="1-注册事件（绑定事件）"><a href="#1-注册事件（绑定事件）" class="headerlink" title="1. 注册事件（绑定事件）"></a>1. 注册事件（绑定事件）</h3><h4 id="1-1-注册事件概述"><a href="#1-1-注册事件概述" class="headerlink" title="1.1 注册事件概述"></a>1.1 注册事件概述</h4><p>给元素添加事件，称为注册事件或者绑定事件。<br>注册事件有两种方式：传统方式和方法监听注册方式</p>
<p>传统注册方式 </p>
<ul>
<li>利用 on 开头的事件 onclick </li>
<li>&lt;button onclick=“alert(‘hi~’)”&gt;&lt;/button&gt; </li>
<li>btn.onclick = function() {} </li>
<li>特点： 注册事件的唯一性 </li>
<li>同一个元素同一个事件只能设置一个处理函数，最 后注册的处理函数将会覆盖前面注册的处理函数</li>
</ul>
<p>方法监听注册方式</p>
<ul>
<li>w3c 标准 推荐方式 </li>
<li>addEventListener() 它是一个方法 </li>
<li>IE9 之前的 IE 不支持此方法，可使用 attachEvent() 代替 </li>
<li>特点：同一个元素同一个事件可以注册多个监听器 </li>
<li>按注册顺序依次执行</li>
</ul>
<h4 id="1-2-addEventListener-事件监听方式"><a href="#1-2-addEventListener-事件监听方式" class="headerlink" title="1.2 addEventListener 事件监听方式"></a>1.2 addEventListener 事件监听方式</h4><blockquote>
<p>eventTarget.addEventListener(type, listener[, useCapture]) </p>
</blockquote>
<p>eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对 象触发指定的事件时，就会执行事件处理函数。<br>该方法接收三个参数：</p>
<ul>
<li>type：事件类型字符串，比如 click 、mouseover ，注意这里不要带on</li>
<li>listener：事件处理函数，事件发生时，会调用该监听函数</li>
<li>useCapture：可选参数，是一个布尔值，默认是false。学完DOM 事件流后，我们再进一步学习</li>
</ul>
<h4 id="1-3-attachEvent-事件监听方式-只能在IE9-之前使用"><a href="#1-3-attachEvent-事件监听方式-只能在IE9-之前使用" class="headerlink" title="1.3 attachEvent 事件监听方式(只能在IE9 之前使用)"></a>1.3 attachEvent 事件监听方式(只能在IE9 之前使用)</h4><blockquote>
<p>eventTarget.attachEvent(eventNameWithOn, callback) </p>
</blockquote>
<p>eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触 发指定的事件时，指定的回调函数就会被执行。<br>该方法接收两个参数：</p>
<ul>
<li>eventNameWithOn：事件类型字符串，比如onclick 、onmouseover ，这里要带 on</li>
<li>callback：事件处理函数，当目标触发事件时回调函数被调用<br>注意：IE8 及早期版本支持</li>
</ul>
<h4 id="1-4-注册事件兼容性解决方案"><a href="#1-4-注册事件兼容性解决方案" class="headerlink" title="1.4 注册事件兼容性解决方案"></a>1.4 注册事件兼容性解决方案</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addEventListener</span>(<span class="params">element, eventName, fn</span>) &#123; </span><br><span class="line">    <span class="comment">// 判断当前浏览器是否支持 addEventListener 方法     </span></span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">addEventListener</span>) &#123;         </span><br><span class="line">        element.<span class="title function_">addEventListener</span>(eventName, fn);  </span><br><span class="line">        <span class="comment">// 第三个参数 默认是false     </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">attachEvent</span>) &#123;		</span><br><span class="line">        element.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + eventName, fn);	</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 相当于 element.onclick = fn;         </span></span><br><span class="line">        element[<span class="string">&#x27;on&#x27;</span> + eventName] = fn;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-删除事件（解绑事件）"><a href="#2-删除事件（解绑事件）" class="headerlink" title="2. 删除事件（解绑事件）"></a>2. 删除事件（解绑事件）</h3><h4 id="2-1-删除事件的方式"><a href="#2-1-删除事件的方式" class="headerlink" title="2.1 删除事件的方式"></a>2.1 删除事件的方式</h4><ol>
<li><p>传统注册方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventTarget.<span class="property">onclick</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>方法监听注册方式</p>
</li>
</ol>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eventTarget.<span class="title function_">removeEventListener</span>(type, listener[, useCapture]);</span><br><span class="line">eventTarget.<span class="title function_">detachEvent</span>(eventNameWithOn, callback);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-删除事件兼容性解决方案"><a href="#2-2-删除事件兼容性解决方案" class="headerlink" title="2.2 删除事件兼容性解决方案"></a>2.2 删除事件兼容性解决方案</h4><img src="/posts/3424359953/1604458921348.png" class="" width="1604458921348">

<h3 id="3-DOM-事件流"><a href="#3-DOM-事件流" class="headerlink" title="3. DOM 事件流"></a>3. DOM 事件流</h3><p>事件流描述的是从页面中接收事件的顺序。<br>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM 事件流。</p>
<p>比如我们给一个div 注册了点击事件：</p>
<p>DOM 事件流分为3个阶段：</p>
<ol>
<li>捕获阶段</li>
<li>当前目标阶段</li>
<li>冒泡阶段</li>
</ol>
<img src="/posts/3424359953/1604459021352.png" class="" width="1604459021352">

<ul>
<li>事件冒泡： IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到DOM 最顶层节点的过程。</li>
<li>事件捕获： 网景最早提出，由DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。</li>
</ul>
<p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM 事件流。</p>
<p>注意</p>
<ol>
<li><p>JS 代码中只能执行捕获或者冒泡其中的一个阶段。</p>
</li>
<li><p>onclick 和 attachEvent 只能得到冒泡阶段。</p>
</li>
<li><p>addEventListener(type, listener[, useCapture])第三个参数如果是 true，表示在事件捕 获阶段调用事件处理程序；如果是 false（不写默认就是false），表示在事件冒泡阶段调用事件处理 程序。</p>
</li>
<li><p>实际开发中我们很少使用事件捕获，我们更关注事件冒泡。</p>
</li>
<li><p>有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave</p>
</li>
<li><p>事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解。</p>
</li>
</ol>
<h3 id="4-事件对象"><a href="#4-事件对象" class="headerlink" title="4. 事件对象"></a>4. 事件对象</h3><h4 id="4-1-什么是事件对象"><a href="#4-1-什么是事件对象" class="headerlink" title="4.1 什么是事件对象"></a>4.1 什么是事件对象</h4><p>简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象 event，它有很多属性和方法。<br>比如：</p>
<ol>
<li>谁绑定了这个事件。</li>
<li>鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。</li>
<li>键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。</li>
</ol>
<h4 id="4-2-事件对象的使用语法"><a href="#4-2-事件对象的使用语法" class="headerlink" title="4.2 事件对象的使用语法"></a>4.2 事件对象的使用语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eventTarget.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">   <span class="comment">// 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt </span></span><br><span class="line">&#125; </span><br><span class="line">eventTarget.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">   <span class="comment">// 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt </span></span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure>

<p>这个event  是个形参，系统帮我们设定为事件对象，不需要传递实参过去。<br>当我们注册事件时，event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）。</p>
<h4 id="4-4-事件对象的常见属性和方法"><a href="#4-4-事件对象的常见属性和方法" class="headerlink" title="4.4 事件对象的常见属性和方法"></a>4.4 事件对象的常见属性和方法</h4><p>e.target 和 this 的区别：</p>
<ul>
<li>this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素）</li>
<li>e.target 是事件触发的元素。(点击了哪个元素，就返回哪个元素)</li>
<li><img src="/posts/3424359953/1604460102431.png" class="" width="1604460102431"></li>
</ul>
<h3 id="5-阻止事件冒泡"><a href="#5-阻止事件冒泡" class="headerlink" title="5. 阻止事件冒泡"></a>5. 阻止事件冒泡</h3><h4 id="5-1-阻止事件冒泡的两种方式"><a href="#5-1-阻止事件冒泡的两种方式" class="headerlink" title="5.1 阻止事件冒泡的两种方式"></a>5.1 阻止事件冒泡的两种方式</h4><p>事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到DOM 最顶层节点。<br>事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。</p>
<p>阻止事件冒泡</p>
<p>标准写法：利用事件对象里面的 stopPropagation()方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.<span class="title function_">stopPropagation</span>() </span><br></pre></td></tr></table></figure>

<p>非标准写法：IE 6-8  利用事件对象cancelBubble 属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.<span class="property">cancelBubble</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-事件委托（代理、委派）"><a href="#6-事件委托（代理、委派）" class="headerlink" title="6. 事件委托（代理、委派）"></a>6. 事件委托（代理、委派）</h3><p><strong>事件委托的原理</strong><br>不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。<br>以上案例：给ul 注册点击事件，然后利用事件对象的target 来找到当前点击的li，因为点击 li，事件会冒泡到ul 上， ul 有注册事件，就会触发事件监听器。</p>
<h3 id="7-常用的3鼠标事件"><a href="#7-常用的3鼠标事件" class="headerlink" title="7. 常用的3鼠标事件"></a>7. 常用的3鼠标事件</h3><img src="/posts/3424359953/1604460464635.png" class="" width="1604460464635">

<h4 id="7-1-常用的鼠标事件"><a href="#7-1-常用的鼠标事件" class="headerlink" title="7.1 常用的鼠标事件"></a>7.1 常用的鼠标事件</h4><h4 id="1-禁止鼠标右键菜单"><a href="#1-禁止鼠标右键菜单" class="headerlink" title="1.禁止鼠标右键菜单"></a>1.禁止鼠标右键菜单</h4><p>contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;contextmenu&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;	</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-禁止鼠标选中（selectstart-开始选中）"><a href="#2-禁止鼠标选中（selectstart-开始选中）" class="headerlink" title="2.禁止鼠标选中（selectstart 开始选中）"></a>2.禁止鼠标选中（selectstart 开始选中）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;selectstart&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;	</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="8-常用的键盘事件"><a href="#8-常用的键盘事件" class="headerlink" title="8. 常用的键盘事件"></a>8. 常用的键盘事件</h3><h4 id="8-1-常用键盘事件"><a href="#8-1-常用键盘事件" class="headerlink" title="8.1 常用键盘事件"></a>8.1 常用键盘事件</h4><p>事件除了使用鼠标触发，还可以使用键盘触发。</p>
<img src="/posts/3424359953/1604460883205.png" class="" width="1604460883205">

<p>注意：</p>
<ol>
<li> 如果使用addEventListener 不需要加on</li>
<li> onkeypress 和前面2个的区别是，它不识别功能键，比如左右箭头，shift 等。</li>
<li> 三个事件的执行顺序是： keydown – keypress  — keyup</li>
</ol>
<h4 id="8-2-键盘事件对象"><a href="#8-2-键盘事件对象" class="headerlink" title="8.2 键盘事件对象"></a>8.2 键盘事件对象</h4><img src="/posts/3424359953/1604461171890.png" class="" width="1604461171890">

<p><code>注意</code>： onkeydown 和 onkeyup  不区分字母大小写，onkeypress 区分字母大小写。<br>在我们实际开发中，我们更多的使用keydown和keyup，它能识别所有的键（包括功能键）<br>Keypress 不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCII值</p>
<h2 id="19-BOM"><a href="#19-BOM" class="headerlink" title="19.BOM"></a>19.BOM</h2><h3 id="1-BOM-概述"><a href="#1-BOM-概述" class="headerlink" title="1. BOM 概述"></a>1. BOM 概述</h3><h4 id="1-1-什么是-BOM"><a href="#1-1-什么是-BOM" class="headerlink" title="1.1 什么是 BOM"></a>1.1 什么是 BOM</h4><p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心 对象是 window。</p>
<img src="/posts/3424359953/1604461367686.png" class="" width="1604461367686">

<h3 id="1-2-BOM-的构成"><a href="#1-2-BOM-的构成" class="headerlink" title="1.2 BOM 的构成"></a>1.2 BOM 的构成</h3><p>window 对象是浏览器的顶级对象，它具有双重角色。</p>
<ol>
<li>它是 JS 访问浏览器窗口的一个接口。</li>
<li>它是一个全局对象。定义在全局作用域中的变量、函数都会变成window 对象的属性和方法。</li>
</ol>
<img src="/posts/3424359953/1604461494009.png" class="" width="1604461494009">

<h3 id="2-window-对象的常见事件"><a href="#2-window-对象的常见事件" class="headerlink" title="2. window 对象的常见事件"></a>2. window 对象的常见事件</h3><h4 id="2-1-窗口加载事件"><a href="#2-1-窗口加载事件" class="headerlink" title="2.1 窗口加载事件"></a>2.1 窗口加载事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; </span><br><span class="line"><span class="comment">// 或者 </span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>window.onload 是窗口 (页面）加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。</p>
<p>注意：</p>
<ol>
<li>有了 window.onload 就可以把 JS 代码写到页面元素的上方，因为onload 是等页面内容全部加载完毕， 再去执行处理函数。</li>
<li>window.onload 传统注册事件方式只能写一次，如果有多个，会以最后一个 window.onload 为准。</li>
<li>如果使用 addEventListener 则没有限制</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。<br>Ie9以上才支持<br>如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间,交互效果就不能实现，必然影响用 户的体验，此时用 DOMContentLoaded 事件比较合适。</p>
<h4 id="2-2-调整窗口大小事件"><a href="#2-2-调整窗口大小事件" class="headerlink" title="2.2 调整窗口大小事件"></a>2.2 调整窗口大小事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>window.onresize 是调整窗口大小加载事件,  当触发时就调用的处理函数。<br>注意：</p>
<ol>
<li>只要窗口大小发生像素变化，就会触发这个事件。</li>
<li>我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度</li>
</ol>
<h3 id="3-定时器"><a href="#3-定时器" class="headerlink" title="3. 定时器"></a>3. 定时器</h3><h4 id="3-1-两种定时器"><a href="#3-1-两种定时器" class="headerlink" title="3.1 两种定时器"></a>3.1 两种定时器</h4><p>window 对象给我们提供了2 个非常好用的方法-定时器。</p>
<ul>
<li>setTimeout() 定时器</li>
<li>setInterval()  时间间隔定时器</li>
</ul>
<h4 id="3-3-停止-setTimeout-定时器"><a href="#3-3-停止-setTimeout-定时器" class="headerlink" title="3.3 停止 setTimeout() 定时器"></a>3.3 停止 setTimeout() 定时器</h4><p>clearTimeout()方法取消了先前通过调用 setTimeout() 建立的定时器。</p>
<h4 id="3-5-停止-setInterval-定时器"><a href="#3-5-停止-setInterval-定时器" class="headerlink" title="3.5 停止 setInterval() 定时器"></a>3.5 停止 setInterval() 定时器</h4><p>clearInterval()方法取消了先前通过调用 setInterval()建立的定时器。</p>
<h3 id="4-JS-执行机制"><a href="#4-JS-执行机制" class="headerlink" title="4. JS 执行机制"></a>4. JS 执行机制</h3><h4 id="4-1-JS-是单线程"><a href="#4-1-JS-是单线程" class="headerlink" title="4.1 JS 是单线程"></a>4.1 JS 是单线程</h4><p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。</p>
<h4 id="4-2-同步和异步"><a href="#4-2-同步和异步" class="headerlink" title="4.2 同步和异步"></a>4.2 同步和异步</h4><p>为了解决这个问题，利用多核CPU 的计算能力，HTML5 提出 Web Worker 标准，允许JavaScript 脚本创 建多个线程。于是，JS 中出现了<strong>同步</strong>和<strong>异步</strong>。</p>
<h4 id="4-3-同步和异步"><a href="#4-3-同步和异步" class="headerlink" title="4.3 同步和异步"></a>4.3 同步和异步</h4><p><strong>同步任务</strong><br>同步任务都在主线程上执行，形成一个执行栈。<br><strong>异步任务</strong><br>JS 的异步是通过回调函数实现的。</p>
<h4 id="4-4-JS-执行机制"><a href="#4-4-JS-执行机制" class="headerlink" title="4.4 JS 执行机制"></a>4.4 JS 执行机制</h4><ol>
<li>先执行执行栈中的同步任务。</li>
<li>异步任务（回调函数）放入任务队列中。</li>
<li>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任 务结束等待状态，进入执行栈，开始执行。</li>
</ol>
<h3 id="5-location-对象"><a href="#5-location-对象" class="headerlink" title="5. location 对象"></a>5. location 对象</h3><h4 id="5-1-什么是-location-对象"><a href="#5-1-什么是-location-对象" class="headerlink" title="5.1 什么是 location 对象"></a>5.1 什么是 location 对象</h4><p>window 对象给我们提供了一个location 属性用于获取或设置窗体的URL，并且可以用于解析 URL 。 因为 这个属性返回的是一个对象，所以我们将这个属性也称为location 对象。</p>
<h4 id="5-2-URL"><a href="#5-2-URL" class="headerlink" title="5.2 URL"></a>5.2 URL</h4><p>统一资源定位符 (Uniform Resource Locator, URL) 是互联网上标准资源的地址。互联网上的每个文件都有 一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
<h4 id="5-3-location-对象的属性"><a href="#5-3-location-对象的属性" class="headerlink" title="5.3 location 对象的属性"></a>5.3 location 对象的属性</h4><img src="/posts/3424359953/1604467496191.png" class="" title="5.4 location 对象的方法">

<h4 id="5-4-location-对象的方法"><a href="#5-4-location-对象的方法" class="headerlink" title="5.4 location 对象的方法"></a>5.4 location 对象的方法</h4><img src="/posts/3424359953/1604467529595.png" class="" width="1604467529595">

<h3 id="6-navigator-对象"><a href="#6-navigator-对象" class="headerlink" title="6. navigator 对象"></a>6. navigator 对象</h3><p>navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是userAgent，该属性可以返回由客 户机发送服务器的 user-agent 头部的值。<br>下面前端代码可以判断用户那个终端打开页面，实现跳转</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(navigator.<span class="property">userAgent</span>.<span class="title function_">match</span>(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>)) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;&quot;</span>;     </span><br><span class="line">    <span class="comment">//手机</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;	</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;&quot;</span>;     </span><br><span class="line">    <span class="comment">//电脑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-history-对象"><a href="#7-history-对象" class="headerlink" title="7. history 对象"></a>7. history 对象</h3><p>window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中） 访问过的 URL。</p>
<img src="/posts/3424359953/1604468001386.png" class="" width="1604468001386">

<h2 id="20-本地存储"><a href="#20-本地存储" class="headerlink" title="20.本地存储"></a>20.本地存储</h2><h3 id="1-window-sessionStorage"><a href="#1-window-sessionStorage" class="headerlink" title="1.window.sessionStorage"></a>1.window.sessionStorage</h3><p>1、生命周期为关闭浏览器窗口</p>
<p>2、在同一个窗口(页面)下数据可以共享</p>
<p>3、以键值对的形式存储使用</p>
<p>存储数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(key, value)</span><br></pre></td></tr></table></figure>

<p>获取数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(key)</span><br></pre></td></tr></table></figure>

<p>删除数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">removeItem</span>(key)</span><br></pre></td></tr></table></figure>

<p>删除所有数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure>

<h3 id="2-window-localStorage"><a href="#2-window-localStorage" class="headerlink" title="2.window.localStorage"></a>2.window.localStorage</h3><p>1、声明周期永久生效，除非手动删除否则关闭页面也会存在</p>
<p>2、可以多窗口（页面）共享（同一浏览器可以共享）</p>
<p>3、以键值对的形式存储使用</p>
<p>存储数据：</p>
<blockquote>
<p>localStorage.setItem(key, value)</p>
</blockquote>
<p>获取数据：</p>
<blockquote>
<p>localStorage.getItem(key)</p>
</blockquote>
<p>删除数据：</p>
<blockquote>
<p>localStorage.removeItem(key)</p>
</blockquote>
<p>删除所有数据：</p>
<blockquote>
<p>localStorage.clear()</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io">Eric</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io/posts/3424359953/">https://ericwjian.github.io/posts/3424359953/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericwjian.github.io" target="_blank">Eric</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2920256992/" title="SpringMVC"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringMVC</div></div></a></div><div class="next-post pull-right"><a href="/posts/583548277/" title="CSS 学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CSS 学习</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Eric</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/wangjian_uuid" target="_blank" title="Gitee"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:358070983@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=358070983&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9D%E8%AF%86-JavaScript"><span class="toc-text">1.初识 JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-JavaScript-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1.1 JavaScript 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-JavaScript-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">1.2 JavaScript 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-HTML-CSS-JS-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">1.3 HTML&#x2F;CSS&#x2F;JS 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A7%E8%A1%8C-JS-%E7%AE%80%E4%BB%8B"><span class="toc-text">1.4 浏览器执行 JS 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-JS-%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">1.5 JS 的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-JS-%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-text">1.6 JS 初体验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%A1%8C%E5%86%85%E5%BC%8F-JS"><span class="toc-text">1.行内式 JS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E5%B5%8C-JS"><span class="toc-text">2.内嵌 JS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%96%E9%83%A8-JS%E6%96%87%E4%BB%B6"><span class="toc-text">3. 外部 JS文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-JavaScript%E6%B3%A8%E9%87%8A"><span class="toc-text">2.JavaScript注释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-text">1. 单行注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-text">2. 多行注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-JavaScript-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.JavaScript 输入输出语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%98%E9%87%8F%E6%A6%82%E8%BF%B0"><span class="toc-text">4.变量概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%AC%E8%B4%A8"><span class="toc-text">1.本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2. 变量的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="toc-text">1. 声明变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B5%8B%E5%80%BC"><span class="toc-text">2. 赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">3. 变量的初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F%E8%AF%AD%E6%B3%95%E6%89%A9%E5%B1%95"><span class="toc-text">3.变量语法扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9B%B4%E6%96%B0%E5%8F%98%E9%87%8F"><span class="toc-text">1.更新变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%8C%E6%97%B6%E5%A3%B0%E6%98%8E%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-text">2.同时声明多个变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-text">3.声明变量特殊情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">5.数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 变量的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">2. 数据类型的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-text">2.1 简单数据类型（基本数据类型）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%95%B0%E5%AD%97%E5%9E%8B-Number"><span class="toc-text">2.2 数字型 Number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B-String"><span class="toc-text">2.3 字符串型 String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%B8%83%E5%B0%94%E5%9E%8B-Boolean"><span class="toc-text">2.4  布尔型 Boolean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-Undefined-%E5%92%8C-Null"><span class="toc-text">2.5  Undefined 和 Null</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.获取变量数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E8%8E%B7%E5%8F%96%E6%A3%80%E6%B5%8B%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.1  获取检测变量的数据类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">6.数据类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">1.转换为字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E5%9E%8B%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">2.转换为数字型（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-text">3.转换为布尔型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">7.运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1.算数运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 算术运算符概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-text">1.2 浮点数的精度问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">2. 递增和递减运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 递增和递减运算符概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%89%8D%E7%BD%AE%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">2.2 前置递增运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%90%8E%E7%BD%AE%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">2.3 后置递增运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%89%8D%E7%BD%AE%E9%80%92%E5%A2%9E%E5%92%8C%E5%90%8E%E7%BD%AE%E9%80%92%E5%A2%9E%E5%B0%8F%E7%BB%93"><span class="toc-text">2.4 前置递增和后置递增小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">3.比较运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1 比较运算符概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%B0%8F%E7%BB%93"><span class="toc-text">3.2 &#x3D;小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4.逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E6%A6%82%E8%BF%B0"><span class="toc-text">1 逻辑运算符概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%BB%E8%BE%91%E4%B8%8E-amp-amp"><span class="toc-text">2 逻辑与&amp;&amp;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%BB%E8%BE%91%E6%88%96"><span class="toc-text">3 逻辑或 ||</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E9%9D%9E-%EF%BC%81"><span class="toc-text">4 逻辑非 ！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97%EF%BC%88%E9%80%BB%E8%BE%91%E4%B8%AD%E6%96%AD%EF%BC%89"><span class="toc-text">5 短路运算（逻辑中断）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%80%BB%E8%BE%91%E4%B8%AD%E6%96%AD%EF%BC%88%E7%9F%AD%E8%B7%AF%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-text">6 逻辑中断（短路操作）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">5.赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">6.运算符优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-%E5%88%86%E6%94%AF"><span class="toc-text">8.流程控制-分支</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">1. 流程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A1%BA%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">2. 顺序流程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E6%94%AF%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-if-%E8%AF%AD%E5%8F%A5"><span class="toc-text">3. 分支流程控制 if 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">4. 三元表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%86%E6%94%AF%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-switch-%E8%AF%AD%E5%8F%A5"><span class="toc-text">5. 分支流程控制 switch 语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-%E5%BE%AA%E7%8E%AF"><span class="toc-text">9.流程控制-循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BE%AA%E7%8E%AF"><span class="toc-text">1. 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-for-%E5%BE%AA%E7%8E%AF"><span class="toc-text">2. for 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-while-%E5%BE%AA%E7%8E%AF"><span class="toc-text">3.while 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-do-while-%E5%BE%AA%E7%8E%AF"><span class="toc-text">4. do while 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-continue-break"><span class="toc-text">5.continue break</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-continue-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">1 continue 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-break-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2 break 关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-JavaScript-%E6%95%B0%E7%BB%84"><span class="toc-text">10.JavaScript 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">1 数组的创建方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">2. 获取数组元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-text">3.遍历数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-text">3.1 数组的长度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0"><span class="toc-text">4. 数组中新增元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9-length-%E9%95%BF%E5%BA%A6%E6%96%B0%E5%A2%9E%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">4.1 通过修改 length 长度新增数组元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E6%96%B0%E5%A2%9E%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">4.2 通过修改数组索引新增数组元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-JavaScript-%E5%87%BD%E6%95%B0"><span class="toc-text">11.JavaScript 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 函数的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2. 函数的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%A3%B0%E6%98%8E%E5%87%BD%E6%95%B0"><span class="toc-text">2.1 声明函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">2.2 调用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">3. 函数的参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-text">3.1 形参和实参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B"><span class="toc-text">3.2 函数参数的传递过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-text">3.3 函数形参和实参个数不匹配问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">4. 函数的返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-return-%E8%AF%AD%E5%8F%A5"><span class="toc-text">4.1 return 语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-arguments%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">5. arguments的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F"><span class="toc-text">6. 函数的两种声明方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F-%E5%91%BD%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">1.自定义函数方式(命名函数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%96%B9%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">2. 函数表达式方式(匿名函数）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">12.JavaScript 作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">1. 作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 作用域概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">1.2 全局作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F-%EF%BC%88%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%89"><span class="toc-text">1.3 局部作用域 （函数作用域）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-JavaScript-%E9%A2%84%E8%A7%A3%E6%9E%90"><span class="toc-text">13.JavaScript 预解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A2%84%E8%A7%A3%E6%9E%90"><span class="toc-text">1. 预解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F%E9%A2%84%E8%A7%A3%E6%9E%90%E5%92%8C%E5%87%BD%E6%95%B0%E9%A2%84%E8%A7%A3%E6%9E%90"><span class="toc-text">2. 变量预解析和函数预解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%8F%98%E9%87%8F%E9%A2%84%E8%A7%A3%E6%9E%90%EF%BC%88%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%89"><span class="toc-text">2.1 变量预解析（变量提升）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%87%BD%E6%95%B0%E9%A2%84%E8%A7%A3%E6%9E%90%EF%BC%88%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%EF%BC%89"><span class="toc-text">2.2 函数预解析（函数提升）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-JavaScript-%E5%AF%B9%E8%B1%A1"><span class="toc-text">14.JavaScript 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">1 创建对象的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%88%A9%E7%94%A8%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.1 利用字面量创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%88%A9%E7%94%A8new-Object%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.2 利用new Object创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%88%A9%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.3 利用构造函数创建对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-new%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2. new关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-text">3. 遍历对象属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-JavaScript-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-text">15.JavaScript 内置对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-text">1. 内置对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Math-%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. Math 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1"><span class="toc-text">4. 日期对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-Date-%E6%A6%82%E8%BF%B0"><span class="toc-text">4.1 Date 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-Date-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.2 Date()方法的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">4.3 日期格式化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">5. 数组对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-text">5.2 检测是否为数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">5.3 添加删除数组元素的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-text">5.4 数组排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%B3%95"><span class="toc-text">5.5 数组索引方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">5.6 数组转换为字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-text">5.7 其他方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-text">6. 字符串对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-text">6.2 字符串的不可变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E8%BF%94%E5%9B%9E%E4%BD%8D%E7%BD%AE"><span class="toc-text">6.3 根据字符返回位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%BD%AE%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">6.4 根据位置返回字符（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">6.5 字符串操作方法（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-replace-%E6%96%B9%E6%B3%95"><span class="toc-text">6.6 replace()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-split-%E6%96%B9%E6%B3%95"><span class="toc-text">6.7 split()方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Web-APIs"><span class="toc-text">16.Web APIs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-API"><span class="toc-text">1.API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Web-API"><span class="toc-text">2.Web API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-DOM"><span class="toc-text">17.DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-DOM-%E7%AE%80%E4%BB%8B"><span class="toc-text">1. DOM 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF-DOM"><span class="toc-text">1.1 什么是 DOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-DOM-%E6%A0%91"><span class="toc-text">1.2 DOM 树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><span class="toc-text">2.获取元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0"><span class="toc-text">2.1 如何获取页面元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%A0%B9%E6%8D%AE-ID-%E8%8E%B7%E5%8F%96"><span class="toc-text">2.2 根据 ID 获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%A0%B9%E6%8D%AE%E6%A0%87%E7%AD%BE%E5%90%8D%E8%8E%B7%E5%8F%96"><span class="toc-text">2.3 根据标签名获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E9%80%9A%E8%BF%87-HTML5-%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96"><span class="toc-text">2.4 通过 HTML5 新增的方法获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E8%8E%B7%E5%8F%96%E7%89%B9%E6%AE%8A%E5%85%83%E7%B4%A0%EF%BC%88body%EF%BC%8Chtml%EF%BC%89"><span class="toc-text">2.5 获取特殊元素（body，html）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80"><span class="toc-text">3. 事件基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%BA%8B%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1 事件概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E4%BA%8B%E4%BB%B6%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-text">3.2 事件三要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%89%A7%E8%A1%8C%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">3.3 执行事件的步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0"><span class="toc-text">4.操作元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9"><span class="toc-text">4.1 改变元素内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%B8%B8%E7%94%A8%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">4.2 常用元素的属性操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">4.3 表单元素的属性操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">4.4 样式属性操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">4.6 自定义属性的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-H5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-text">4.7 H5自定义属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AEH5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-text">1.设置H5自定义属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96H5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-text">2.获取H5自定义属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">5. 节点操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7"><span class="toc-text">5.1 节点层级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9"><span class="toc-text">5.4 创建节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#node-appendChild-child"><span class="toc-text">node.appendChild(child)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#node-insertBefore-child-%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0"><span class="toc-text">node.insertBefore(child, 指定元素)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#node-removeChild-child"><span class="toc-text">node.removeChild(child)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#node-cloneNode"><span class="toc-text">node.cloneNode()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-%E4%B8%89%E7%A7%8D%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0%E5%8C%BA%E5%88%AB"><span class="toc-text">5.8 三种动态创建元素区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-DOM-%E9%87%8D%E7%82%B9%E6%A0%B8%E5%BF%83"><span class="toc-text">6. DOM 重点核心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%88%9B%E5%BB%BA"><span class="toc-text">6.1 创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E5%A2%9E"><span class="toc-text">6.2 增</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E5%88%A0"><span class="toc-text">6.3 删</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E6%94%B9"><span class="toc-text">6.4 改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E6%9F%A5"><span class="toc-text">6.5 查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">6.6 属性操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-%E4%BA%8B%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">6.7 事件操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7"><span class="toc-text">18.事件高级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%EF%BC%88%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-text">1. 注册事件（绑定事件）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 注册事件概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-addEventListener-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2 addEventListener 事件监听方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-attachEvent-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8F-%E5%8F%AA%E8%83%BD%E5%9C%A8IE9-%E4%B9%8B%E5%89%8D%E4%BD%BF%E7%94%A8"><span class="toc-text">1.3 attachEvent 事件监听方式(只能在IE9 之前使用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E5%85%BC%E5%AE%B9%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">1.4 注册事件兼容性解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4%E4%BA%8B%E4%BB%B6%EF%BC%88%E8%A7%A3%E7%BB%91%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-text">2. 删除事件（解绑事件）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%88%A0%E9%99%A4%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">2.1 删除事件的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%88%A0%E9%99%A4%E4%BA%8B%E4%BB%B6%E5%85%BC%E5%AE%B9%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">2.2 删除事件兼容性解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-DOM-%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-text">3. DOM 事件流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">4. 事件对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.1 什么是事件对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-text">4.2 事件对象的使用语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">4.4 事件对象的常见属性和方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-text">5. 阻止事件冒泡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">5.1 阻止事件冒泡的两种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%BB%A3%E7%90%86%E3%80%81%E5%A7%94%E6%B4%BE%EF%BC%89"><span class="toc-text">6. 事件委托（代理、委派）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%B8%B8%E7%94%A8%E7%9A%843%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-text">7. 常用的3鼠标事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E5%B8%B8%E7%94%A8%E7%9A%84%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-text">7.1 常用的鼠标事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A6%81%E6%AD%A2%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95"><span class="toc-text">1.禁止鼠标右键菜单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A6%81%E6%AD%A2%E9%BC%A0%E6%A0%87%E9%80%89%E4%B8%AD%EF%BC%88selectstart-%E5%BC%80%E5%A7%8B%E9%80%89%E4%B8%AD%EF%BC%89"><span class="toc-text">2.禁止鼠标选中（selectstart 开始选中）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-text">8. 常用的键盘事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E5%B8%B8%E7%94%A8%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-text">8.1 常用键盘事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.2 键盘事件对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-BOM"><span class="toc-text">19.BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-BOM-%E6%A6%82%E8%BF%B0"><span class="toc-text">1. BOM 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF-BOM"><span class="toc-text">1.1 什么是 BOM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-BOM-%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-text">1.2 BOM 的构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-window-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6"><span class="toc-text">2. window 对象的常见事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%AA%97%E5%8F%A3%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6"><span class="toc-text">2.1 窗口加载事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%B0%83%E6%95%B4%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E4%BA%8B%E4%BB%B6"><span class="toc-text">2.2 调整窗口大小事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">3. 定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%B8%A4%E7%A7%8D%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">3.1 两种定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%81%9C%E6%AD%A2-setTimeout-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">3.3 停止 setTimeout() 定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%81%9C%E6%AD%A2-setInterval-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">3.5 停止 setInterval() 定时器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JS-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">4. JS 执行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-JS-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">4.1 JS 是单线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-text">4.2 同步和异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-text">4.3 同步和异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-JS-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">4.4 JS 执行机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-location-%E5%AF%B9%E8%B1%A1"><span class="toc-text">5. location 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AF-location-%E5%AF%B9%E8%B1%A1"><span class="toc-text">5.1 什么是 location 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-URL"><span class="toc-text">5.2 URL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-location-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">5.3 location 对象的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-location-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">5.4 location 对象的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-navigator-%E5%AF%B9%E8%B1%A1"><span class="toc-text">6. navigator 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-history-%E5%AF%B9%E8%B1%A1"><span class="toc-text">7. history 对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-text">20.本地存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-window-sessionStorage"><span class="toc-text">1.window.sessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-window-localStorage"><span class="toc-text">2.window.localStorage</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148432/" title="MyBatis 拦截器">MyBatis 拦截器</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148434/" title="MyBatis 集成druid数据源">MyBatis 集成druid数据源</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1166366203/" title="SQL调优">SQL调优</a><time datetime="2024-07-16T16:00:00.000Z" title="发表于 2024-07-17 00:00:00">2024-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3109398172/" title="ContextHolder">ContextHolder</a><time datetime="2024-07-11T16:00:00.000Z" title="发表于 2024-07-12 00:00:00">2024-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2889834893/" title="SpringCloud Feign">SpringCloud Feign</a><time datetime="2024-07-01T16:00:00.000Z" title="发表于 2024-07-02 00:00:00">2024-07-02</time></div></div></div></div></div></div></main><footer id="footer" style="background: #47577e"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '2N3fEF3CzNAzKwVbFlhSTUuM-gzGzoHsz',
      appKey: '9m41Klhi8IgsrNrbyMnoCHrN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>