<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java | Eric</title><meta name="author" content="Eric"><meta name="copyright" content="Eric"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Java语言概述1、Java技术体系平台 Java SE(Java Standard Edition)标准版   支持面向桌面级应用(如Windows下的应用程序)的Java平台，提供了完整的Java核心API，此版本以前称为J2SE   Java EE(Java Enterprise Edi"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://ericwjian.github.io/posts/3743959532/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4dfa2c883c8c4c23f4866185de932236";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-09 14:54:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Eric"><span class="site-name">Eric</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2017-07-11T16:00:00.000Z" title="发表于 2017-07-12 00:00:00">2017-07-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-09T06:54:57.177Z" title="更新于 2024-07-09 14:54:57">2024-07-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">51.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>196分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><hr>
<h2 id="一、Java语言概述"><a href="#一、Java语言概述" class="headerlink" title="一、Java语言概述"></a>一、Java语言概述</h2><h3 id="1、Java技术体系平台"><a href="#1、Java技术体系平台" class="headerlink" title="1、Java技术体系平台"></a>1、Java技术体系平台</h3><blockquote>
<p><code>Java SE</code>(Java Standard Edition)标准版</p>
</blockquote>
<ul>
<li>支持面向桌面级应用(如Windows下的应用程序)的Java平台，提供了完整的Java核心API，此版本以前称为J2SE</li>
</ul>
<blockquote>
<p><code>Java EE</code>(Java Enterprise Edition)企业版</p>
</blockquote>
<ul>
<li>是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet 、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE</li>
</ul>
<blockquote>
<p><code>Java ME</code>(Java Micro Edition)小型版</p>
</blockquote>
<ul>
<li>支持Java程序运行在移动终端（手机、PDA)上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME</li>
</ul>
<blockquote>
<p><code>Java Card</code></p>
</blockquote>
<ul>
<li>支持一些Java小程序(Applets )运行在小内存设备(如智能卡）上的平台</li>
</ul>
<h3 id="2、java程序编写-编译-运行的过程"><a href="#2、java程序编写-编译-运行的过程" class="headerlink" title="2、java程序编写-编译-运行的过程"></a>2、java程序编写-编译-运行的过程</h3><ul>
<li>编写：我们将编写的 java 代码保存在以”<code>.java</code>“结尾的源文件中。</li>
<li>编译：使用 javac.exe 命令编译我们的 java 源文件。格式：<code>javac 源文件名.java</code></li>
<li>运行：使用 java.exe 命令解释运行我们的字节码文件。 格式：java 类名</li>
</ul>
<h3 id="3、注释-Comment"><a href="#3、注释-Comment" class="headerlink" title="3、注释:Comment"></a>3、注释:Comment</h3><ol>
<li>单行注释：// </li>
<li>多行注释：/* */ </li>
<li>文档注释：/** */</li>
</ol>
<p><strong>作用</strong>：</p>
<p>① 对所写的程序进行解释说明，增强可读性。方便自己，方便别人</p>
<p>② 调试所写的代码</p>
<p><strong>特点</strong>：</p>
<p>① 单行注释和多行注释，注释了的内容不参与编译。 换句话说，编译以后生成的 <code>.class</code> 结尾的字节码文件中不包含注释掉的信息。</p>
<p>② 注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</p>
<p>③ 多行注释不可以嵌套使用。</p>
<h2 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h2><h3 id="1、关键字与保留字"><a href="#1、关键字与保留字" class="headerlink" title="1、关键字与保留字"></a>1、关键字与保留字</h3><h4 id="1、Java关键字"><a href="#1、Java关键字" class="headerlink" title="1、Java关键字"></a>1、Java关键字</h4><p>被Java语言赋予了特殊含义，用做专门用途的字符串（单词） 特点：关键字中所字母都为小写 具体关键字：</p>
<img src="/posts/3743959532/20200430110459.png" class="" title="image-20200430110458435">

<img src="/posts/3743959532/20200430110507.png" class="" title="image-20200430110505797">

<h4 id="2、-保留字"><a href="#2、-保留字" class="headerlink" title="2、 保留字"></a>2、 保留字</h4><p>现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字 </p>
<p><code>goto</code> 、<code>const</code>。</p>
<h3 id="2、标识符"><a href="#2、标识符" class="headerlink" title="2、标识符"></a>2、标识符</h3><ol>
<li>标识符：<ul>
<li>Java 对各种变量、方法和类等要素命名时使用的字符序列称为<code>标识符</code>。</li>
<li>技巧：凡是自己可以起名字的地方都叫标识符。</li>
</ul>
</li>
<li>定义合法标识符规则：<ul>
<li>由26个英文字母大小写，0-9 ，_或 $ 组成。</li>
<li>数字不可以开头。</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字。</li>
<li>Java中严格区分大小写，长度无限制。</li>
<li>标识符不能包含空格。</li>
</ul>
</li>
</ol>
<h3 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h3><h4 id="1、变量的分类"><a href="#1、变量的分类" class="headerlink" title="1、变量的分类"></a>1、变量的分类</h4><h5 id="1-按数据类型分类"><a href="#1-按数据类型分类" class="headerlink" title="1 按数据类型分类"></a>1 按数据类型分类</h5><img src="/posts/3743959532/image-20201222133503872.png" class="" title="image-20201222133503872">

<h5 id="2-按声明的位置的不同"><a href="#2-按声明的位置的不同" class="headerlink" title="2 按声明的位置的不同"></a>2 按声明的位置的不同</h5><ul>
<li>在方法体外，类体内声明的变量称为成员变量。 </li>
<li>在方法体内部声明的变量称为局部变量。</li>
</ul>
<img src="/posts/3743959532/image-20201222133716605.png" class="" title="image-20201222133716605">

<h5 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3 数据类型"></a>3 数据类型</h5><ul>
<li><p>整型：byte【1字节=8bit】、short【2字节】、int【4字节】、long【8字节】。</p>
<p>① byte 范围：-128 ~ 127。</p>
<p>② 声明 long 型变量，必须以<code>l</code>或<code>L</code>结尾。    </p>
<p>③ 通常，定义整型变量时，使用 int 型。</p>
</li>
<li><p>浮点型：float【4字节】、double【8字节】</p>
<p>① 浮点型，表示带小数点的数值。</p>
<p>② <code>float表示数值的范围比long还大</code>。</p>
<p>③ 定义float类型变量时，变量要以<code>f</code>或<code>F</code>结尾。</p>
<p>④ 通常，定义浮点型变量时，使用double型。</p>
<p>⑤ 浮点型的常量，默认类型为：double。</p>
</li>
<li><p>字符型：char【1字符=2字节】</p>
<p>① 定义char型变量，通常使用一对’’,内部只能写一个字符，<code>char c1 = &#39;A&#39;;</code>。</p>
<p>② 表示方式：</p>
<ol>
<li>声明一个字符  </li>
<li>转义字符 </li>
<li>直接使用 Unicode 值来表示字符型常量</li>
</ol>
</li>
<li><p>布尔型：boolean</p>
<p>① 只能取两个值之一：true 、 false</p>
<p>② 常常在条件判断、循环结构中使用</p>
</li>
</ul>
<h4 id="2、基本数据类型转换"><a href="#2、基本数据类型转换" class="headerlink" title="2、基本数据类型转换"></a>2、基本数据类型转换</h4><h5 id="1-自动类型转换："><a href="#1-自动类型转换：" class="headerlink" title="1 自动类型转换："></a>1 自动类型转换：</h5><p>容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：</p>
<img src="/posts/3743959532/image-20201222134359257.png" class="" title="image-20201222134359257">

<ul>
<li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。</li>
<li>byte、short、char 之间不会相互转换，他们三者在计算时首先转换为 int 类型。 </li>
<li>boolean 类型不能与其它数据类型运算。 </li>
<li>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。</li>
</ul>
<h5 id="2-强制类型转换"><a href="#2-强制类型转换" class="headerlink" title="2 强制类型转换"></a>2 强制类型转换</h5><ul>
<li><p>只涉及7种基本数据类型：自动类型提升运算的逆运算。</p>
</li>
<li><p>注意点：强制类型转换，可能导致精度损失。</p>
</li>
</ul>
<h5 id="3-String与8种基本数据类型间的运算"><a href="#3-String与8种基本数据类型间的运算" class="headerlink" title="3 String与8种基本数据类型间的运算"></a>3 String与8种基本数据类型间的运算</h5><ul>
<li>String不是基本数据类型，属于引用数据类型。 </li>
<li>使用方式与基本数据类型一致。例如：String str = “abcd”。 </li>
</ul>
<h3 id="4、运算符"><a href="#4、运算符" class="headerlink" title="4、运算符"></a>4、运算符</h3><ol>
<li>位运算符 <ul>
<li>位运算符操作的都是整型的数据。</li>
<li>&lt;&lt; ：在一定范围内，每向左移1位，相当于乘以2。 </li>
<li>&gt;&gt; ：在一定范围内，每向右移1位，相当于除以2。</li>
</ul>
</li>
</ol>
<h2 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h2><h3 id="1、数组的理解"><a href="#1、数组的理解" class="headerlink" title="1、数组的理解"></a>1、数组的理解</h3><p>数组(Array)，是多个相同类型数据一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;数据类型&gt;[] &lt;数组名&gt; = new &lt;数据类型&gt;[&lt;数组长度&gt;];</span></span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">String[] strings= <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">12</span>];</span><br><span class="line"><span class="comment">// 数据类型[]   数组的名字 = &#123;值1, 值2, 值3,...&#125;;</span></span><br><span class="line"><span class="type">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2、数组相关的概念"><a href="#2、数组相关的概念" class="headerlink" title="2、数组相关的概念"></a>2、数组相关的概念</h3><ul>
<li>数组名</li>
<li>元素 </li>
<li>角标、下标</li>
<li>索引 数组的长度：元素的个数</li>
</ul>
<h3 id="3、数组的特点"><a href="#3、数组的特点" class="headerlink" title="3、数组的特点"></a>3、数组的特点</h3><ol>
<li>数组是序排列的。</li>
<li>数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型。</li>
<li>创建数组对象会在内存中开辟一整块连续的空间。</li>
<li>数组的长度一旦确定，就不能修改。</li>
</ol>
<h3 id="4、数组的分类"><a href="#4、数组的分类" class="headerlink" title="4、数组的分类"></a>4、数组的分类</h3><p>① 按照维数：一维数组、二维数组、。。。</p>
<p>② 按照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组。</p>
<h3 id="5、数据结构"><a href="#5、数据结构" class="headerlink" title="5、数据结构"></a>5、数据结构</h3><ol>
<li>数据与数据之间的逻辑关系：<ul>
<li>集合（关系很弱）</li>
<li>一对一（数组里面的元素）</li>
<li>一对多（二叉树）</li>
<li>多对多（社交网络）</li>
</ul>
</li>
<li>数据的存储结构： <ul>
<li>线性表：顺序表（比如：数组）</li>
<li>链表</li>
<li>栈</li>
<li>队列 </li>
<li>树形结构：二叉树 </li>
<li>图形结构：</li>
</ul>
</li>
</ol>
<h3 id="6、数组的排序算法"><a href="#6、数组的排序算法" class="headerlink" title="6、数组的排序算法"></a>6、数组的排序算法</h3><ul>
<li>选择排序：<ul>
<li>直接选择排序、堆排序</li>
</ul>
</li>
<li>交换排序：<ul>
<li>冒泡排序、快速排序</li>
</ul>
</li>
<li>插入排序：<ul>
<li>直接插入排序、折半插入排序、希尔排序</li>
</ul>
</li>
<li>归并排序</li>
<li>桶排序</li>
<li>基数排序</li>
</ul>
<h3 id="7、Arrays-工具类的使用"><a href="#7、Arrays-工具类的使用" class="headerlink" title="7、Arrays 工具类的使用"></a>7、Arrays 工具类的使用</h3><ul>
<li><p>定义在java.util包下。 </p>
</li>
<li><p>Arrays:提供了很多操作数组的方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr1[] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">21</span>, <span class="number">43</span>, <span class="number">542</span>, <span class="number">432</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr2[] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">32</span>, <span class="number">43</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">76</span>, <span class="number">54</span>, <span class="number">68</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.Arrays.equals(arr1, arr2):判断数组是否相等</span></span><br><span class="line">    System.out.println(Arrays.equals(arr1, arr2));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.Arrays.toString(arr1):输出数组信息</span></span><br><span class="line">    System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.Arrays.fill(arr1, 2):将指定值填充到数组中</span></span><br><span class="line">    Arrays.fill(arr1, <span class="number">2</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.Arrays.sort(arr2):对数组进行排序</span></span><br><span class="line">    Arrays.sort(arr2);</span><br><span class="line">    System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.Arrays.binarySearch(arr2, 1):堆排序好的数组用二分法检索指定值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr2, <span class="number">4</span>);</span><br><span class="line">    System.out.println(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、数组的常见异常"><a href="#8、数组的常见异常" class="headerlink" title="8、数组的常见异常"></a>8、数组的常见异常</h3><ol>
<li><p>数组角标越界异常：</p>
<p>ArrayIndexOutOfBoundsException</p>
</li>
<li><p>空指针异常：</p>
<p>NullPointerException</p>
</li>
</ol>
<h2 id="四、面向对象-上"><a href="#四、面向对象-上" class="headerlink" title="四、面向对象(上)"></a>四、面向对象(上)</h2><h3 id="1、面向对象的三大特征"><a href="#1、面向对象的三大特征" class="headerlink" title="1、面向对象的三大特征"></a>1、面向对象的三大特征</h3><blockquote>
<p>Object Oriented Programming </p>
</blockquote>
<ul>
<li>封装 (Encapsulation) </li>
<li>继承 (Inheritance)</li>
<li>多态 (Polymorphism)</li>
</ul>
<h3 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h3><ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义。</li>
<li>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。</li>
</ul>
<p>可以理解为：</p>
<ul>
<li><code>类 = 抽象概念的人</code>；</li>
<li><code>对象 = 实实在在的某个人</code>。</li>
</ul>
<h3 id="3、类的成员"><a href="#3、类的成员" class="headerlink" title="3、类的成员"></a>3、类的成员</h3><p>属性：对应类中的成员变量。</p>
<p>行为：对应类中的成员方法。</p>
<h3 id="4、属性"><a href="#4、属性" class="headerlink" title="4、属性"></a>4、属性</h3><ol>
<li><p>语法格式：</p>
<ul>
<li>修饰符 数据类型 属性名 = 初始化值 ;</li>
</ul>
</li>
<li><p>说明1: 修饰符 </p>
<ul>
<li>常用的权限修饰符有：private、缺省、protected、public </li>
<li>其他修饰符：static、final </li>
</ul>
</li>
<li><p>说明2：数据类型 </p>
<ul>
<li>任何基本数据类型(如int、Boolean) 或 任何引用数据类型。 </li>
</ul>
</li>
<li><p>说明3：属性名 </p>
<ul>
<li>属于标识符，符合命名规则和规范即可。 </li>
</ul>
</li>
<li><p>成员变量和局部变量</p>
<ul>
<li>方法体外，类体内声明的变量称为成员变量。 </li>
<li>在方法体内部声明的变量称为局部变量。</li>
</ul>
</li>
</ol>
<img src="/posts/3743959532/image-20201222142505996.png" class="" title="image-20201222142505996">

<h3 id="5、方法"><a href="#5、方法" class="headerlink" title="5、方法"></a>5、方法</h3><h4 id="1、什么是方法"><a href="#1、什么是方法" class="headerlink" title="1、什么是方法"></a>1、什么是方法</h4><ul>
<li>方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中 也称为函数或过程。 </li>
<li>将功能封装为方法的目的是，可以实现代码重用，简化代码 </li>
<li>Java里的方法不能独立存在，所有的方法必须定义在类里</li>
</ul>
<h4 id="2、方法的重载-overload"><a href="#2、方法的重载-overload" class="headerlink" title="2、方法的重载(overload)"></a>2、方法的重载(overload)</h4><blockquote>
<p>重载的概念 </p>
</blockquote>
<ul>
<li>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 </li>
</ul>
<blockquote>
<p>重载的特点： </p>
</blockquote>
<ul>
<li>与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。 </li>
</ul>
<h4 id="3、可变个数的形参"><a href="#3、可变个数的形参" class="headerlink" title="3、可变个数的形参"></a>3、可变个数的形参</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量 </span></span><br><span class="line"><span class="comment">//这个形参必须是形参列表的最后一个，编译器会把可变参数变为数组类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a ,String… books)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4、封装和隐藏"><a href="#4、封装和隐藏" class="headerlink" title="4、封装和隐藏"></a>4、封装和隐藏</h4><ul>
<li>Java中通过将数据声明为私有的(private)，再提供公共的(public)方法：getXxx()和setXxx()实现对该属性的操作。</li>
</ul>
<h3 id="6、构造器"><a href="#6、构造器" class="headerlink" title="6、构造器"></a>6、构造器</h3><h4 id="1、构造器的特征"><a href="#1、构造器的特征" class="headerlink" title="1、构造器的特征"></a>1、构造器的特征</h4><ul>
<li>它具有与类相同的名称。</li>
<li>它不声明返回值类型，【与声明为void不同】。</li>
<li>不能被 static、final、synchronized、abstract、native修饰，不能有 return语句返回值。</li>
</ul>
<h4 id="2、构造器的作用"><a href="#2、构造器的作用" class="headerlink" title="2、构造器的作用"></a>2、构造器的作用</h4><p>​    创建对象；给对象进行初始化 。</p>
<h4 id="3、构造器的分类"><a href="#3、构造器的分类" class="headerlink" title="3、构造器的分类"></a>3、构造器的分类</h4><ul>
<li>隐式无参构造器（系统默认提供）。 </li>
<li>显式定义一个或多个构造器（无参、有参）。</li>
</ul>
<h4 id="4、构造器重载"><a href="#4、构造器重载" class="headerlink" title="4、构造器重载"></a>4、构造器重载</h4><ol>
<li><p>构造器一般用来创建对象的同时初始化对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n,<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        name=n; </span><br><span class="line">    	age=a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器重载举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age,Date d)</span> &#123;<span class="built_in">this</span>(name,age);...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span> &#123;....&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,Date d)</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>构造器重载，参数列表必须不同</p>
</li>
</ol>
<h3 id="7、this关键字"><a href="#7、this关键字" class="headerlink" title="7、this关键字"></a>7、this关键字</h3><ul>
<li>它在方法内部使用，即这个方法所属对象的引用； </li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象。 </li>
</ul>
<img src="/posts/3743959532/image-20201222145841058.png" class="" title="image-20201222145841058">

<p>常见用法：</p>
<ol>
<li><p>使用this，调用属性、方法</p>
</li>
<li><p>使用this调用本类的构造器</p>
</li>
</ol>
<h2 id="五、面向对象-中"><a href="#五、面向对象-中" class="headerlink" title="五、面向对象(中)"></a>五、面向对象(中)</h2><h3 id="1、继承性"><a href="#1、继承性" class="headerlink" title="1、继承性"></a>1、继承性</h3><h4 id="1、为什么要有继承"><a href="#1、为什么要有继承" class="headerlink" title="1、为什么要有继承"></a>1、为什么要有继承</h4><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中， 那么多个类中无需再定义这些属性和行为，只要继承那个类即可。</p>
<h4 id="2、作用："><a href="#2、作用：" class="headerlink" title="2、作用："></a>2、作用：</h4><ul>
<li>继承的出现减少了代码冗余，提高了代码的复用性。 </li>
<li>继承的出现，更有利于功能的扩展。 </li>
<li>继承的出现让类与类之间产生了关系，提供了多态的前提。</li>
<li><code>注意：不要仅为了获取其他类中某个功能而去继承</code>。</li>
</ul>
<h4 id="3、注意"><a href="#3、注意" class="headerlink" title="3、注意"></a>3、注意</h4><ul>
<li><p>子类继承了父类，就继承了父类的方法和属性。 </p>
</li>
<li><p>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。 </p>
</li>
<li><p>在Java 中，继承的关键字用的是 <code>extends</code>，即子类不是父类的子集， 而是对父类的<code>扩展</code>。</p>
</li>
<li><p>子类不能直接访问父类中私有的(private)的成员变量和方法。</p>
</li>
<li><p> Java只支持单继承和多层继承，不允许多重继承 。</p>
</li>
</ul>
<h4 id="4、方法的重写"><a href="#4、方法的重写" class="headerlink" title="4、方法的重写"></a>4、方法的重写</h4><h5 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h5><p>在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。</p>
<h5 id="2、要求"><a href="#2、要求" class="headerlink" title="2、要求"></a>2、要求</h5><ol>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表。</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型。</li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限。<ul>
<li>子类不能重写父类中声明为private权限的方法 。</li>
</ul>
</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常 。</li>
</ol>
<h5 id="3、-注意"><a href="#3、-注意" class="headerlink" title="3、 注意"></a>3、 注意</h5><p>子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为 static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</p>
<p><code>override是覆盖，子类覆盖父类的方法。 overwrite是重写，同一类内，同名不同参的方法.</code></p>
<h4 id="5、关键字：super"><a href="#5、关键字：super" class="headerlink" title="5、关键字：super"></a>5、关键字：super</h4><p>1、在Java类中使用super来调用父类中的指定操作</p>
<ul>
<li>super可用于访问父类中定义的属性。</li>
<li>super可用于调用父类中定义的成员方法。</li>
<li>super可用于在子类构造器中调用父类的构造器。</li>
</ul>
<p>2、注意： </p>
<ul>
<li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员。</li>
<li>super的追溯不仅限于直接父类。</li>
<li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识。</li>
</ul>
<img src="/posts/3743959532/image-20201222151535291.png" class="" width="20201222151535291">

<h3 id="2、多态性"><a href="#2、多态性" class="headerlink" title="2、多态性"></a>2、多态性</h3><h4 id="1、多态性是什么"><a href="#1、多态性是什么" class="headerlink" title="1、多态性是什么"></a>1、多态性是什么</h4><p>多态性，是面向对象中最重要的概念，在Java中的体现</p>
<ul>
<li>对象的多态性：<code>父类引用指向子类对象</code> 。</li>
<li>Person p2 = new Man();</li>
<li>p2.eat()  </li>
<li>多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法</li>
</ul>
<p><code>虚拟方法调用(Virtual Method Invocation)</code></p>
<p>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</p>
<blockquote>
<p>总结:编译，看左边；运行，看右边。</p>
</blockquote>
<p>多态性的使用前提:</p>
<ul>
<li>类的继承关系。</li>
<li>方法的重写。</li>
</ul>
<blockquote>
<p>运行的时候 动态绑定。</p>
</blockquote>
<p>多态性只体现在方法上，不适用于属性！</p>
<h4 id="2、instanceof-操作符"><a href="#2、instanceof-操作符" class="headerlink" title="2、instanceof 操作符"></a>2、instanceof 操作符</h4><p><code>boolean b = p instanceof Man;</code>，检验 p 是否为类 Man 的对象，返回值为boolean型。 </p>
<h3 id="3、Object类的使用"><a href="#3、Object类的使用" class="headerlink" title="3、Object类的使用"></a>3、Object类的使用</h3><ul>
<li>Object 类是所有Java类的根父类。</li>
<li>如果在类的声明中未使用 extends 关键字指明其父类，则默认父类 为 java.lang.Object 类。</li>
</ul>
<h3 id="4、-操作符与equals方法"><a href="#4、-操作符与equals方法" class="headerlink" title="4、==操作符与equals方法"></a>4、==操作符与equals方法</h3><ol>
<li>==<ul>
<li>基本类型：比较值，只要两个变量的值相等，即为true。 </li>
<li>引用类型：比较引用(是否指向同一个对象)，只有指向同一个对象时，== 才返回true。</li>
</ul>
</li>
<li> equals()：</li>
</ol>
<ul>
<li>只能比较引用类型，其作用与<code>==</code>相同，比较是否指向同一个对象。 </li>
<li>obj1.equals(obj2)；</li>
</ul>
<h2 id="六、面向对象-下"><a href="#六、面向对象-下" class="headerlink" title="六、面向对象(下)"></a>六、面向对象(下)</h2><h3 id="1、static"><a href="#1、static" class="headerlink" title="1、static"></a>1、static</h3><p>当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过 new 关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少 对象的情况下，<code>某些特定的数据在内存空间里只有一份</code>，例如所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。</p>
<ol>
<li>在Java类中，可用 static 修饰属性、方法、代码块、内部类。</li>
<li>使用 static 修饰属性：静态变量（类变量）<ul>
<li>属性：按照是否使用static 修饰，又分为<code>静态属性</code>（静态变量），<code>非静态属性</code>（实例变量）。</li>
<li>实例变量：我们创建了类的对个对象，每个对象都有独立的拥有一套类中的非静态属性，当修改其中一个对象的非静态属性时，不会导致其他对象中同样属性值的修改。</li>
<li>静态变量：我们创建了多个对象，多个对象共享同一个静态变量，当通过某一个对象修改静态属性时，会导致其他对象调用此静态变量时，是修改过了的。<ul>
<li>静态变量随着类的加载而加载。</li>
<li>静态变量的加载早于对象的创建。</li>
<li>由于类只会加载一次，则静态变量只会在内存中存在一份，存在方法区静态域中。</li>
</ul>
</li>
</ul>
</li>
<li>使用static 修饰方法<ul>
<li>随着类的加载而加载，可以通过 “类.静态方法”的方式进行调用。</li>
<li>静态方法中，只能调用静态的方法或属性，非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性。</li>
</ul>
</li>
<li>static 注意点<ul>
<li>在静态的方法内，<code>不能使用</code> this关键字、super关键字。</li>
<li>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</li>
</ul>
</li>
</ol>
<h3 id="2、单例设计模式"><a href="#2、单例设计模式" class="headerlink" title="2、单例设计模式"></a>2、单例设计模式</h3><p><code>单例设计模式</code>： 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对 某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。 </p>
<p>1、单例(Singleton)设计模式-饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line">    <span class="comment">// 1.私有化构造器（不能在外部构造对象） </span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">	<span class="comment">// 2.内部提供一个当前类的实例 </span></span><br><span class="line">    <span class="comment">// 4.此实例也必须静态化 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	<span class="comment">// 3.提供公共的静态的方法，返回当前类的对象 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> single; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、单例(Singleton)设计模式-懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line">    <span class="comment">// 1.私有化构造器 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125; </span><br><span class="line">    <span class="comment">// 2.内部提供一个当前类的实例 </span></span><br><span class="line">    <span class="comment">// 4.此实例也必须静态化 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single; </span><br><span class="line">    <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">null</span>) &#123; </span><br><span class="line">            single = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> single; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例模式的优点： 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的 产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可 以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方 式来解决。</p>
<h3 id="3、代码块"><a href="#3、代码块" class="headerlink" title="3、代码块"></a>3、代码块</h3><ol>
<li>代码块(或初始化块)的作用： <ul>
<li>对Java类或对象进行初始化</li>
</ul>
</li>
<li>代码块(或初始化块)的分类： <ul>
<li>一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块 (static block)，没有使用static修饰的，为非静态代码块。 </li>
<li>静态代码块<ul>
<li>被static修饰，只执行一次。</li>
</ul>
</li>
<li>非静态代码块<ul>
<li>没有使用static修饰，随着类的创建而执行（创建多少个类就执行多少次）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="4、final"><a href="#4、final" class="headerlink" title="4、final"></a>4、final</h3><p>在Java中声明类、变量和方法时，可使用关键字final来修饰,表示<code>最终的</code>。 </p>
<ol>
<li><p>final标记的类不能被继承。提高安全性，提高程序的可读性。</p>
</li>
<li><p>final标记的方法不能被子类重写。 </p>
</li>
<li><p>final标记的变量(成员变量或局部变量)即称为常量。名称大写，且只 能被赋值一次。 </p>
<ul>
<li>final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。 </li>
<li>final double MY_PI = 3.14;</li>
</ul>
</li>
</ol>
<h3 id="5、抽象类和抽象方法"><a href="#5、抽象类和抽象方法" class="headerlink" title="5、抽象类和抽象方法"></a>5、抽象类和抽象方法</h3><blockquote>
<p><strong>抽象类</strong></p>
</blockquote>
<p>在编写类时，多个类具有相同的属性、方法，但是方法内部实现代码不一样，可以将相同特征抽取到一个父类中，子类只需要继承该父类，即可具有重复的特征，子类只需要新的特征即可。<code>如果这样的父类通常作为模板来存在，该父类的用途是用于被子类继承，提高代码的复用性，该父类并不会被直接创建为对象，那么该父类被定义为抽象类。</code></p>
<ul>
<li><p><code>抽象类不能被直接创建对象实例，只能被子类继承。</code></p>
</li>
<li><p><code>普通类是描述对象的某一类事物的抽象，而抽象类则是更高层次对具有相同特征的一批普通类进行抽象。</code></p>
</li>
<li><p><code>抽象类使用abstract修饰符修饰。</code></p>
</li>
</ul>
<blockquote>
<p>抽象方法</p>
</blockquote>
<p>在抽象类中定义子类共有的方法，但是每个子类对该方法的实现代码都不一样，也就是说抽象定义的某个方法的功能无法满足所有子类的需求，那么就将该方法定义为抽象方法，在抽象方法中不提供具体的实现功能，将实现的细节交个不同的子类去实现，抽象类只是定义了子类该具有的方法，至于方法体抽象类步提供，由子类去编写专属于子类自己的业务逻辑。</p>
<ul>
<li><p><code>抽象方法使用abstract修饰符去修饰，抽象方法没有方法体。</code></p>
</li>
<li><p><code>子类继承了抽象类，就必须重写抽象类中的所有抽象方法。</code></p>
</li>
</ul>
<p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做<code>抽象类</code>。</p>
<ol>
<li>用 abstract 关键字来修饰一个类，这个类叫做抽象类。 </li>
<li>用 abstract 来修饰一个方法，该方法叫做抽象方法。 <ul>
<li>抽象方法：只有方法的声明，没有方法的实现。以分号结束： </li>
<li>比如：public abstract void talk(); </li>
</ul>
</li>
<li><code>含有抽象方法的类必须被声明为抽象类</code>。 </li>
<li> <code>抽象类不能被实例化</code>。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。 </li>
<li>不能用abstract修饰变量、代码块、构造器； </li>
<li>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</li>
</ol>
<h3 id="6、接口"><a href="#6、接口" class="headerlink" title="6、接口"></a>6、接口</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><ul>
<li>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方 法。但是Java不支持多重继承。有了接口，就可以得到多重继承的效果。</li>
<li>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有 is-a 的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打 印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。 </li>
<li><code>接口就是规范，定义的是一组规则</code>，体现了现实世界中“如果你是/要…则必须能…”的思想。<code>继承是一个&quot;是不是&quot;的关系，而接口实现则是 &quot;能不能&quot; 的关系</code>。</li>
<li><code>接口的本质是契约，标准，规范</code>，就像我们的法律一样。制定好后大家都 要遵守。</li>
</ul>
<h4 id="2、接口的特定"><a href="#2、接口的特定" class="headerlink" title="2、接口的特定"></a>2、接口的特定</h4><ul>
<li>用interface来定义。 </li>
<li>接口中的所有成员变量都默认是由public static final修饰的。 </li>
<li>接口中的所有抽象方法都默认是由public abstract修饰的。 </li>
<li><code>接口中没有构造器</code>。 </li>
<li>接口采用多继承机制</li>
</ul>
<h4 id="3、代理模式-Proxy"><a href="#3、代理模式-Proxy" class="headerlink" title="3、代理模式(Proxy)"></a>3、代理模式(Proxy)</h4><h4 id="4、内部类"><a href="#4、内部类" class="headerlink" title="4、内部类"></a>4、内部类</h4><h2 id="七、异常处理"><a href="#七、异常处理" class="headerlink" title="七、异常处理"></a>七、异常处理</h2><h3 id="1、异常体系结构"><a href="#1、异常体系结构" class="headerlink" title="1、异常体系结构"></a>1、异常体系结构</h3><p>Java程序在执行过程中所发生的异常事件可分为两类： </p>
<p>1、Error： Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如： StackOverflowError和OOM。一般不编写针对性的代码进行处理。</p>
<p>2、Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：</p>
<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ul>
<h3 id="2、常见异常"><a href="#2、常见异常" class="headerlink" title="2、常见异常"></a>2、常见异常</h3><h3 id="3、try-catch-finally"><a href="#3、try-catch-finally" class="headerlink" title="3、try-catch-finally"></a>3、try-catch-finally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="comment">//可能出现异常的代码</span></span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">  		<span class="comment">//处理异常的方式1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line"> 		<span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line">  		<span class="comment">//处理异常的方式3</span></span><br><span class="line">&#125;</span><br><span class="line"> ....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">  		<span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、throws"><a href="#4、throws" class="headerlink" title="4、throws"></a>4、throws</h3><p>try-catch-finally:真正的将异常给处理掉了。 throws的方式只是将异常抛给了方法的调用者。<code>并没真正将异常处理掉</code>。</p>
<h3 id="5、手动抛出异常对象"><a href="#5、手动抛出异常对象" class="headerlink" title="5、手动抛出异常对象"></a>5、手动抛出异常对象</h3><p>throw 和 throws区别： throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。 throws 属于异常处理的一种方式，声明在方法的声明处。</p>
<h3 id="6、自定义异常类"><a href="#6、自定义异常类" class="headerlink" title="6、自定义异常类"></a>6、自定义异常类</h3><h4 id="1-如何自定义异常类"><a href="#1-如何自定义异常类" class="headerlink" title="1.如何自定义异常类"></a>1.如何自定义异常类</h4><ol>
<li>继承于现有的异常结构：RuntimeException 、Exception。</li>
<li>提供全局常量：serialVersionUID（对类的唯一标识）。</li>
<li>提供重载的构造器。</li>
</ol>
<h4 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2.代码示例"></a>2.代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7034897193246939L</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、多线程"><a href="#八、多线程" class="headerlink" title="八、多线程"></a>八、多线程</h2><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><ul>
<li><p>程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一 段静态的代码，静态对象。 </p>
</li>
<li><p>进程(process)是程序的一次执行过程，或是<code>正在运行的一个程序</code>。是一个动态 的过程：有它自身的产生、存在和消亡的过程。——生命周期</p>
<ul>
<li>如：运行中的QQ，运行中的MP3播放器 </li>
<li>程序是静态的，进程是动态的 </li>
<li><code>进程作为资源分配的单位</code>，系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
</li>
<li><p>线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。 </p>
<ul>
<li>若一个进程同一时间并行执行多个线程，就是支持多线程的 </li>
<li><code>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)</code>，线程切换的开 销小 </li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象，可以 访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资 源可能就会带来安全的隐患。</li>
</ul>
</li>
</ul>
<h3 id="2、线程的创建和使用"><a href="#2、线程的创建和使用" class="headerlink" title="2、线程的创建和使用"></a>2、线程的创建和使用</h3><ul>
<li>Java语言的JVM允许程序运行多个线程，它通过<code>java.lang.Thread</code> 类来体现。</li>
</ul>
<h4 id="1、方式一-继承于Thread类"><a href="#1、方式一-继承于Thread类" class="headerlink" title="1、方式一:继承于Thread类"></a>1、方式一:继承于Thread类</h4><h5 id="1、使用方法"><a href="#1、使用方法" class="headerlink" title="1、使用方法"></a>1、使用方法</h5><ol>
<li><p>创建一个继承于Thread类的子类</p>
</li>
<li><p><code>重写Thread类的run()</code></p>
</li>
<li><p>创建Thread类的子类的对象</p>
</li>
<li><p>通过此对象调用start()</p>
</li>
</ol>
<h5 id="2、注意事项"><a href="#2、注意事项" class="headerlink" title="2、注意事项"></a>2、注意事项</h5><ol>
<li><p>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。</p>
</li>
<li><p>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU<br>调度决定。</p>
</li>
<li><p>想要启动多线程，必须调用start方法。</p>
</li>
<li><p>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上 的异常“IllegalThreadStateException”。</p>
</li>
</ol>
<h5 id="3、Thread-类的常用方法"><a href="#3、Thread-类的常用方法" class="headerlink" title="3、Thread 类的常用方法"></a>3、Thread 类的常用方法</h5><ul>
<li>void start():  启动线程，并执行对象的run()方法 </li>
<li>run():  线程在被调度时执行的操作 </li>
<li>String getName():  返回线程的名称 </li>
<li>void setName(String name):设置该线程名称 </li>
<li>static Thread currentThread(): 返回当前线程。在Thread子类中就 是this，通常用于主线程和Runnable实现类</li>
<li>static  void  yield()（礼让）：线程让步 <ul>
<li>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程 </li>
<li>若队列中没有同优先级的线程，忽略此方法 </li>
</ul>
</li>
<li>join() （插队）：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将 被阻塞，直到 join() 方法加入的 join 线程执行完为止 <ul>
<li>低优先级的线程也可以获得执行 </li>
</ul>
</li>
<li>static  void  sleep(long millis)：(指定时间:毫秒) <ul>
<li>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后 重排队。 </li>
<li>抛出InterruptedException异常</li>
</ul>
</li>
</ul>
<h4 id="2、实现Runnable接口"><a href="#2、实现Runnable接口" class="headerlink" title="2、实现Runnable接口"></a>2、实现Runnable接口</h4><h5 id="1、使用方法-1"><a href="#1、使用方法-1" class="headerlink" title="1、使用方法"></a>1、使用方法</h5><ol>
<li><p>定义子类，实现Runnable接口。 </p>
</li>
<li><p>子类中重写Runnable接口中的run方法。 </p>
</li>
<li><p>通过Thread类含参构造器创建线程对象。 </p>
</li>
<li><p>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</p>
</li>
<li><p>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。</p>
</li>
</ol>
<h3 id="3、两种方式的对比"><a href="#3、两种方式的对比" class="headerlink" title="3、两种方式的对比"></a>3、两种方式的对比</h3><p>1、区别 </p>
<ul>
<li>继承Thread：线程代码存放Thread子类run方法中。 </li>
<li>实现Runnable：线程代码存在接口的子类的run方法。 </li>
</ul>
<p>2、实现方式的好处 </p>
<ul>
<li>避免了单继承的局限性 </li>
<li>多个线程可以共享同一个接口实现类的对象，非常适合多个相同线 程来处理同一份资源。</li>
</ul>
<h3 id="4、线程的生命周期"><a href="#4、线程的生命周期" class="headerlink" title="4、线程的生命周期"></a>4、线程的生命周期</h3><p>Thread.State类定义了线程的几种状态</p>
<ul>
<li>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建 状态 </li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已 具备了运行的条件，只是没分配到CPU资源 </li>
<li>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线 程的操作和功能 </li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中 止自己的执行，进入阻塞状态 </li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<img src="/posts/3743959532/image-20201223103450241.png" class="" title="image-20201223103450241">

<h3 id="5、线程的同步"><a href="#5、线程的同步" class="headerlink" title="5、线程的同步"></a>5、线程的同步</h3><h4 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h4><p>例子：创建个窗口卖票，总票数为100张.使用实现Runnable接口的方式</p>
<ul>
<li>问题：卖票过程中，出现了重票、错票 –&gt;出现了线程的安全问题</li>
<li>问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。</li>
<li>如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。</li>
</ul>
<h4 id="2、Java解决方案：同步机制"><a href="#2、Java解决方案：同步机制" class="headerlink" title="2、Java解决方案：同步机制"></a>2、Java解决方案：同步机制</h4><p>在Java中，我们通过同步机制，来解决线程的安全问题。</p>
<h5 id="1、方式一：同步代码块"><a href="#1、方式一：同步代码块" class="headerlink" title="1、方式一：同步代码块"></a>1、方式一：同步代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;<span class="comment">//同步监视器就是需要同步线程的公共对象</span></span><br><span class="line">   <span class="comment">//需要被同步的代码   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li>操作共享数据的代码，即为需要被同步的代码。 –&gt;不能包含代码多了，也不能包含代码少了。</li>
<li>共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。</li>
<li>同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。</li>
<li>要求多个线程必须要共用同一把锁。</li>
</ol>
<ul>
<li>在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</li>
<li>在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wj.Object;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号窗口买票，票号为：&quot;</span> + tick--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        thread3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2、方式二：同步方法"><a href="#2、方式二：同步方法" class="headerlink" title="2、方式二：同步方法"></a>2、方式二：同步方法</h5><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String namer)</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isFlag) &#123;</span><br><span class="line">            show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;<span class="comment">//同步show方法，继承Thread类方法一样，只需同步方法即可，同时需要给方法加static关键字，确保不会创建多个对象</span></span><br><span class="line">        <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号窗口买票，票号为：&quot;</span> + tick--);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isFlag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket3</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket3</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        thread3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、线程的同步问题"><a href="#3、线程的同步问题" class="headerlink" title="3、线程的同步问题"></a>3、线程的同步问题</h4><h5 id="1、单例模式，懒汉式-线程不安全的"><a href="#1、单例模式，懒汉式-线程不安全的" class="headerlink" title="1、单例模式，懒汉式-线程不安全的"></a>1、单例模式，懒汉式-线程不安全的</h5><h5 id="2、线程的死锁问题"><a href="#2、线程的死锁问题" class="headerlink" title="2、线程的死锁问题"></a>2、线程的死锁问题</h5><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃 自己需要的同步资源，就形成了线程的死锁 </p>
<p>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于 阻塞状态，无法继续 </p>
<p><strong>解决方法</strong> </p>
<ul>
<li>专门的算法、原则 </li>
<li>尽量减少同步资源的定义 </li>
<li>尽量避免嵌套同步</li>
</ul>
<h4 id="4、Lock锁"><a href="#4、Lock锁" class="headerlink" title="4、Lock锁"></a>4、Lock锁</h4><ul>
<li><p>从JDK 5.0开始，Java提供了更强大的线程同步机制–通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</p>
</li>
<li><p>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p>
</li>
<li><p>ReentrantLock类实现了Lock，它拥有与 synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 Reentrantlock，可以显式加锁、释放锁。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//2.调用锁定方法lock()</span></span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：售票，票号为：&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//3.调用解锁方法：unlock()</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Window</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、面试题"><a href="#5、面试题" class="headerlink" title="5、面试题"></a>5、面试题</h4><h5 id="1、synchronized-与-Lock的异同？"><a href="#1、synchronized-与-Lock的异同？" class="headerlink" title="1、synchronized 与 Lock的异同？"></a>1、synchronized 与 Lock的异同？</h5><ol>
<li><p>相同：二者都可以解决线程安全问题</p>
</li>
<li><p>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器</p>
</li>
<li><p>Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()）</p>
</li>
<li><p>使用的优先顺序：</p>
<p>Lock—&gt; 同步代码块（已经进入了方法体，分配了相应资源 ) —&gt;同步方法（在方法体之外)</p>
</li>
<li><p>利弊： 同步的方式，解决了线程的安全问题。—好处 操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。</p>
</li>
</ol>
<h5 id="2、Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同"><a href="#2、Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同" class="headerlink" title="2、Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同"></a>2、Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同</h5><p>利用同步锁的方式，有三种方式同步代码块、同步方法和用lock方法</p>
<h3 id="6、线程的通讯"><a href="#6、线程的通讯" class="headerlink" title="6、线程的通讯"></a>6、线程的通讯</h3><p>为了解决线程的死锁问题，引入线程通讯</p>
<h4 id="1-线程通信涉及到的三个方法："><a href="#1-线程通信涉及到的三个方法：" class="headerlink" title="1. 线程通信涉及到的三个方法："></a>1. 线程通信涉及到的三个方法：</h4><ul>
<li>wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。</li>
<li>notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。</li>
<li>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</li>
</ul>
<h4 id="2-说明："><a href="#2-说明：" class="headerlink" title="2. 说明："></a>2. 说明：</h4><ul>
<li><p>wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。</p>
</li>
<li><p>wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。</p>
<p>否则，会出现IllegalMonitorStateException异常</p>
</li>
<li><p>wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。</p>
</li>
</ul>
<p><strong>代码示例：</strong></p>
<p>使用两个线程打印 1-100，线程1, 线程2 交替打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                object.notify();<span class="comment">//调用notify()方法唤醒线程</span></span><br><span class="line">                <span class="keyword">if</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="comment">//线程休眠</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + number);</span><br><span class="line">                    number++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();<span class="comment">//打印输出一次后调用wait()方法将线程阻塞</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommunicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;线程1:&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;线程2:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、面试题"><a href="#3、面试题" class="headerlink" title="3、面试题"></a>3、面试题</h4><p>sleep() 和 wait()的异同？</p>
<p>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</p>
<p>不同点：</p>
<p>1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</p>
<p>2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</p>
<p>3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</p>
<h4 id="4、生产者消费者问题"><a href="#4、生产者消费者问题" class="headerlink" title="4、生产者消费者问题"></a>4、生产者消费者问题</h4><p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处 取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图 生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通 知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如 果店中有产品了再通知消费者来取走产品。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wj.PC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produceProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count&lt;<span class="number">20</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:开始生产第&quot;</span>+count+<span class="string">&quot;个产品！&quot;</span>);</span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consumeProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:开始消费第&quot;</span>+count+<span class="string">&quot;个产品！&quot;</span>);</span><br><span class="line">            count--;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;:开始生产产品~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.produceProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;:开始消费产品~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.consumeProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line">        p1.setName(<span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        c1.setName(<span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        c2.setName(<span class="string">&quot;消费者2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7、新增线程创建方式"><a href="#7、新增线程创建方式" class="headerlink" title="7、新增线程创建方式"></a>7、新增线程创建方式</h3><h4 id="1、新增方式一：实现Callable接口"><a href="#1、新增方式一：实现Callable接口" class="headerlink" title="1、新增方式一：实现Callable接口"></a>1、新增方式一：实现Callable接口</h4><ul>
<li>创建一个实现Callable的实现类</li>
<li>实现call方法，将此线程需要执行的操作声明在call()中</li>
<li>创建Callable接口实现类的对象</li>
<li>将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</li>
<li>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</li>
<li>获取Callable中call方法的返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</strong></p>
<ol>
<li>call()可以返回值的。</li>
<li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li>
<li>Callable是支持泛型的</li>
</ol>
<h4 id="2、新增方式二：使用线程池"><a href="#2、新增方式二：使用线程池" class="headerlink" title="2、新增方式二：使用线程池"></a>2、新增方式二：使用线程池</h4><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程对性能影响很大。</p>
<p><strong>解决方案：</strong></p>
<p>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p>
<p><strong>实现方法：</strong></p>
<ol>
<li>提供指定线程数量的线程池</li>
<li>执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</li>
<li>关闭连接池</li>
</ol>
<p><strong>相关API：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JDK <span class="number">5.0</span>起提供了线程池相关AP|： Executor Service和 Executors</span><br><span class="line"></span><br><span class="line">Executor Service：真正的线程池接口。常见子类 Thread Poolexecutor</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command）：执行任务/命令，没有返回值，一般用来执行Runnable</span></span><br><span class="line"><span class="params">&lt;T&gt; Future&lt;T&gt; submit（Callable&lt;T&gt;task）：执行任务，有返回值，一般又来执行Callable</span></span><br><span class="line"><span class="params"><span class="keyword">void</span> shutdown()</span>：关闭连接池</span><br><span class="line"></span><br><span class="line">Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</span><br><span class="line">Executors. newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</span><br><span class="line">Executors.newFⅸedthreadPool(n)；创建一个可重用固定线程数的线程池</span><br><span class="line">EXecutors. newSingleThreadEXecutor()：创建一个只有一个线程的线程池</span><br><span class="line">Executors. <span class="keyword">new</span> <span class="title class_">thread</span> Poo(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//        service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//        service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用线程池的好处：</strong></p>
<ol>
<li><p>提高响应速度（减少了创建新线程的时间）</p>
</li>
<li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p>
</li>
<li><p>便于线程管理</p>
<p>corePoolSize：核心池的大小</p>
<p>maximumPoolSize：最大线程数</p>
<p>keepAliveTime：线程没任务时最多保持多长时间后会终止</p>
</li>
</ol>
<h3 id="8、面试题："><a href="#8、面试题：" class="headerlink" title="8、面试题："></a>8、面试题：</h3><p>Java中多线程的创建有几种方式？四种。</p>
<p>JDK 5.0以前：</p>
<ul>
<li>即继承Thread类重run方法</li>
<li>实现Runnable接口实现run方法</li>
</ul>
<p>JDK 5.0以后：</p>
<ul>
<li>实现callable接口，实现call方法</li>
<li>利用线程池</li>
</ul>
<h2 id="九、Java常用类"><a href="#九、Java常用类" class="headerlink" title="九、Java常用类"></a>九、Java常用类</h2><h3 id="1、String类"><a href="#1、String类" class="headerlink" title="1、String类"></a>1、String类</h3><p>java.lang.String类的使用</p>
<h4 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h4><p>String:字符串，使用一对<code>&quot;&quot;</code>引起来表示。</p>
<ol>
<li>String声明为final的，不可被继承</li>
<li>String 实现了Serializable接口：表示字符串是支持序列化的。 实现了Comparable接口：表示String可以比较大小</li>
<li>String内部定义了final char[] value用于存储字符串数据</li>
<li>String:代表不可变的字符序列。简称：不可变性。<ul>
<li><strong>体现：</strong></li>
<li>4.1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>4.2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>4.3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
</ul>
</li>
<li>通过字面量的方式（区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中)。</li>
<li>字符串常量池中是不会存储相同内容(使用String类的equals()比较，返回true)的字符串的)。</li>
</ol>
<h4 id="2、String的特性"><a href="#2、String的特性" class="headerlink" title="2、String的特性"></a>2、String的特性</h4><h5 id="1-String的不可变性"><a href="#1-String的不可变性" class="headerlink" title="1. String的不可变性"></a>1. String的不可变性</h5><ol>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当对现的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
</ol>
<h5 id="2-String实例化方法"><a href="#2-String实例化方法" class="headerlink" title="2. String实例化方法"></a>2. String实例化方法</h5><ul>
<li>方式一：通过字面量定义的方式</li>
<li>方式二：通过new + 构造器的方式</li>
</ul>
<p><strong>面试题：</strong></p>
<p>String s = new String(“abc”);方式创建对象，在内存中创建了几个对象？</p>
<p>两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="comment">//通过new + 构造器的方式:此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>String str1=“abc”;与 String str2= new String(“abc”);的区别?</p>
<ul>
<li>字符串常量存储在字符串常量池，目的是共享</li>
<li>字符串非常量对象存储在堆中</li>
</ul>
<h5 id="3-字符串拼接方式赋值对比"><a href="#3-字符串拼接方式赋值对比" class="headerlink" title="3. 字符串拼接方式赋值对比"></a>3. 字符串拼接方式赋值对比</h5><ol>
<li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</li>
<li>只要其中一个是变量，结果就在堆中。</li>
<li>如果拼接的结果调用intern()方法，返回值就在常量池中</li>
</ol>
<h5 id="4-String使用陷阱"><a href="#4-String使用陷阱" class="headerlink" title="4. String使用陷阱"></a>4. String使用陷阱</h5><ul>
<li><p>String s1=”a”；</p>
<p>说明：在字符串常量池中创建了一个字面量为”a”的字符串。</p>
</li>
<li><p>s1=s1+”b”</p>
<p>说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”）。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。</p>
</li>
<li><p>String s2=”ab”； 说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。</p>
</li>
<li><p>String s3=”a”+”b”； 说明：s3指向字符串常量池中已经创建的”ab”的字符串。</p>
</li>
<li><p>String s4=s1.intern()； 说明：堆空间的S1对象在调用 intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。</p>
</li>
</ul>
<h5 id="5-String类常用方法"><a href="#5-String类常用方法" class="headerlink" title="5. String类常用方法"></a>5. String类常用方法</h5><h6 id="1-字符串操作"><a href="#1-字符串操作" class="headerlink" title="1 字符串操作"></a>1 字符串操作</h6><ol>
<li>int length()：返回字符串的长度： return value.length</li>
<li>char charAt(int index)： 返回某索引处的字符return value[index]</li>
<li>boolean isEmpty()：判断是否是空字符串：return value.length == 0</li>
<li>String toLowerCase()：使用默认语言环境，将 String 中的所字符转换为小写</li>
<li>String toUpperCase()：使用默认语言环境，将 String 中的所字符转换为大写</li>
<li>String trim()：返回字符串的副本，忽略前导空白和尾部空白</li>
<li>boolean equals(Object obj)：比较字符串的内容是否相同</li>
<li>boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写</li>
<li>String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”</li>
<li>int compareTo(String anotherString)：比较两个字符串的大小</li>
<li>String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</li>
<li>String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</li>
</ol>
<h6 id="2-查找字符串中的字符"><a href="#2-查找字符串中的字符" class="headerlink" title="2 查找字符串中的字符"></a>2 查找字符串中的字符</h6><ol>
<li>boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true</li>
<li>int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引</li>
<li>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</li>
<li>int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引</li>
<li>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</li>
</ol>
<h6 id="3-字符串操作方法"><a href="#3-字符串操作方法" class="headerlink" title="3 字符串操作方法"></a>3 字符串操作方法</h6><ol>
<li>替换：<ul>
<li>String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。</li>
<li>String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。</li>
<li>String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。</li>
<li>String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</li>
</ul>
</li>
<li>匹配:<ul>
<li>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。</li>
</ul>
</li>
<li>切片：<ul>
<li>String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</li>
<li>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</li>
</ul>
</li>
</ol>
<h5 id="6-String与其他结构的转换"><a href="#6-String与其他结构的转换" class="headerlink" title="6. String与其他结构的转换"></a>6. String与其他结构的转换</h5><h6 id="1-String与基本数据类型、包装类之间的转换"><a href="#1-String与基本数据类型、包装类之间的转换" class="headerlink" title="1 String与基本数据类型、包装类之间的转换"></a>1 String与基本数据类型、包装类之间的转换</h6><p>String –&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)</p>
<p>基本数据类型、包装类 –&gt; String:调用String重载的valueOf(xxx)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringToBasic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    System.out.println(i == <span class="number">123</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">456</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(j);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(s.equals(<span class="string">&quot;456&quot;</span>));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-与字符数组之间的转换"><a href="#2-与字符数组之间的转换" class="headerlink" title="2 与字符数组之间的转换"></a>2 与字符数组之间的转换</h6><p>String –&gt; char[]:调用String的toCharArray()</p>
<p> char[] –&gt; String:调用String的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;helloword&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] chars = s1.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">    System.out.println(chars[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] charArray = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">System.out.println(s2);</span><br></pre></td></tr></table></figure>

<h6 id="3-与字节数组之间的转换"><a href="#3-与字节数组之间的转换" class="headerlink" title="3 与字节数组之间的转换"></a>3 与字节数组之间的转换</h6><p>编码：String –&gt; byte[]:调用String的getBytes()</p>
<p>解码：byte[] –&gt; String:调用String的构造器</p>
<p>编码：字符串 –&gt;字节 (看得懂 —&gt;看不懂的二进制数据)</p>
<p>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂</p>
<p>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span><span class="string">&quot;你好java世界&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytesArray = s1.getBytes();<span class="comment">//使用默认字符集编码</span></span><br><span class="line">System.out.println(Arrays.toString(bytesArray));<span class="comment">//[-28, -67, -96, -27, -91, -67, 106, 97, 118, 97, -28, -72, -106, -25, -107, -116]</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] gbks = s1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk编码集合</span></span><br><span class="line">System.out.println(Arrays.toString(gbks));<span class="comment">//[-60, -29, -70, -61, 106, 97, 118, 97, -54, -64, -67, -25]</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">String str1=<span class="keyword">new</span> <span class="title class_">String</span>(bytesArray);<span class="comment">//使用默认字符进行解码</span></span><br><span class="line">System.out.println(str1);<span class="comment">//你好java世界</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);<span class="comment">//使用默认字符对gbk编码进行解码</span></span><br><span class="line">System.out.println(str2);<span class="comment">//���java����解码错误，出现中文乱码,原因：编码和解码不一致</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks,<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk格式进行解码</span></span><br><span class="line">System.out.println(str3);<span class="comment">//你好java世界，解码正确，原因：编码和解码一致</span></span><br></pre></td></tr></table></figure>

<h6 id="4-与StringBuffer、StringBuilder之间的转换"><a href="#4-与StringBuffer、StringBuilder之间的转换" class="headerlink" title="4 与StringBuffer、StringBuilder之间的转换"></a>4 与StringBuffer、StringBuilder之间的转换</h6><p>1.String –&gt;StringBuffer、StringBuilder: 调用StringBuffer、StringBuilder构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span><span class="string">&quot;helloword&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str1);</span><br><span class="line">System.out.println(stringBuffer);<span class="comment">//helloword</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str1);</span><br><span class="line">System.out.println(stringBuilder);<span class="comment">//helloword</span></span><br><span class="line"></span><br><span class="line">stringBuffer.append(<span class="string">&quot;isStringBuffer&quot;</span>);</span><br><span class="line">System.out.println(stringBuffer);<span class="comment">//hellowordandgood</span></span><br><span class="line"></span><br><span class="line">stringBuilder.append(<span class="string">&quot;isStringBuider&quot;</span>);</span><br><span class="line">System.out.println(stringBuilder);</span><br></pre></td></tr></table></figure>

<p>2.StringBuffer、StringBuilder –&gt;String:</p>
<p>①调用String构造器； ②StringBuffer、StringBuilder的toString()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringBuiderOrStringBufferToStringTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello StringBuffer&quot;</span>);</span><br><span class="line">    System.out.println(sb1);</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello StringBuider&quot;</span>);</span><br><span class="line">    System.out.println(sb2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb1);</span><br><span class="line">    System.out.println(str1);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb2);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    System.out.println(sb1.toString());</span><br><span class="line">    System.out.println(sb2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-JVM中字符串常量池存放位置说明："><a href="#7-JVM中字符串常量池存放位置说明：" class="headerlink" title="7. JVM中字符串常量池存放位置说明："></a>7. JVM中字符串常量池存放位置说明：</h5><p>jdk 1.6 (jdk 6.0 ,java 6.0):字符串常量池存储在方法区（永久区）</p>
<p>jdk 1.7:字符串常量池存储在堆空间</p>
<p>jdk 1.8:字符串常量池存储在方法区（元空间）</p>
<h4 id="3、StringBuffer和StringBuilder"><a href="#3、StringBuffer和StringBuilder" class="headerlink" title="3、StringBuffer和StringBuilder"></a>3、StringBuffer和StringBuilder</h4><h5 id="1、StringBuffer类"><a href="#1、StringBuffer类" class="headerlink" title="1、StringBuffer类"></a>1、StringBuffer类</h5><h6 id="1-概述："><a href="#1-概述：" class="headerlink" title="1.概述："></a>1.概述：</h6><p>java.lang.String.Buffer代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。 很多方法与 String相同 作为参数传递时，方法内部可以改变值。</p>
<ul>
<li>StringBuffer类不同于 String，其对象必须使用构造器生成。</li>
<li>有三个构造器 StringBuffer()：初始容量为16的字符串缓冲区</li>
<li>StringBuffer(int size)：构造指定容量的字符串缓冲区</li>
<li>StringBuffer(String str)：将内容初始化为指定字符串内容</li>
</ul>
<h6 id="2-常用方法："><a href="#2-常用方法：" class="headerlink" title="2.常用方法："></a>2.常用方法：</h6><ol>
<li>StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接</li>
<li>StringBuffer delete(int start,int end)：删除指定位置的内容</li>
<li>StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str</li>
<li>StringBuffer insert(int offset, xxx)：在指定位置插入xxx</li>
<li>StringBuffer reverse() ：把当前字符序列逆转</li>
</ol>
<ul>
<li>public int indexOf(String str)：返回子串的下标</li>
<li>public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串</li>
<li>public int length()：获取字符串的长度</li>
<li>public char charAt(int n )：返回指定位置的字符</li>
<li>public void setCharAt(int n ,char ch)：设置指定位置的字符</li>
</ul>
<p><strong>总结：</strong></p>
<p>增：append(xxx) ；</p>
<p>删：delete(int start,int end) ；</p>
<p>改：setCharAt(int n ,char ch) / replace(int start, int end, String str) ；</p>
<p>查：charAt(int n ) ；</p>
<p>插：insert(int offset, xxx) ；</p>
<p>长度：length();</p>
<p>遍历：for() + charAt() / toString()；</p>
<h5 id="2、StringBuilder类"><a href="#2、StringBuilder类" class="headerlink" title="2、StringBuilder类"></a>2、StringBuilder类</h5><p>StringBuilder和 StringBuffer非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样，只是StringBuilder类没有加线程锁，执行效率更高。</p>
<h6 id="1-String、StringBuffer、StringBuilder三者的对比"><a href="#1-String、StringBuffer、StringBuilder三者的对比" class="headerlink" title="1. String、StringBuffer、StringBuilder三者的对比"></a>1. String、StringBuffer、StringBuilder三者的对比</h6><ul>
<li>String:不可变的字符序列；底层使用char[]存储；占用内存（会不断的创建和回收对象）</li>
<li>StringBuffer:可变的字符序列；线程安全的，效率低；线程安全；底层使用char[]存储；</li>
<li>StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；线程不安全；底层使用char[]存储</li>
</ul>
<blockquote>
<p>注意：作为参数传递的话，方法内部Stng不会改变其值， StringBuffer和 StringBuilder会改变其值。</p>
</blockquote>
<h6 id="2、StringBuffer与StringBuilder的内存解析"><a href="#2、StringBuffer与StringBuilder的内存解析" class="headerlink" title="2、StringBuffer与StringBuilder的内存解析"></a>2、StringBuffer与StringBuilder的内存解析</h6><p>指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)</p>
<h6 id="3-对比String、StringBuffer、StringBuilder三者的执行效率"><a href="#3-对比String、StringBuffer、StringBuilder三者的执行效率" class="headerlink" title="3. 对比String、StringBuffer、StringBuilder三者的执行效率"></a>3. 对比String、StringBuffer、StringBuilder三者的执行效率</h6><p>从高到低排列：StringBuilder &gt; StringBuffer &gt; String</p>
<h3 id="2、JDK-8-0以前的日期时间API"><a href="#2、JDK-8-0以前的日期时间API" class="headerlink" title="2、JDK 8.0以前的日期时间API"></a>2、JDK 8.0以前的日期时间API</h3><h4 id="1-java-lang-System类"><a href="#1-java-lang-System类" class="headerlink" title="1. java.lang.System类"></a>1. java.lang.System类</h4><p>System类提供的 public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。(时间戳) 此方法适于计算时间差。</p>
<blockquote>
<p>计算世界时间的主要标准有：</p>
</blockquote>
<ul>
<li><p>UTC（Coordinated Universal Time）</p>
</li>
<li><p>GMT（Greenwich Mean Time） </p>
</li>
<li><p>CST（Central Standard Time）</p>
</li>
</ul>
<h4 id="2-java-util-Date类"><a href="#2-java-util-Date类" class="headerlink" title="2. java.util.Date类"></a>2. java.util.Date类</h4><p>表示特定的瞬间，精确到毫秒</p>
<h5 id="1-构造器"><a href="#1-构造器" class="headerlink" title="1 构造器"></a>1 构造器</h5><p>Date():使用无参的构造器创建对象可以获取本地当前时间</p>
<p>Date(long date)</p>
<h5 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2 常用方法"></a>2 常用方法</h5><p>getTime()：返回自1970年1月1日00：00：00GMT以来此Date对象表示的毫秒数</p>
<p>tostring()：把此Date对象转换为以下形式的 String：</p>
<h5 id="3-java-util-Date类与java-sql-Date类"><a href="#3-java-util-Date类与java-sql-Date类" class="headerlink" title="3  java.util.Date类与java.sql.Date类"></a>3  java.util.Date类与java.sql.Date类</h5><ul>
<li><p>java.util.Date类</p>
</li>
<li><p>java.sql.Date类</p>
</li>
</ul>
<h4 id="3-java-text-SimpleDateFormat类"><a href="#3-java-text-SimpleDateFormat类" class="headerlink" title="3. java.text.SimpleDateFormat类"></a>3. java.text.SimpleDateFormat类</h4><p>Date类的AP不易于国际化，大部分被废弃了， java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</p>
<p>它允许进行格式化：日期→文本、解析：文本→日期</p>
<p><strong>格式化：</strong></p>
<p>SimpleDateFormat()：默认的模式和语言环境创建对象</p>
<p>public SimpleDateFormat(String pattern)：该构造方法可以用参数 pattern指定的格式创建一个对象，该对象调用：</p>
<p>public String format(Datedate)：方法格式化时间对象date</p>
<p><strong>解析</strong>： public Date parse(String source)：从给定字符串的开始解析文本，以生成个日期</p>
<h5 id="1-SimpleDateFormat对日期Date类的格式化和解析"><a href="#1-SimpleDateFormat对日期Date类的格式化和解析" class="headerlink" title="1. SimpleDateFormat对日期Date类的格式化和解析"></a>1. SimpleDateFormat对日期Date类的格式化和解析</h5><p>两个操作：</p>
<p>1.1 格式化：日期 —&gt;字符串</p>
<p>1.2 解析：格式化的逆过程，字符串 —&gt; 日期</p>
<h5 id="2-SimpleDateFormat的实例化-new-构造器"><a href="#2-SimpleDateFormat的实例化-new-构造器" class="headerlink" title="2. SimpleDateFormat的实例化:new + 构造器"></a>2. SimpleDateFormat的实例化:new + 构造器</h5><p>照指定的方式格式化和解析：调用带参的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="comment">//实例化Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//实例化SimpleDateFormate对象，并设置显示格式</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:aaa&quot;</span>);</span><br><span class="line">    <span class="comment">//格式化date对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br><span class="line">    System.out.println(format.toString());<span class="comment">//2020-09-19 02:09:下午</span></span><br><span class="line">    <span class="comment">//解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),</span></span><br><span class="line">    <span class="comment">//否则，抛异常</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> simpleDateFormat.parse(<span class="string">&quot;2020-04-20 14:20:下午&quot;</span>);</span><br><span class="line">    System.out.println(date2.toString());<span class="comment">//Tue Jan 21 02:20:00 CST 2020</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Calendar类：日历类、抽象类"><a href="#4-Calendar类：日历类、抽象类" class="headerlink" title="4. Calendar类：日历类、抽象类"></a>4. Calendar类：日历类、抽象类</h4><p>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</p>
<ul>
<li>获取 Calenda实例的方法 使用 Calendar.getInstance()方法 调用它的子类 GregorianCalendarl的构造器。</li>
<li>一个 Calendar的实例是系统时间的抽象表示，通过 get(int field)方法来取得想要的时间信息。 比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY、MINUTE、SECOND public void set(int field,int value) public void add(int field,int amount) public final Date get Time() public final void set Time(Date date)</li>
<li>注意 获取月份时：一月是0，二月是1，以此类推，12月是11 获取星期时：周日是1，周二是2，。。。周六是7</li>
</ul>
<h5 id="1-实例化"><a href="#1-实例化" class="headerlink" title="1 实例化"></a>1 实例化</h5><p>方式一：创建其子类(GregorianCalendar)的对象</p>
<p>方式二：调用其静态方法getInstance()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br></pre></td></tr></table></figure>

<h5 id="2-常用方法-1"><a href="#2-常用方法-1" class="headerlink" title="2 常用方法"></a>2 常用方法</h5><p>get():获取日期</p>
<p>set():设置日期</p>
<p>add():添加、修改日期</p>
<p>getTime:日历类–&gt;Date</p>
<p>setTime:Date–&gt;日历类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//        System.out.println(calendar.getClass());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.常用方法</span></span><br><span class="line"><span class="comment">//get()</span></span><br><span class="line"><span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);<span class="comment">//获取本月第几天</span></span><br><span class="line">System.out.println(days);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_YEAR));<span class="comment">//获取本年第几天</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set()</span></span><br><span class="line"><span class="comment">//calendar可变性</span></span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH,<span class="number">22</span>);<span class="comment">//设置本月第几天</span></span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add()</span></span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH,-<span class="number">3</span>);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br><span class="line"></span><br><span class="line"><span class="comment">//getTime():日历类---&gt; Date</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">//setTime():Date ---&gt; 日历类</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">calendar.setTime(date1);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>

<h3 id="3、JDK-8-0中新的日期时间类"><a href="#3、JDK-8-0中新的日期时间类" class="headerlink" title="3、JDK 8.0中新的日期时间类"></a>3、JDK 8.0中新的日期时间类</h3><h4 id="1-日期时间API的迭代："><a href="#1-日期时间API的迭代：" class="headerlink" title="1. 日期时间API的迭代："></a>1. 日期时间API的迭代：</h4><p>第一代：jdk 1.0 Date类</p>
<p>第二代：jdk 1.1 Calendar类，一定程度上替换Date类</p>
<p>第三代：jdk 1.8 提出了新的一套API</p>
<h4 id="2-前两代的问题："><a href="#2-前两代的问题：" class="headerlink" title="2. 前两代的问题："></a>2. 前两代的问题：</h4><p>可变性：像日期和时间这样的类应该是不可变的。</p>
<p>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</p>
<p>格式化：格式化只对Date用，Calendar则不行。 此外，它们也不是线程安全的；不能处理闰秒等。</p>
<p>Java 8.0中新引入的java.time API:</p>
<p>Java 8.0吸收了Joda-Time的精华，以一个新的开始为Java创建优秀的APl。新的java.time中包含了所有关于本地日期(LocalDate)、本地时间(Localtime)、本地日期时间(LocalDate time)、时区(ZonedDate time)和持续时间(Duration)的类。历史悠久的Date类新增了tolnstant()方法用于把Date转换成新的表示形式。这些新增的本地化时间日期API大大简化了日期时间和本地化的管理。</p>
<h4 id="3-Java-8-0中新的日期时间API涉及的包"><a href="#3-Java-8-0中新的日期时间API涉及的包" class="headerlink" title="3. Java 8.0中新的日期时间API涉及的包:"></a>3. Java 8.0中新的日期时间API涉及的包:</h4><img src="/posts/3743959532/20200421111835.png" class="" title="image-20200421111833248">

<h4 id="4-本地日期、本地时间、本地日期时间的使用："><a href="#4-本地日期、本地时间、本地日期时间的使用：" class="headerlink" title="4. 本地日期、本地时间、本地日期时间的使用："></a>4. 本地日期、本地时间、本地日期时间的使用：</h4><p>LocalDate / LocalTime / LocalDateTime</p>
<h5 id="1-代码："><a href="#1-代码：" class="headerlink" title="1 代码："></a>1 代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取当前的日期、时间、日期时间</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    System.out.println(localDate);<span class="comment">//2020-04-21</span></span><br><span class="line">    System.out.println(localTime);<span class="comment">//18:52:54.929</span></span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:52:54.929</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//of():设置指定的年、月、日、时、分、秒。没有偏移量</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">12</span>);</span><br><span class="line">    System.out.println(localDateTime1);<span class="comment">//2020-10-06T12:13:12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//getXxx()：获取相关的属性</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfMonth());<span class="comment">//21</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfWeek());<span class="comment">//TUESDAY</span></span><br><span class="line">    System.out.println(localDateTime.getMonth());<span class="comment">//APRIL</span></span><br><span class="line">    System.out.println(localDateTime.getMonthValue());<span class="comment">//4</span></span><br><span class="line">    System.out.println(localDateTime.getMinute());<span class="comment">//52</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//体现不可变性</span></span><br><span class="line">    <span class="comment">//withXxx():设置相关的属性</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> localDate.withDayOfMonth(<span class="number">22</span>);</span><br><span class="line">    System.out.println(localDate);<span class="comment">//2020-04-21</span></span><br><span class="line">    System.out.println(localDate1);<span class="comment">//2020-04-22</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> localDateTime.withHour(<span class="number">4</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime2);<span class="comment">//2020-04-21T04:59:17.484</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不可变性</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime3</span> <span class="operator">=</span> localDateTime.plusMonths(<span class="number">3</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime3);<span class="comment">//2020-07-21T18:59:17.484</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime4</span> <span class="operator">=</span> localDateTime.minusDays(<span class="number">6</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime4);<span class="comment">//2020-04-15T18:59:17.484</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、时间点：Instant"><a href="#5、时间点：Instant" class="headerlink" title="5、时间点：Instant"></a>5、时间点：Instant</h4><h5 id="1-说明："><a href="#1-说明：" class="headerlink" title="1 说明："></a>1 说明：</h5><p>① 时间线上的一个瞬时点。 概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC开始的秒数。）</p>
<p>② 类似于 java.util.Date类</p>
<h5 id="2-代码示例-1"><a href="#2-代码示例-1" class="headerlink" title="2 代码示例"></a>2 代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取本初子午线对应的标准时间</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">    System.out.println(instant);<span class="comment">//2020-04-21T11:03:21.469Z</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加时间的偏移量</span></span><br><span class="line">    <span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span> <span class="operator">=</span> instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    System.out.println(offsetDateTime);<span class="comment">//2020-04-21T19:03:21.469+08:00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  ---&gt; Date类的getTime()</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> instant.toEpochMilli();</span><br><span class="line">    System.out.println(milli);<span class="comment">//1587467105795</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ofEpochMilli():通过给定的毫秒数，获取Instant实例  --&gt;Date(long millis)</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">1587467105795L</span>);</span><br><span class="line">    System.out.println(instant1);<span class="comment">//2020-04-21T11:05:05.795Z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、日期时间格式化类：DateTimeFormatter"><a href="#6、日期时间格式化类：DateTimeFormatter" class="headerlink" title="6、日期时间格式化类：DateTimeFormatter"></a>6、日期时间格式化类：DateTimeFormatter</h4><h5 id="1-说明：-1"><a href="#1-说明：-1" class="headerlink" title="1 说明："></a>1 说明：</h5><p>① 格式化或解析日期、时间</p>
<p>② 类似于SimpleDateFormat</p>
<h5 id="2-常用方法：-1"><a href="#2-常用方法：-1" class="headerlink" title="2 常用方法："></a>2 常用方法：</h5><ol>
<li><p>实例化方式： 预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME 本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG) 自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p>
</li>
<li><p>常用方法：</p>
<img src="/posts/3743959532/20200421112840.png" class="" title="image-20200421112839437"></li>
</ol>
<h5 id="3、代码示例："><a href="#3、代码示例：" class="headerlink" title="3、代码示例："></a>3、代码示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//        方式一：预定义的标准格式。</span></span><br><span class="line">    <span class="comment">//        如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">    <span class="comment">//格式化:日期--&gt;字符串</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> formatter.format(localDateTime);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T19:13:13.530</span></span><br><span class="line">    System.out.println(str1);<span class="comment">//2020-04-21T19:13:13.53</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析：字符串 --&gt;日期</span></span><br><span class="line">    <span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> formatter.parse(<span class="string">&quot;2000-04-21T19:13:13.53&quot;</span>);</span><br><span class="line">    System.out.println(parse);<span class="comment">//&#123;&#125;,ISO resolved to 2000-04-21T19:13:13.530</span></span><br><span class="line">    <span class="comment">//        方式二：</span></span><br><span class="line">    <span class="comment">//        本地化相关的格式。如：ofLocalizedDateTime()</span></span><br><span class="line">    <span class="comment">//        FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> formatter1.format(localDateTime);</span><br><span class="line">    System.out.println(str2);<span class="comment">//2020年4月21日 下午07时16分57秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      本地化相关的格式。如：ofLocalizedDate()</span></span><br><span class="line">    <span class="comment">//      FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> formatter2.format(LocalDate.now());</span><br><span class="line">    System.out.println(str3);<span class="comment">//2020-4-21</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//       重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter3</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">Str4</span> <span class="operator">=</span> formatter3.format(LocalDateTime.now());</span><br><span class="line">    System.out.println(Str4);<span class="comment">//2020-04-21 07:24:04</span></span><br><span class="line"></span><br><span class="line">    <span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> formatter3.parse(<span class="string">&quot;2020-02-03 05:23:06&quot;</span>);</span><br><span class="line">    System.out.println(accessor);<span class="comment">//&#123;SecondOfMinute=6, HourOfAmPm=5, NanoOfSecond=0, MicroOfSecond=0, MinuteOfHour=23, MilliOfSecond=0&#125;,ISO resolved to 2020-02-03</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7、其它API的使用"><a href="#7、其它API的使用" class="headerlink" title="7、其它API的使用"></a>7、其它API的使用</h4><ul>
<li>ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris </li>
<li>ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-1203T10:15:30+01:00 Europe/Paris。 <ul>
<li>其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如： Asia/Shanghai等 </li>
</ul>
</li>
<li>Clock：使用时区提供对当前即时、日期和时间的访问的时钟。 </li>
<li>持续时间：Duration，用于计算两个“时间”间隔 </li>
<li>日期间隔：Period，用于计算两个“日期”间隔 </li>
<li>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整 到“下一个工作日”等操作。 </li>
<li>TemporalAdjusters : 该类通过静态方法 (firstDayOfXxx()/lastDayOfXxx()/nextXxx</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//getAvailableZoneIds():获取所的ZoneId</span></span><br><span class="line">    Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">    <span class="keyword">for</span>(String s : zoneIds)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取“Asia/Tokyo”时区对应的时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>));</span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ZonedDateTime:带时区的日期时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取本时区的ZonedDateTime对象</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">    System.out.println(zonedDateTime);</span><br><span class="line">    <span class="comment">//now(ZoneId id):获取指定时区的ZonedDateTime对象</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime1</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>));</span><br><span class="line">    System.out.println(zonedDateTime1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、Java比较器"><a href="#4、Java比较器" class="headerlink" title="4、Java比较器"></a>4、Java比较器</h3><h4 id="1-Java比较器的使用背景："><a href="#1-Java比较器的使用背景：" class="headerlink" title="1. Java比较器的使用背景："></a>1. Java比较器的使用背景：</h4><ul>
<li>Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的</li>
<li>但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</li>
<li>如何实现？使用两个接口中的任何一个：Comparable（自然排序） 或 Comparator（定制排序）</li>
</ul>
<h4 id="2-自然排序：使用Comparable接口"><a href="#2-自然排序：使用Comparable接口" class="headerlink" title="2. 自然排序：使用Comparable接口"></a>2. 自然排序：使用Comparable接口</h4><h5 id="2-1-说明"><a href="#2-1-说明" class="headerlink" title="2.1 说明"></a>2.1 说明</h5><ol>
<li>像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。</li>
<li>像String、包装类重写compareTo()方法以后，进行了从小到大的排列</li>
<li>重写compareTo(obj)的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。</li>
<li>对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序</li>
<li>Comparable的典型实现：(默认都是从小到大排列的) String：按照字符串中字符的Uincode值进行比较 Character：按照字符的 Unicode值来进行比较 数值类型对应的包装类以及 BigInteger、BigDecimal：按照它们对应的数值大小进行比较 Boolean：true对应的包装类实例大于false对应的包装类实例 Date、Time等：后面的日期时间比前面的日期时间大</li>
</ol>
<h5 id="2-2-自定义类代码举例："><a href="#2-2-自定义类代码举例：" class="headerlink" title="2.2 自定义类代码举例："></a>2.2 自定义类代码举例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span>  <span class="title class_">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明商品比较大小的方式:照价格从低到高排序,再照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//        System.out.println(&quot;**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods)o;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line">            <span class="comment">//           return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//        return 0;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter、setter、toString()、构造器：省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-定制排序：使用Comparator接口"><a href="#3-定制排序：使用Comparator接口" class="headerlink" title="3. 定制排序：使用Comparator接口"></a>3. 定制排序：使用Comparator接口</h4><h5 id="3-1-说明"><a href="#3-1-说明" class="headerlink" title="3.1 说明:"></a>3.1 说明:</h5><ol>
<li>背景：</li>
</ol>
<p>当元素的类型没实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序</p>
<ol start="2">
<li>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：</li>
</ol>
<ul>
<li>如果方法返回正整数，则表示o1大于o2；</li>
<li>如果返回0，表示相等；</li>
<li>返回负整数，表示o1小于o2。</li>
</ul>
<h5 id="3-2-代码举例："><a href="#3-2-代码举例：" class="headerlink" title="3.2 代码举例："></a>3.2 代码举例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="comment">//指明商品比较大小的方式:照产品名称从低到高排序,再照价格从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods)o1;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods)o2;</span><br><span class="line">            <span class="keyword">if</span>(g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                <span class="keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-两种排序方式对比"><a href="#4-两种排序方式对比" class="headerlink" title="4. 两种排序方式对比"></a>4. 两种排序方式对比</h4><ul>
<li>Comparable接口的方式是一定的，保证Comparable接口实现类的对象在任何位置都可以比较大小。</li>
<li>Comparator接口属于临时性的比较。</li>
</ul>
<h3 id="5、其他常用类"><a href="#5、其他常用类" class="headerlink" title="5、其他常用类"></a>5、其他常用类</h3><h4 id="1-System类"><a href="#1-System类" class="headerlink" title="1.System类"></a>1.System类</h4><h4 id="2-Math类"><a href="#2-Math类" class="headerlink" title="2.Math类"></a>2.Math类</h4><h4 id="3-BigInteger类、BigDecimal类"><a href="#3-BigInteger类、BigDecimal类" class="headerlink" title="3.BigInteger类、BigDecimal类"></a>3.BigInteger类、BigDecimal类</h4><h2 id="十、枚举类-amp-注解"><a href="#十、枚举类-amp-注解" class="headerlink" title="十、枚举类&amp;注解"></a>十、枚举类&amp;注解</h2><h3 id="1、枚举类的使用"><a href="#1、枚举类的使用" class="headerlink" title="1、枚举类的使用"></a>1、枚举类的使用</h3><h4 id="1-枚举类的说明："><a href="#1-枚举类的说明：" class="headerlink" title="1. 枚举类的说明："></a>1. 枚举类的说明：</h4><ol>
<li><p>枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</p>
</li>
<li><p>当需要定义一组常量时，强烈建议使用枚举类</p>
</li>
<li><p>枚举类的实现：</p>
<p>JDK 5.0以前需要自定义</p>
<p>JDK 5.0后新增enum关键字用于定义枚举类</p>
</li>
<li><p>如果枚举类中只一个对象，则可以作为单例模式的实现方式。</p>
</li>
<li><p>枚举类的属性：</p>
<p>枚举类对象的属性不应允许被改动，所以应该使用 private final修饰 枚举类的使用 private final修饰的属性应该在构造器中为其赋值 若枚举类显式的定义了带参数的构造器，则在列出枚举值时也必须对应的传入参数</p>
</li>
</ol>
<h4 id="2-如何自定义枚举类？"><a href="#2-如何自定义枚举类？" class="headerlink" title="2. 如何自定义枚举类？"></a>2. 如何自定义枚举类？</h4><p>步骤:</p>
<ol>
<li>私有化构造器，保证不能在类的外部创建其对象；</li>
<li>在类的内部创建枚举类的示例。声明为：public static final；</li>
<li>对象如果有实例变量，应该声明为private final，并在构造器中初始化；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类 使用 class 关键字</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-JDK-5-0-新增使用enum定义枚举类。"><a href="#3-JDK-5-0-新增使用enum定义枚举类。" class="headerlink" title="3. JDK 5.0 新增使用enum定义枚举类。"></a>3. JDK 5.0 新增使用enum定义枚举类。</h4><ul>
<li>使用enum定义的枚举类默认继承了java.lang.Enum类，因此不能再继承其他类</li>
<li>枚举类的构造器只能使用private权限修饰符</li>
<li>枚举类的所有实例必须在枚举类中显式列出(“,”分隔“;”结尾)。列出的实例系统会自动添加public static final修饰</li>
<li>必须在枚举类的第一行声明枚举类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> &#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.私化类的构造器,并给对象属性赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Enum类的常用方法："><a href="#Enum类的常用方法：" class="headerlink" title="Enum类的常用方法："></a>Enum类的常用方法：</h5><ol>
<li>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</li>
<li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”.如不是，会有运行时异常IllegalArgumentException</li>
<li>toString()：返回当前枚举类对象常量的名称</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season1</span> <span class="variable">summer</span> <span class="operator">=</span> Season1.SUMMER;</span><br><span class="line"><span class="comment">//toString():返回枚举类对象的名称</span></span><br><span class="line">System.out.println(summer.toString());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line"><span class="comment">//values():返回所的枚举类对象构成的数组</span></span><br><span class="line">Season1[] values = Season1.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">    System.out.println(values[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">Thread.State[] values1 = Thread.State.values();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values1.length; i++) &#123;</span><br><span class="line">    System.out.println(values1[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line"><span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line"><span class="comment">//如果没objName的枚举类对象，则抛异常：IllegalArgumentException</span></span><br><span class="line"><span class="comment">//        Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);</span></span><br><span class="line">System.out.println(winter);</span><br></pre></td></tr></table></figure>

<h4 id="4、用Enum类定义的枚举类对象分别实现接口："><a href="#4、用Enum类定义的枚举类对象分别实现接口：" class="headerlink" title="4、用Enum类定义的枚举类对象分别实现接口："></a>4、用Enum类定义的枚举类对象分别实现接口：</h4><p>使用说明：</p>
<ol>
<li>和普通Java类一样，枚举类可以实现一个或多个接口</li>
<li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li>
<li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、注解的使用"><a href="#2、注解的使用" class="headerlink" title="2、注解的使用"></a>2、注解的使用</h3><h4 id="1-注解的理解"><a href="#1-注解的理解" class="headerlink" title="1. 注解的理解"></a>1. 注解的理解</h4><p>① jdk 5.0 新增的功能</p>
<p>② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。</p>
<p>③ Annotation可以像修饰符一样使用，可以用来修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的“name = value”对中。</p>
<p>④ 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗 代码和XML配置等。</p>
<p>⑤ 框架 = 注解 + 反射机制 + 设计模式</p>
<h4 id="2-注解的使用示例"><a href="#2-注解的使用示例" class="headerlink" title="2. 注解的使用示例"></a>2. 注解的使用示例</h4><p>使用 Annotation时要在其前面增加<code>@符号</code>，并把该 Annotation当成个修饰符使用。用于修饰它支持的程序元素</p>
<h5 id="示例一：生成文档相关的注解"><a href="#示例一：生成文档相关的注解" class="headerlink" title="示例一：生成文档相关的注解"></a>示例一：生成文档相关的注解</h5><ul>
<li><p>@author标明开发该类模块的作者，多个作者之间使用，分割 </p>
</li>
<li><p>@version标明该类模块的版本 </p>
</li>
<li><p>@see参考转向，也就是相关主题 </p>
</li>
<li><p>@since从哪个版本开始增加的 </p>
</li>
<li><p>@param对方法中某参数的说明，如果没有参数就不能写 </p>
</li>
<li><p>@return对方法返回值的说明，如果方法的返回值类型是void就不能写 </p>
</li>
<li><p>@exception对方法可能抛出的异常进行说明，如果方法没有用 throws显式抛出的异常就不能写 </p>
<p>其中 </p>
<ul>
<li>@param @return和@exception这三个标记都是只用于方法的。 </li>
<li>@param的格式要求：@param形参名形参类型形参说明 </li>
<li>@return的格式要求：@return返回值类型返回值说明 </li>
<li>@exception的格式要求：@exception异常类型异常说明 </li>
<li>@param和@ exception可以并列多个</li>
</ul>
</li>
</ul>
<h5 id="示例二：在编译时进行格式检查-JDK内置的个基本注解"><a href="#示例二：在编译时进行格式检查-JDK内置的个基本注解" class="headerlink" title="示例二：在编译时进行格式检查(JDK内置的个基本注解)"></a>示例二：在编译时进行格式检查(JDK内置的个基本注解)</h5><ul>
<li>@Override: 限定重写父类方法, 该注解只能用于方法</li>
<li>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</li>
<li>@SuppressWarnings: 抑制编译器警告</li>
</ul>
<h4 id="3-如何自定义注解"><a href="#3-如何自定义注解" class="headerlink" title="3. 如何自定义注解"></a>3. 如何自定义注解</h4><p>参照@SuppressWarnings定义</p>
<ol>
<li>注解声明为：<a target="_blank" rel="noopener" href="https://my.oschina.net/u/996807">@interface</a></li>
<li>内部定义成员，通常使用value表示</li>
<li>可以指定成员的默认值，使用default定义</li>
<li>如果自定义注解没成员，表明是一个标识作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value = &quot;hello&quot;)</span></span><br></pre></td></tr></table></figure>

<h4 id="4-元注解-："><a href="#4-元注解-：" class="headerlink" title="4. 元注解 ："></a>4. 元注解 ：</h4><blockquote>
<p>对现有的注解进行修饰</p>
</blockquote>
<p>JDK5.0提供了4个标准的meta-annotation类型，分别是： </p>
<ul>
<li><strong>Retention</strong>:只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期,SOURCE,CLASS(默认),RUNTIME</li>
<li><strong>Target</strong>:用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于 修饰哪些程序元素</li>
<li>Documented：用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档</li>
<li>Inherited：被它修饰的 Annotation 将具有继承性。如果某个类使用了被 @Inherited 修饰的 Annotation, 则其子类将自动具有该注解。 </li>
</ul>
<h4 id="5-JDK8中注解的新特性"><a href="#5-JDK8中注解的新特性" class="headerlink" title="5.  JDK8中注解的新特性 :"></a>5.  JDK8中注解的新特性 :</h4><ul>
<li>JDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个TYPE_PARAMETER,TYPE_USE。 </li>
<li>在Java 8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用 在任何地方</li>
</ul>
<h2 id="十一、Java集合"><a href="#十一、Java集合" class="headerlink" title="十一、Java集合"></a>十一、Java集合</h2><h3 id="1、集合框架概述"><a href="#1、集合框架概述" class="headerlink" title="1、集合框架概述"></a>1、集合框架概述</h3><p>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中)</p>
<h4 id="1-数组存储的特点："><a href="#1-数组存储的特点：" class="headerlink" title="1. 数组存储的特点："></a>1. 数组存储的特点：</h4><p>一旦初始化以后，其长度就确定了。 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。</p>
<p>比如：String[] arr;int[] arr1;Object[] arr2;</p>
<h4 id="2-数组存储的弊端："><a href="#2-数组存储的弊端：" class="headerlink" title="2.数组存储的弊端："></a>2.数组存储的弊端：</h4><ol>
<li>一旦初始化以后，其长度就不可修改。</li>
<li>数组中提供的方法非常限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li>
<li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</li>
<li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li>
</ol>
<h4 id="3-集合存储的优点："><a href="#3-集合存储的优点：" class="headerlink" title="3. 集合存储的优点："></a>3. 集合存储的优点：</h4><p>解决数组存储数据方面的弊端。</p>
<h4 id="4-集合的分类"><a href="#4-集合的分类" class="headerlink" title="4. 集合的分类"></a>4. 集合的分类</h4><p>Java集合可分为Collection和Map两种体系</p>
<ul>
<li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul>
<li>List：元素有序、可重复的集合</li>
<li>Set：元素无序、不可重复的集</li>
</ul>
</li>
<li>Map接口：双列数据，保存具有映射关系“key-value对”的集合</li>
</ul>
<h4 id="5-集合的框架结构"><a href="#5-集合的框架结构" class="headerlink" title="5. 集合的框架结构"></a>5. 集合的框架结构</h4><blockquote>
<p>Collection接口：单列集合，用来存储一个一个的对象</p>
<blockquote>
<p>List接口：存储有序的、可重复的数据。  –&gt;“动态”数组</p>
<blockquote>
<p>ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</p>
</blockquote>
<blockquote>
<p>LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</p>
</blockquote>
<blockquote>
<p>Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</p>
</blockquote>
</blockquote>
<blockquote>
<p>Set接口：存储无序的、不可重复的数据   –&gt;数学概念上的“集合”</p>
<blockquote>
<p>HashSet：作为Set接口主要实现类;线程不安全;可以存null值</p>
<blockquote>
<p>LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</p>
</blockquote>
</blockquote>
<blockquote>
<p>TreeSet：可以按照添加对象的指定属性，进行排序。</p>
</blockquote>
</blockquote>
<p>Map:双列数据，存储key-value对的数据   —类似于高中的函数：y = f(x)</p>
<blockquote>
<p>HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</p>
<blockquote>
<p>LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。<br>原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。</p>
</blockquote>
</blockquote>
<blockquote>
<p>TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序<br>             底层使用红黑树</p>
</blockquote>
<blockquote>
<p>Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</p>
<blockquote>
<p>Properties:常用来处理配置文件。key和value都是String类型</p>
</blockquote>
</blockquote>
</blockquote>
<img src="/posts/3743959532/image-20201224090151708.png" class="" title="image-20201224090151708">

<img src="/posts/3743959532/image-20201224090219756.png" class="" title="image-20201224090219756">

<h3 id="2、Collection-接口方法"><a href="#2、Collection-接口方法" class="headerlink" title="2、Collection 接口方法"></a>2、Collection 接口方法</h3><ol>
<li><p>添加</p>
<ul>
<li>add(Object obj)</li>
<li>addAll(Collection coll)</li>
</ul>
</li>
<li><p>获取有效元素个数</p>
<ul>
<li>int size()</li>
</ul>
</li>
<li><p>清空集合</p>
<ul>
<li>void clear()</li>
</ul>
</li>
<li><p>是否为空集合</p>
<ul>
<li>boolean isEmpty()</li>
</ul>
</li>
<li><p>是否包含某个元素</p>
<ul>
<li>boolean contains(Object obj):是通过元素的equals方法来判断是否是同一个对象</li>
<li>boolean containsAll(Collection c):也是调用元素的equals方法来比较的。用两个两个集合的元素逐一比较</li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li>boolean remove(Object obj):通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素</li>
<li>boolean removeAll(Collection coll):取当前集合的差集</li>
</ul>
</li>
<li><p>取两个集合的交集</p>
<ul>
<li>boolean retainAll(Collection c):把交集的结果存在当前的集合中，不影响c</li>
</ul>
</li>
<li><p>集合是否相等</p>
<ul>
<li>boolean equals(Object obj)</li>
</ul>
</li>
<li><p>转换成对象数组</p>
<ul>
<li>Object [] toArray()</li>
</ul>
</li>
<li><p>获取集合对象的哈希值</p>
<ul>
<li>hashCode()</li>
</ul>
</li>
<li><p>遍历 </p>
<ul>
<li>iterator()：返回迭代器对象，用于集合遍历</li>
</ul>
</li>
</ol>
<h3 id="3、Iterator迭代器接口"><a href="#3、Iterator迭代器接口" class="headerlink" title="3、Iterator迭代器接口"></a>3、Iterator迭代器接口</h3><h4 id="1-遍历Collection的两种方式："><a href="#1-遍历Collection的两种方式：" class="headerlink" title="1. 遍历Collection的两种方式："></a>1. 遍历Collection的两种方式：</h4><p>① 使用迭代器Iterator ② foreach循环（或增强for循环）</p>
<h4 id="2-java-utils包下定义的迭代器接口：Iterator"><a href="#2-java-utils包下定义的迭代器接口：Iterator" class="headerlink" title="2. java.utils包下定义的迭代器接口：Iterator"></a>2. java.utils包下定义的迭代器接口：Iterator</h4><h5 id="2-1说明："><a href="#2-1说明：" class="headerlink" title="2.1说明："></a>2.1说明：</h5><p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。 GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</p>
<h5 id="2-2作用："><a href="#2-2作用：" class="headerlink" title="2.2作用："></a>2.2作用：</h5><p>遍历集合Collectiton元素</p>
<h5 id="2-3如何获取实例："><a href="#2-3如何获取实例：" class="headerlink" title="2.3如何获取实例："></a>2.3如何获取实例：</h5><p>coll.iterator()返回一个迭代器实例</p>
<h5 id="2-4遍历的代码实现："><a href="#2-4遍历的代码实现：" class="headerlink" title="2.4遍历的代码实现："></a>2.4遍历的代码实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"><span class="comment">//hasNext():判断是否还下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="comment">//next():①指针下移 ②将下移以后集合位置上的元素返回</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-iterator中remove-方法的使用："><a href="#2-5-iterator中remove-方法的使用：" class="headerlink" title="2.5 iterator中remove()方法的使用："></a>2.5 iterator中remove()方法的使用：</h5><ul>
<li>测试Iterator中的remove()</li>
<li>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。</li>
<li>内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除集合中&quot;Tom&quot;</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">//            iterator.remove();</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">            <span class="comment">//                iterator.remove();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将指针重新放到头部，遍历集合</span></span><br><span class="line">    iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-JDK-5-0新特性–增强for循环：-foreach循环"><a href="#3-JDK-5-0新特性–增强for循环：-foreach循环" class="headerlink" title="3. JDK 5.0新特性–增强for循环：(foreach循环)"></a>3. JDK 5.0新特性–增强for循环：(foreach循环)</h4><h5 id="3-1-遍历集合举例："><a href="#3-1-遍历集合举例：" class="headerlink" title="3.1 遍历集合举例："></a>3.1 遍历集合举例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(集合元素的类型 局部变量 : 集合对象)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：内部仍然调用了迭代器。</p>
</blockquote>
<h5 id="3-2-遍历数组举例："><a href="#3-2-遍历数组举例：" class="headerlink" title="3.2. 遍历数组举例："></a>3.2. 遍历数组举例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//for(数组元素的类型 局部变量 : 数组对象)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、Collection-子接口-List"><a href="#4、Collection-子接口-List" class="headerlink" title="4、Collection 子接口:List"></a>4、Collection 子接口:List</h3><h4 id="1-存储的数据特点："><a href="#1-存储的数据特点：" class="headerlink" title="1. 存储的数据特点："></a>1. 存储的数据特点：</h4><p>存储序有序的、可重复的数据。</p>
<ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</li>
<li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>JDK AP中List接口的实现类常用的有：<code>ArrayList、LinkedList和 Vector.</code></li>
</ul>
<p><strong>面试题: ArrayList、 LinkedList. Vector三者的异同?</strong><br>同:三个类都是实现了List接口，存储数据的特点相同:存储有序的、可重复的数据不同:</p>
<p>不同：</p>
<blockquote>
<p>Collection接口：单列集合，用来存储一个一个的对象  </p>
<blockquote>
<p>List接口：存储序的、可重复的数据。  –&gt;“动态”数组,替换原的数组      </p>
<blockquote>
<p>ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储      </p>
</blockquote>
<blockquote>
<p>LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储     </p>
</blockquote>
<blockquote>
<p>Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="2-常用方法：-2"><a href="#2-常用方法：-2" class="headerlink" title="2. 常用方法："></a>2. 常用方法：</h4><p>List除了从 Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法。</p>
<ul>
<li>void add(int index, Object ele):在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</li>
<li>Object get(int index):获取指定index位置的元素</li>
<li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</li>
<li>Object remove(int index):移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object ele):设置指定index位置的元素为ele</li>
<li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</li>
</ul>
<p>总结：</p>
<ul>
<li>增：add(Object obj)</li>
<li>删：remove(int index) / remove(Object obj)</li>
<li>改：set(int index, Object ele)</li>
<li>查：get(int index)</li>
<li>插：add(int index, Object ele)</li>
<li>长度：size()</li>
<li>遍历： ① Iterator迭代器方式② foreach（增强for循环） ③ 普通的循环</li>
</ul>
<h4 id="3、ArrayList"><a href="#3、ArrayList" class="headerlink" title="3、ArrayList"></a>3、ArrayList</h4><ul>
<li>ArrayList是List接口的典型实现类、主要实现类</li>
<li>本质上，ArrayList是对象引用的一个”变长”数组</li>
<li>Array Listi的JDK 1.8之前与之后的实现区别？<ul>
<li>JDK 1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组</li>
<li>JDK 1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</li>
</ul>
</li>
<li>Arrays.asList（…）方法返回的List集合，既不是 ArrayList实例，也不是Vector实例。Arrays.asList（…）返回值是一个固定长度的List集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">345</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//iterator()遍历ArrayList集合</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、linkedList"><a href="#4、linkedList" class="headerlink" title="4、linkedList"></a>4、linkedList</h4><ul>
<li><p>对与对于频繁的插入和删除元素操作，建议使用LinkedList类，效率更高</p>
</li>
<li><p>新增方法：</p>
<ul>
<li>void addFirst(Object obj)</li>
<li>void addLast(Object obj)</li>
<li>Object getFirst()</li>
<li>Object getlast)()</li>
<li>Object removeFirst()</li>
<li>Object removeLast()</li>
</ul>
</li>
<li><p>Linkedlist：双向链表，内部没有声明数组，而是定义了Node类型的frst和last，用于记录首末元素。同时，定义内部类Node，作为 Linkedlist中保存数据的基本结构。Node除了保存数据，还定义了两个变量：</p>
<ul>
<li>prev变量记录前一个元素的位置</li>
<li>next变量记录下一个元素的位置</li>
</ul>
</li>
</ul>
<img src="/posts/3743959532/image-20201224094812416.png" class="" title="image-20201224094812416">

<h3 id="5、Collection-子接口-Set"><a href="#5、Collection-子接口-Set" class="headerlink" title="5、Collection 子接口:Set"></a>5、Collection 子接口:Set</h3><ul>
<li>Set接口是Collection的子接口，set接口没有提供额外的方法</li>
<li>Set集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败。（多用于过滤操作，去掉重复数据）</li>
<li>Set判断两个对象是否相同不是使用==运算符，而是根据equals()方法</li>
</ul>
<blockquote>
<p>Collection接口：单列集合，用来存储一个一个的对象      </p>
<blockquote>
<p>Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”          </p>
<blockquote>
<p>HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</p>
<blockquote>
<p>LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历，对于频繁的遍历操作，LinkedHashSet效率高于HashSet.           </p>
</blockquote>
<p>TreeSet：可以按照添加对象的指定属性，进行排序。</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="1-存储的数据特点：-1"><a href="#1-存储的数据特点：-1" class="headerlink" title="1.存储的数据特点："></a>1.存储的数据特点：</h4><p>用于存放无序的、不可重复的元素</p>
<p>以HashSet为例说明：</p>
<ol>
<li>无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。</li>
<li>不可重复性：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。</li>
</ol>
<h4 id="2-元素添加过程：-以HashSet为例"><a href="#2-元素添加过程：-以HashSet为例" class="headerlink" title="2. 元素添加过程：(以HashSet为例)"></a>2. 元素添加过程：(以HashSet为例)</h4><p>我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断</p>
<p>数组此位置上是否已经有元素：</p>
<ul>
<li>如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1</li>
<li>如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：<ul>
<li>如果hash值不相同，则元素a添加成功。—&gt;情况2</li>
<li>如果hash值相同，进而需要调用元素a所在类的equals()方法：<ul>
<li>equals()返回true,元素a添加失败</li>
<li>equals()返回false,则元素a添加成功。—&gt;情况3</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</p>
<p>JDK 7.0 :元素a放到数组中，指向原来的元素。</p>
<p>JDK 8.0 :原来的元素在数组中，指向元素a</p>
<p>总结：七上八下</p>
<p>HashSet底层：数组+链表的结构。（JDK 7.0以前）</p>
<img src="/posts/3743959532/image-20201224100739343.png" class="" title="image-20201224100739343">

<h4 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h4><p>Set接口中没额外定义新的方法，使用的都是Collection中声明过的方法。</p>
<h5 id="3-1-重写hashCode-的基本方法"><a href="#3-1-重写hashCode-的基本方法" class="headerlink" title="3.1 重写hashCode()的基本方法"></a>3.1 重写hashCode()的基本方法</h5><ul>
<li>在程序运行时，同一个对象多次调用hashCode()方法应该返回相同的值。</li>
<li>当两个对象的equals()方法比较返回true时，这两个对象的 hashCode()方法的返回值也应相等。</li>
<li>对象中用作equals()方法比较的Field，都应该用来计算hashCode值。</li>
</ul>
<h5 id="3-2-重写equals-方法基本原则"><a href="#3-2-重写equals-方法基本原则" class="headerlink" title="3.2 重写equals()方法基本原则"></a>3.2 重写equals()方法基本原则</h5><ul>
<li>以自定义的 Customer类为例，何时需要重写equals()？</li>
<li>当一个类有自己特有的“逻辑相等”概念，当改写equals()的时候，总是要改写 hash Code（），根据一个类的 equals方法(改写后)，两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。</li>
<li>因此，违反了“相等的对象必须具有相等的散列码”.</li>
<li>结论：复写equals方法的时候一般都需要同时复写 hashCode方法。通常参与计算 hashCode的对象的属性也应该参与到equals()中进行计算。</li>
</ul>
<h5 id="3-3-Eclipse-IDEA工具里hashCode-重写"><a href="#3-3-Eclipse-IDEA工具里hashCode-重写" class="headerlink" title="3.3 Eclipse/IDEA工具里hashCode()重写"></a>3.3 Eclipse/IDEA工具里hashCode()重写</h5><p>以Eclipse/DEA为例，在自定义类中可以调用工具自动重写equals()和hashCode() 问题：为什么用 Eclipse/IDEA复写 hash Code方法，有31这个数字？</p>
<ul>
<li>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</li>
<li>并且31只占用5bits，相乘造成数据溢出的概率较小。</li>
<li>31可以由i*31==(&lt;&lt;5)-1来表示，现在很多虚拟机里面都有做相关优化。（提高算法效率）</li>
<li>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！（减少冲突）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;User equals()....&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age != user.age) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(user.name) : user.name == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; <span class="comment">//return name.hashCode() + age;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + age;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4、HashSet"><a href="#4、HashSet" class="headerlink" title="4、HashSet"></a>4、HashSet</h4><ul>
<li>Hashset是Set接口的典型实现，大多数时候使用Set集合时都使用这个实现类。</li>
<li>HashSet按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。</li>
<li>HashSet具有以下特点：<ul>
<li>不能保证元素的排列顺序</li>
<li>HashSet不是线程安全的</li>
<li>集合元素可以是nul</li>
</ul>
</li>
<li>HashSet集合判断两个元素相等的标准：两个对象通过hashCode()方法比较相等，并且两个对象的equals()方法返回值也相等。</li>
<li>对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”</li>
</ul>
<h4 id="5、LinkedHashSet"><a href="#5、LinkedHashSet" class="headerlink" title="5、LinkedHashSet"></a>5、LinkedHashSet</h4><ul>
<li>LinkedhashSet是HashSet的子类</li>
<li>LinkedhashSet根据元素的hashCode值来决定元素的存储位置但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</li>
<li>LinkedhashSet插入性能略低于HashSet，但在迭代访问Set里的全部元素时有很好的性能。</li>
<li>LinkedhashSet不允许集合元素重复。</li>
</ul>
<h4 id="6、TreeSet"><a href="#6、TreeSet" class="headerlink" title="6、TreeSet"></a>6、TreeSet</h4><ul>
<li>Treeset是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。</li>
<li>不能添加不同类的对象</li>
<li>TreeSet底层使用红黑树结构存储数据</li>
<li>新增的方法如下：（了解）<ul>
<li>Comparator comparator()</li>
<li>Object first()</li>
<li>Object last()</li>
<li>Object lower(object e)</li>
<li>Object higher(object e)</li>
<li>SortedSet subSet(fromElement， toElement)</li>
<li>SortedSet headSet(toElement)</li>
<li>SortedSet tailSet(fromElement)</li>
</ul>
</li>
<li>TreeSet两种排序方法：自然排序和定制排序。默认情况下，TreeSet采用自然排序。</li>
</ul>
<p>详细介绍：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/LiaHon/p/11203229.html">https://www.cnblogs.com/LiaHon/p/11203229.html</a></p>
<h3 id="6、Map接口"><a href="#6、Map接口" class="headerlink" title="6、Map接口"></a>6、Map接口</h3><ul>
<li>Map与Collection并列存在。用于保存具有映射关系的数据:key-value</li>
<li>Map中的key和value都可以是任何引用类型的数据</li>
<li>Map中的key用set来存放，不允许重复，即同一个Map对象所对应的类，须重写 hashCode()和 equals()方法</li>
<li>常用 String类作为Map的“键”</li>
<li>key和value之间存在单向一对一关系，即通过指定的key总能找到唯一的、确定的value</li>
<li>Map接口的常用实现类:HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是Map接口使用频率最高的实现类</li>
</ul>
<h4 id="1-常见实现类结构"><a href="#1-常见实现类结构" class="headerlink" title="1. 常见实现类结构"></a>1. 常见实现类结构</h4><img src="/posts/3743959532/20200429112013.png" class="" title="image-20200429112013">


<blockquote>
<p>Map:双列数据，存储key-value对的数据   —类似于高中的函数：y = f(x)     </p>
<blockquote>
<p>HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value        </p>
<blockquote>
<p>LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。                   </p>
<p> 原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。                    对于频繁的遍历操作，此类执行效率高于HashMap。    </p>
</blockquote>
</blockquote>
<blockquote>
<p>TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序                      </p>
<p>底层使用红黑树   </p>
</blockquote>
<blockquote>
<p>Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value </p>
<blockquote>
<p>Properties:常用来处理配置文件。key和value都是String类型</p>
</blockquote>
</blockquote>
</blockquote>
<h5 id="1-1-HashMap"><a href="#1-1-HashMap" class="headerlink" title="1.1 HashMap"></a>1.1 HashMap</h5><ul>
<li>HashMap是Map接口使用频率最高的实现类。</li>
<li>允许使用null键和null值，与 HashSet一样，不保证映射的顺序。</li>
<li>所有的key构成的集合是set：无序的、不可重复的。所以，key所在的类要重写equals()和 hashCode()</li>
<li>所有的value构成的集合是Collection：无序的、可以重复的。所以，value所在的类要重写:equals()</li>
<li>一个key-value构成一个entry</li>
<li>所有的entry构成的集合是Set：无序的、不可重复的</li>
<li>HashMap判断两个key相等的标准是：两个key通过equals()方法返回true，hashCode值也相等。</li>
<li>HashMap判断两个value相等的标准是：两个value通过equals()方法返回true.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="literal">null</span>,<span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-2-LinkedHashMap"><a href="#1-2-LinkedHashMap" class="headerlink" title="1.2 LinkedHashMap"></a>1.2 LinkedHashMap</h5><ul>
<li>LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap.</li>
<li>区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node.</li>
<li>与Linkedhash Set类似，LinkedHashMap可以维护Map的迭代顺序：迭代顺序与Key-value对的插入顺序一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>();</span><br><span class="line">    map.put(<span class="number">123</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    map.put(<span class="number">345</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    map.put(<span class="number">12</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="1-3-TreeMap"><a href="#1-3-TreeMap" class="headerlink" title="1.3 TreeMap"></a>1.3 TreeMap</h5><ul>
<li>TreeMap存储Key-Value对时，需要根据key-value对进行排序。TreeMap可以保证所有的 Key-Value对处于有序状态。</li>
<li>TreeSet底层使用红黑树结构存储数据</li>
<li>TreeMap的Key的排序:<ul>
<li>自然排序： TreeMap的所有的Key必须实现Comparable接口，而且所有的Key应该是同一个类的对象，否则将会抛出ClasssCastEXception()</li>
<li>定制排序：创建 TreeMap时，传入一个 Comparator对象，该对象负责对TreeMap中的所有key进行排序。此时不需要Map的Key实现Comparable接口</li>
</ul>
</li>
<li>TreeMap判断两个key相等的标准：两个key通过 compareTo()方法或者compare()方法返回0.</li>
</ul>
<h5 id="1-4-Hashtable"><a href="#1-4-Hashtable" class="headerlink" title="1.4 Hashtable"></a>1.4 Hashtable</h5><ul>
<li>Hashtable是个古老的Map实现类，JDK1.0就提供了。不同于 HashMap，Hashtable是线程安全的.</li>
<li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用</li>
<li>与HashMap.不同，Hashtable不允许使用null作为key和value.</li>
<li>与HashMap一样，Hashtable也不能保证其中Key-value对的顺序.</li>
<li>Hashtable判断两个key相等、两个value相等的标准，与HashMap-致.</li>
</ul>
<h5 id="1-5-Properties"><a href="#1-5-Properties" class="headerlink" title="1.5 Properties"></a>1.5 Properties</h5><ul>
<li>Properties类是Hashtable的子类，该对象用于处理属性文件</li>
<li>由于属性文件里的key、value都是字符串类型，所以Properties里的key和value都是字符串类型</li>
<li>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法</li>
</ul>
<h4 id="2-存储结构的理解："><a href="#2-存储结构的理解：" class="headerlink" title="2. 存储结构的理解："></a>2. 存储结构的理解：</h4><ul>
<li>Map中的key:无序的、不可重复的，使用Set存储所的key —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例)</li>
<li>Map中的value:无序的、可重复的，使用Collection存储所的value —&gt;value所在的类要重写equals()</li>
<li>一个键值对：key-value构成了一个Entry对象。</li>
<li>Map中的entry:无序的、不可重复的，使用Set存储所的entry</li>
</ul>
<h4 id="3-常用方法-1"><a href="#3-常用方法-1" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h4><h5 id="3-1添加、删除、修改操作："><a href="#3-1添加、删除、修改操作：" class="headerlink" title="3.1添加、删除、修改操作："></a>3.1添加、删除、修改操作：</h5><ul>
<li>Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</li>
<li>void putAll(Map m):将m中的所有key-value对存放到当前map中</li>
<li>Object remove(Object key)：移除指定key的key-value对，并返回value</li>
<li>void clear()：清空当前map中的所有数据</li>
</ul>
<h5 id="3-2元素查询的操作："><a href="#3-2元素查询的操作：" class="headerlink" title="3.2元素查询的操作："></a>3.2元素查询的操作：</h5><ul>
<li>Object get(Object key)：获取指定key对应的value</li>
<li>boolean containsKey(Object key)：是否包含指定的key</li>
<li>boolean containsValue(Object value)：是否包含指定的value</li>
<li>int size()：返回map中key-value对的个数</li>
<li>boolean isEmpty()：判断当前map是否为空</li>
<li>boolean equals(Object obj)：判断当前map和参数对象obj是否相等</li>
</ul>
<h5 id="3-3-元视图操作的方法："><a href="#3-3-元视图操作的方法：" class="headerlink" title="3.3 元视图操作的方法："></a>3.3 元视图操作的方法：</h5><ul>
<li>Set keySet()：返回所有key构成的Set集合</li>
<li>Collection values()：返回所有value构成的Collection集合</li>
<li>Set entrySet()：返回所有key-value对构成的Set集合</li>
</ul>
<h5 id="总结：常用方法："><a href="#总结：常用方法：" class="headerlink" title="总结：常用方法："></a>总结：常用方法：</h5><ul>
<li>添加：put(Object key,Object value)</li>
<li>删除：remove(Object key)</li>
<li>修改：put(Object key,Object value)</li>
<li>查询：get(Object key)</li>
<li>长度：size()</li>
<li>遍历：keySet() / values() / entrySet()</li>
</ul>
<h3 id="7、Collections-工具类"><a href="#7、Collections-工具类" class="headerlink" title="7、Collections 工具类"></a>7、Collections 工具类</h3><h4 id="1-作用："><a href="#1-作用：" class="headerlink" title="1.作用："></a>1.作用：</h4><p>Collections是一个操作Set、Lit和Map等集合的工具类</p>
<p>Collections中提供了一系列静态的方法对集合元素进行排序、査询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</p>
<h4 id="2-常用方法：-3"><a href="#2-常用方法：-3" class="headerlink" title="2.常用方法："></a>2.常用方法：</h4><h5 id="2-1排序操作"><a href="#2-1排序操作" class="headerlink" title="2.1排序操作"></a>2.1排序操作</h5><ul>
<li>reverse(List)：反转 List 中元素的顺序</li>
<li>shuffle(List)：对 List 集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定 List 集合元素升序排序</li>
<li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">765</span>);</span><br><span class="line">    list.add(-<span class="number">97</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123, 43, 765, -97, 0]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//reverse(List)：反转 List 中元素的顺序</span></span><br><span class="line">    Collections.reverse(list);</span><br><span class="line">    System.out.println(list);<span class="comment">//[0, -97, 765, 43, 123]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//shuffle(List)：对 List 集合元素进行随机排序</span></span><br><span class="line">    Collections.shuffle(list);</span><br><span class="line">    System.out.println(list);<span class="comment">//[765, -97, 123, 0, 43]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span></span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    System.out.println(list);<span class="comment">//[-97, 0, 43, 123, 765]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span><br><span class="line">    Collections.swap(list,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[-97, 765, 43, 123, 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2查找、替换"><a href="#2-2查找、替换" class="headerlink" title="2.2查找、替换"></a>2.2查找、替换</h5><ul>
<li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</li>
<li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li>
<li>Object min(Collection)</li>
<li>Object min(Collection，Comparator)</li>
<li>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</li>
<li>void copy(List dest,List src)：将src中的内容复制到dest中</li>
<li>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所旧值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">765</span>);</span><br><span class="line">    list.add(-<span class="number">97</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123, 43, 765, -97, 0]</span></span><br><span class="line">    <span class="comment">//Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</span></span><br><span class="line">    <span class="type">Comparable</span> <span class="variable">max</span> <span class="operator">=</span> Collections.max(list);</span><br><span class="line">    System.out.println(max);<span class="comment">//765</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object min(Collection)</span></span><br><span class="line">    <span class="type">Comparable</span> <span class="variable">min</span> <span class="operator">=</span> Collections.min(list);</span><br><span class="line">    System.out.println(min);<span class="comment">//-97</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> Collections.frequency(list,<span class="number">123</span>);</span><br><span class="line">    System.out.println(frequency);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void copy(List dest,List src)：将src中的内容复制到dest中</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">dest</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Object</span>[list.size()]);</span><br><span class="line">    System.out.println(dest.size());<span class="comment">//7</span></span><br><span class="line">    Collections.copy(dest,list);</span><br><span class="line">    System.out.println(dest);<span class="comment">//[123, 123, 123, 43, 765, -97, 0]</span></span><br><span class="line">    <span class="comment">//boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="十二、泛型"><a href="#十二、泛型" class="headerlink" title="十二、泛型"></a>十二、泛型</h2><h3 id="1、泛型简介"><a href="#1、泛型简介" class="headerlink" title="1、泛型简介"></a>1、泛型简介</h3><h4 id="1、泛型概述"><a href="#1、泛型概述" class="headerlink" title="1、泛型概述"></a>1、泛型概述</h4><ul>
<li>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、 创建对象时确定（即传入实际的类型参数，也称为类型实参）。</li>
<li>从JDK 5.0以后，Java引入了“参数化类型(Parameterized type)”的概念，允许我们在创建集合时再指定集合元素的类型，正如:List &lt;String&gt;，这表明该List只能保存字符串类型的对象。</li>
<li>JDK 5.0改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。</li>
</ul>
<h4 id="2-泛型的引入背景"><a href="#2-泛型的引入背景" class="headerlink" title="2.泛型的引入背景"></a>2.泛型的引入背景</h4><p>集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection&lt;E&gt;，List&lt;E&gt;，ArrayList&lt;E&gt; 这个&lt;E&gt;就是类型参数，即泛型。</p>
<h4 id="3-引入泛型的目的"><a href="#3-引入泛型的目的" class="headerlink" title="3.引入泛型的目的"></a>3.引入泛型的目的</h4><ol>
<li>解决元素存储的安全性问题，好比商品、药品标签，不会弄错。</li>
<li>解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。</li>
</ol>
<blockquote>
<p>Java泛型可以保证如果程序在编译时没有发岀警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。</p>
</blockquote>
<h3 id="2、集合中使用泛型"><a href="#2、集合中使用泛型" class="headerlink" title="2、集合中使用泛型"></a>2、集合中使用泛型</h3><p>① 集合接口或集合类在JDK 5.0时都修改为带泛型的结构。</p>
<p>② 在实例化集合类时，可以指明具体的泛型类型</p>
<p>③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</p>
<p>  比如：add(E e) —&gt;实例化以后：add(Integer e)</p>
<p>④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</p>
<p>⑤ 如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。</p>
<h3 id="3、自定义泛型结构"><a href="#3、自定义泛型结构" class="headerlink" title="3、自定义泛型结构"></a>3、自定义泛型结构</h3><p>泛型类、泛型接口、泛型方法</p>
<h4 id="1-泛型的声明"><a href="#1-泛型的声明" class="headerlink" title="1. 泛型的声明"></a>1. 泛型的声明</h4><ul>
<li>interface List<T> 和 class GenTest&lt;K,V&gt;其中，T，K，V，不代表值，而是表示类型。这里使用任意字母都可以。</li>
<li>常用T表示，是Type的缩写。</li>
</ul>
<h4 id="2-泛型的实例化："><a href="#2-泛型的实例化：" class="headerlink" title="2. 泛型的实例化："></a>2. 泛型的实例化：</h4><p>一定要在类名后面指定类型参数的值（类型）。如：</p>
<p>List<String> strList =new ArrayList<String>();</p>
<p>Iterator<Customer> iterator = customers.iterator();</p>
<ul>
<li>T只能是类，不能用基本数据类型填充。但可以使用包装类填充</li>
<li>把一个集合中的内容限制为一个特定的数据类型，这就是 generics背后的核心思想</li>
</ul>
<h4 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3. 注意点"></a>3. 注意点</h4><ol>
<li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如&lt;E1,E2,E3&gt;</p>
</li>
<li><p>泛型类的构造器如下： public GenericClass(){}</p>
<p>而下面是错误的： public GenericClass<E>{}</p>
</li>
<li><p>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</p>
</li>
<li><p>泛型不同的引用不能相互赋值。</p>
<blockquote>
<p>尽管在编译时 ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。</p>
</blockquote>
</li>
<li><p>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。</p>
<blockquote>
<p>建议：泛型要使用一路都用。要不用，一路都不要用。</p>
</blockquote>
</li>
<li><p>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。</p>
</li>
<li><p>JDK 7.0，泛型的简化操作： ArrayList<Fruit>first= new ArrayList&lt;&gt;();（类型推断）</p>
</li>
<li><p>泛型的指定中不能使用基本数据类型，可以使用包装类替换。</p>
</li>
<li><p>在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。</p>
</li>
<li><p>异常类不能是泛型的。</p>
</li>
<li><p>不能使用new E[]。但是可以：E[] elements= (E[])new Object[capacity];</p>
<blockquote>
<p>参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</p>
</blockquote>
</li>
<li><p>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：</p>
<ul>
<li>子类不保留父类的泛型：按需实现<ul>
<li>没有类型—擦除</li>
<li>具体类型</li>
</ul>
</li>
<li>子类保留父类的泛型：泛型子类<ul>
<li>全部保留</li>
<li>部分保留</li>
</ul>
</li>
<li>结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义泛型子类Son</span></span><br><span class="line"><span class="comment"> * 情况一：继承泛型父类后不保留父类的泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.没有指明类型  擦除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;<span class="comment">//等价于class Son1 extends Father&lt;Object,Odject&gt;&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.指定具体类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义泛型子类Son</span></span><br><span class="line"><span class="comment"> * 情况二：继承泛型父类后保留泛型类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.全部保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.部分保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer,T2&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>4、泛型在继承上的体现</p>
<p>5、通配符的使用</p>
<p>6、泛型举例</p>
<h3 id="4、泛型的使用"><a href="#4、泛型的使用" class="headerlink" title="4、泛型的使用"></a>4、泛型的使用</h3><p>泛型的三种使用方式：泛型类，泛型方法，泛型接口。</p>
<h4 id="1、泛型类"><a href="#1、泛型类" class="headerlink" title="1、泛型类"></a>1、泛型类</h4><h4 id="2、泛型接口"><a href="#2、泛型接口" class="headerlink" title="2、泛型接口"></a>2、泛型接口</h4><h4 id="3、泛型通配符"><a href="#3、泛型通配符" class="headerlink" title="3、泛型通配符"></a>3、泛型通配符</h4><p>此处 <code>？</code> 是类型实参，而不是类型形参。</p>
<h4 id="4、泛型方法"><a href="#4、泛型方法" class="headerlink" title="4、泛型方法"></a>4、泛型方法</h4><p>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型。</p>
<h2 id="十三、IO流"><a href="#十三、IO流" class="headerlink" title="十三、IO流"></a>十三、IO流</h2><h3 id="一、File类的使用"><a href="#一、File类的使用" class="headerlink" title="一、File类的使用"></a>一、File类的使用</h3><h4 id="1-File类的理解"><a href="#1-File类的理解" class="headerlink" title="1. File类的理解"></a>1. File类的理解</h4><ul>
<li>File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)。</li>
<li>File类声明在java.io包下：文件和文件路径的抽象表示形式，与平台无关。</li>
<li>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</li>
<li>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</li>
<li>后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”。</li>
</ul>
<h4 id="2-File的实例化"><a href="#2-File的实例化" class="headerlink" title="2. File的实例化"></a>2. File的实例化</h4><h5 id="2-1-常用构造器"><a href="#2-1-常用构造器" class="headerlink" title="2.1 常用构造器"></a>2.1 常用构造器</h5><ul>
<li>File(String filePath)</li>
<li>File(String parentPath,String childPath)</li>
<li>File(File parentFile,String childPath)</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//构造器1</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\workspace_idea\\JavaSenic\\IO\\hello.txt&quot;</span>);</span><br><span class="line">    System.out.println(file1);</span><br><span class="line">    System.out.println(file2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器2</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\workspace_idea\\JavaSenior&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    System.out.println(file3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器3</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file3, <span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line">    System.out.println(file4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-路径分类"><a href="#2-2-路径分类" class="headerlink" title="2.2 路径分类"></a>2.2 路径分类</h5><ul>
<li>相对路径：相较于某个路径下，指明的路径。</li>
<li>绝对路径：包含盘符在内的文件或文件目录的路径。</li>
</ul>
<p><strong>说明</strong>：</p>
<ul>
<li>IDEA中：<ul>
<li>如果使用JUnit中的单元测试方法测试，相对路径即为当前Module下。</li>
<li>如果使用main()测试，相对路径即为当前的Project下。</li>
</ul>
</li>
<li>Eclipse中：<ul>
<li>不管使用单元测试方法还是使用main()测试，相对路径都是当前的Project下。</li>
</ul>
</li>
</ul>
<h5 id="2-3-路径分隔符"><a href="#2-3-路径分隔符" class="headerlink" title="2.3 路径分隔符"></a>2.3 路径分隔符</h5><ul>
<li><p>windows和DOS系统默认使用“\”来表示</p>
</li>
<li><p>UNIX和URL使用“/”来表示</p>
</li>
<li><p>Java程序支持跨平台运行，因此路径分隔符要慎用。</p>
</li>
<li><p>为了解决这个隐患，File类提供了一个常量： public static final String separator。根据操作系统，动态的提供分隔符。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//windows和DOS系统</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\io\\test.txt&quot;</span>);</span><br><span class="line"><span class="comment">//UNIX和URL</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/io/test.txt&quot;</span>);</span><br><span class="line"><span class="comment">//java提供的常量</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:&quot;</span>+File.separator+<span class="string">&quot;io&quot;</span>+File.separator+<span class="string">&quot;test.txt&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-File类的常用方法"><a href="#3-File类的常用方法" class="headerlink" title="3. File类的常用方法"></a>3. File类的常用方法</h4><h5 id="3-1-File类的获取功能"><a href="#3-1-File类的获取功能" class="headerlink" title="3.1 File类的获取功能"></a>3.1 File类的获取功能</h5><ul>
<li>public String getAbsolutePath()：获取绝对路径</li>
<li>public String getPath() ：获取路径</li>
<li>public String getName() ：获取名称</li>
<li>public String getParent()：获取上层文件目录路径。若无，返回null</li>
<li>public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。</li>
<li>public long lastModified() ：获取最后一次的修改时间，毫秒值</li>
<li>如下的两个方法适用于文件目录：</li>
<li>public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组</li>
<li>public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io\\hi.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(file1.getAbsolutePath());</span><br><span class="line">    System.out.println(file1.getPath());</span><br><span class="line">    System.out.println(file1.getName());</span><br><span class="line">    System.out.println(file1.getParent());</span><br><span class="line">    System.out.println(file1.length());</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>(file1.lastModified()));</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    System.out.println(file2.getAbsolutePath());</span><br><span class="line">    System.out.println(file2.getPath());</span><br><span class="line">    System.out.println(file2.getName());</span><br><span class="line">    System.out.println(file2.getParent());</span><br><span class="line">    System.out.println(file2.length());</span><br><span class="line">    System.out.println(file2.lastModified());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workspace_idea1\\JavaSenior&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String[] list = file.list();</span><br><span class="line">    <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">for</span>(File f : files)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-File类的重命名功能"><a href="#3-2-File类的重命名功能" class="headerlink" title="3.2 File类的重命名功能"></a>3.2 File类的重命名功能</h5><ul>
<li>public boolean renameTo(File dest):把文件重命名为指定的文件路径</li>
<li>注意：file1.renameTo(file2)为例：要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\io\\hi.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">renameTo</span> <span class="operator">=</span> file2.renameTo(file1);</span><br><span class="line">    System.out.println(renameTo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-File类的判断功能"><a href="#3-3-File类的判断功能" class="headerlink" title="3.3 File类的判断功能"></a>3.3 File类的判断功能</h5><ul>
<li>public boolean isDirectory()：判断是否是文件目录</li>
<li>public boolean isFile() ：判断是否是文件</li>
<li>public boolean exists() ：判断是否存在</li>
<li>public boolean canRead() ：判断是否可读</li>
<li>public boolean canWrite() ：判断是否可写</li>
<li>public boolean isHidden() ：判断是否隐藏</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    file1 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(file1.isDirectory());</span><br><span class="line">    System.out.println(file1.isFile());</span><br><span class="line">    System.out.println(file1.exists());</span><br><span class="line">    System.out.println(file1.canRead());</span><br><span class="line">    System.out.println(file1.canWrite());</span><br><span class="line">    System.out.println(file1.isHidden());</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io&quot;</span>);</span><br><span class="line">    file2 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io1&quot;</span>);</span><br><span class="line">    System.out.println(file2.isDirectory());</span><br><span class="line">    System.out.println(file2.isFile());</span><br><span class="line">    System.out.println(file2.exists());</span><br><span class="line">    System.out.println(file2.canRead());</span><br><span class="line">    System.out.println(file2.canWrite());</span><br><span class="line">    System.out.println(file2.isHidden());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-4-Flie类的创建功能"><a href="#3-4-Flie类的创建功能" class="headerlink" title="3.4 Flie类的创建功能"></a>3.4 Flie类的创建功能</h5><ul>
<li>创建硬盘中对应的文件或文件目录</li>
<li>public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false</li>
<li>public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</li>
<li>public boolean mkdirs() ：创建文件目录。如果此文件目录存在，就不创建了。如果上层文件目录不存在，一并创建</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file1.exists())&#123;</span><br><span class="line">        <span class="comment">//文件的创建</span></span><br><span class="line">        file1.createNewFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//文件存在</span></span><br><span class="line">        file1.delete();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//文件目录的创建</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io\\io1\\io3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">mkdir</span> <span class="operator">=</span> file1.mkdir();</span><br><span class="line">    <span class="keyword">if</span>(mkdir)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io\\io1\\io4&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">mkdir1</span> <span class="operator">=</span> file2.mkdirs();</span><br><span class="line">    <span class="keyword">if</span>(mkdir1)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要想删除成功，io4文件目录下不能有子目录或文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\io\\io1\\io4&quot;</span>);</span><br><span class="line">    file3 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\io\\io1&quot;</span>);</span><br><span class="line">    System.out.println(file3.delete());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-5-File类的删除功能"><a href="#3-5-File类的删除功能" class="headerlink" title="3.5 File类的删除功能"></a>3.5 File类的删除功能</h5><ul>
<li>删除磁盘中的文件或文件目录</li>
<li>public boolean delete()：删除文件或者文件夹</li>
<li>删除注意事项：Java中的删除不走回收站。</li>
</ul>
<h4 id="4-内存解析"><a href="#4-内存解析" class="headerlink" title="4. 内存解析"></a>4. 内存解析</h4><img src="/posts/3743959532/20200430231447.png" class="" title="image-20200430231445700">



<h4 id="5-小练习"><a href="#5-小练习" class="headerlink" title="5. 小练习"></a>5. 小练习</h4><p>利用Fie构造器，new一个文件目录file 1）在其中创建多个文件和目录 2）编写方法，实现删除fle中指定文件的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\io\\io1\\hello.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//创建一个与file同目录下的另外一个文件，文件名为：haha.txt</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file.getParent(),<span class="string">&quot;haha.txt&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newFile</span> <span class="operator">=</span> destFile.createNewFile();</span><br><span class="line">    <span class="keyword">if</span>(newFile)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断指定目录下是否有后缀名为jpg的文件，如果有，就输出该文件名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindJPGFileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\code&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String[] fileNames = srcFile.list();</span><br><span class="line">        <span class="keyword">for</span>(String fileName : fileNames)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fileName.endsWith(<span class="string">&quot;.jpg&quot;</span>))&#123;</span><br><span class="line">                System.out.println(fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\code&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File[] listFiles = srcFile.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File file : listFiles)&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.getName().endsWith(<span class="string">&quot;.jpg&quot;</span>))&#123;</span><br><span class="line">                System.out.println(file.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * File类提供了两个文件过滤器方法</span></span><br><span class="line"><span class="comment">	 * public String[] list(FilenameFilter filter)</span></span><br><span class="line"><span class="comment">	 * public File[] listFiles(FileFilter filter)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\code&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File[] subFiles = srcFile.listFiles(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(File file : subFiles)&#123;</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历指定目录所有文件名称，包括子文件目录中的文件。 拓展1：并计算指定目录占用空间的大小 拓展2：删除指定文件目录及其下的所有文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListFileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归:文件目录</span></span><br><span class="line">        <span class="comment">/** 打印出指定目录所有文件名称，包括子文件目录中的文件 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建目录对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.打印子目录</span></span><br><span class="line">        printSubFile(file);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归方法遍历所有目录下的文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSubFile</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">        <span class="comment">//打印子目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;<span class="comment">//如果为文件目录，则递归调用自身</span></span><br><span class="line">                printSubFile(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(f.getAbsolutePath());<span class="comment">//输出绝对路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓展1：求指定目录所在空间的大小</span></span><br><span class="line">    <span class="comment">// 求任意一个目录的总大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDirectorySize</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="comment">// file是文件，那么直接返回file.length()</span></span><br><span class="line">        <span class="comment">// file是目录，把它的下一级的所有大小加起来就是它的总大小</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            size += file.length();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            File[] allFiles = file.listFiles();<span class="comment">// 获取file的下一级</span></span><br><span class="line">            <span class="comment">// 累加all[i]的大小</span></span><br><span class="line">            <span class="keyword">for</span> (File f : allFiles) &#123;</span><br><span class="line">                size += getDirectorySize(f);<span class="comment">//f的大小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拓展2：删除指定的目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDirectory</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果file是文件，直接delete</span></span><br><span class="line">        <span class="comment">// 如果file是目录，先把它的下一级干掉，然后删除自己</span></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            File[] allFiles = file.listFiles();</span><br><span class="line">            <span class="comment">//递归调用删除file下一级</span></span><br><span class="line">            <span class="keyword">for</span> (File f : allFiles) &#123;</span><br><span class="line">                deleteDirectory(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除文件</span></span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、IO流概述"><a href="#二、IO流概述" class="headerlink" title="二、IO流概述"></a>二、IO流概述</h3><h4 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h4><ul>
<li>IO是Input/Output的缩写，I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。</li>
<li>Java程序中，对于数据的输入输出操作以“流(stream)”的方式进行。</li>
<li>Java.IO包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。</li>
</ul>
<h4 id="2-流的分类"><a href="#2-流的分类" class="headerlink" title="2. 流的分类"></a>2. 流的分类</h4><p><strong>操作数据单位：字节流、字符流</strong></p>
<ul>
<li>对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理</li>
<li>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理</li>
</ul>
<p><strong>数据的流向：输入流、输出流</strong></p>
<ul>
<li>输入input:读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li>
<li>输出output:将程序（内存）数据输出到磁盘、光盘等存储设备中。</li>
</ul>
<p><strong>流的角色：节点流、处理流</strong></p>
<p>节点流：直接从数据源或目的地读写数据。</p>
<img src="/posts/3743959532/20200502092207.png" class="" title="image-20200502092206789">

<p>处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。</p>
<img src="/posts/3743959532/20200502092222.png" class="" title="image-20200502092221437">

<p><strong>图示：</strong></p>
<img src="/posts/3743959532/20200502091549.png" class="" title="image-20200502091548532">



<h4 id="3-IO流的体系分类"><a href="#3-IO流的体系分类" class="headerlink" title="3. IO流的体系分类"></a>3. IO流的体系分类</h4><h5 id="3-1-总体分类"><a href="#3-1-总体分类" class="headerlink" title="3.1 总体分类"></a>3.1 总体分类</h5><img src="/posts/3743959532/20200502091616.png" class="" title="image-20200502091615386">

<blockquote>
<p>红框为抽象基类，蓝框为常用IO流</p>
</blockquote>
<h5 id="3-2-常用的几个IO流结构"><a href="#3-2-常用的几个IO流结构" class="headerlink" title="3.2 常用的几个IO流结构"></a>3.2 常用的几个IO流结构</h5><table>
<thead>
<tr>
<th>抽象基类</th>
<th>节点流（或文件流）</th>
<th>缓冲流（处理流的一种）</th>
</tr>
</thead>
<tbody><tr>
<td>InputStream</td>
<td>FileInputStream (read(byte[] buffer))</td>
<td>BufferedInputStream (read(byte[] buffer))</td>
</tr>
<tr>
<td>OutputSteam</td>
<td>FileOutputStream (write(byte[] buffer,0,len)</td>
<td>BufferedOutputStream (write(byte[] buffer,0,len) / flush()</td>
</tr>
<tr>
<td>Reader</td>
<td>FileReader (read(char[] cbuf))</td>
<td>BufferedReader (read(char[] cbuf) / readLine())</td>
</tr>
<tr>
<td>Writer</td>
<td>FileWriter (write(char[] cbuf,0,len)</td>
<td>BufferedWriter (write(char[] cbuf,0,len) / flush()</td>
</tr>
</tbody></table>
<h5 id="3-3-对抽象基类的说明："><a href="#3-3-对抽象基类的说明：" class="headerlink" title="3.3 对抽象基类的说明："></a>3.3 对抽象基类的说明：</h5><table>
<thead>
<tr>
<th>抽象基类</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputSteam</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputSteam</td>
<td>Writer</td>
</tr>
</tbody></table>
<ul>
<li>说明：Java的lO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。</li>
<li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</li>
</ul>
<p>3.3.1InputSteam &amp; Reader</p>
<ul>
<li>InputStream和Reader是所有输入流的基类。</li>
<li>InputStream（典型实现：FileInputStream）<ul>
<li>int read()</li>
<li>int read(byte[] b)</li>
<li>int read(byte[] b,int off,int len)</li>
</ul>
</li>
<li>Reader（典型实现：FileReader）<ul>
<li>int read()</li>
<li>int read(char[] c）</li>
<li>int read(char[] c,int off,int len）</li>
</ul>
</li>
<li>程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。</li>
<li>FileInputStream从文件系统中的某个文件中获得输入字节。FileInputStream用于读取非文本数据之类的原始字节流。要读取字符流，需要使用 FileReader。</li>
</ul>
<p><strong>InputSteam：</strong></p>
<ul>
<li><p>int read()</p>
<p>从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回值-1。</p>
</li>
<li><p>int read(byte[] b)</p>
<p>从此输入流中将最多b.length个字节的数据读入一个byte数组中。如果因为已经到达流末尾而没有可用的字节，则返回值-1.否则以整数形式返回实际读取的字节数。</p>
</li>
<li><p>int read(byte[] b,int off,int len)</p>
<p>将输入流中最多len个数据字节读入byte数组。尝试读取len个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值-1。</p>
</li>
<li><p>public void close throws IOException</p>
<p>关闭此输入流并释放与该流关联的所有系统资源。</p>
</li>
</ul>
<p><strong>Reader：</strong></p>
<ul>
<li><p>int read()</p>
<p>读取单个字符。作为整数读取的字符，范围在0到65535之间（0x00-0xffff）(2个字节的 Unicode码)，如果已到达流的末尾，则返回-1。</p>
</li>
<li><p>int read（char[] cbuf）</p>
<p>将字符读入数组。如果已到达流的末尾，则返回-1。否则返回本次读取的字符数。</p>
</li>
<li><p>int read（char[] cbuf,int off,int len）</p>
<p>将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回-1。否则返回本次读取的字符数。</p>
</li>
<li><p>public void close throws IOException</p>
<p>关闭此输入流并释放与该流关联的所有系统资源</p>
</li>
</ul>
<p>3.3.2 OutputSteam &amp; Writer</p>
<ul>
<li>OutputStream和Writer也非常相似：<ul>
<li>void write(int b/int c);</li>
<li>void write(byte[] b/char[] cbuf);</li>
<li>void write(byte[] b/char[] buff,int off,int len);</li>
<li>void flush();</li>
<li>void close();需要先刷新，再关闭此流</li>
</ul>
</li>
<li>因为字符流直接以字符作为操作单位，所以 Writer可以用字符串来替换字符数组，即以 String对象作为参数<ul>
<li>void write(String str);</li>
<li>void write(String str,int off,int len);</li>
</ul>
</li>
<li>FileOutputStream从文件系统中的某个文件中获得输出字节。FileOutputstream用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter</li>
</ul>
<p><strong>OutputStream:</strong></p>
<ul>
<li><p>void write(int b)</p>
<p>将指定的字节写入此输出流。 write的常规协定是：向输出流写入一个字节。要写入的字节是参数b的八个低位。b的24个高位将被忽略。即写入0~255范围的</p>
</li>
<li><p>void write（byte[] b）</p>
<p>将b.length个字节从指定的byte数组写入此输出流。write（b）的常规协定是：应该与调用wite（b,0,b.length）的效果完全相同。</p>
</li>
<li><p>void write（byte[] b,int off,int len）</p>
<p>将指定byte数组中从偏移量off开始的len个字节写入此输出流。</p>
</li>
<li><p>public void flush()throws IOException</p>
<p>刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。</p>
</li>
<li><p>public void close throws IOException</p>
<p>关闭此输岀流并释放与该流关联的所有系统资源。</p>
</li>
</ul>
<p><strong>Writer:</strong></p>
<ul>
<li><p>void write(int c)</p>
<p>写入单个字符。要写入的字符包含在给定整数值的16个低位中，16高位被忽略。即写入0到65535之间的 Unicode码。</p>
</li>
<li><p>void write(char[] cbuf)</p>
<p>写入字符数组</p>
</li>
<li><p>void write(char[] cbuf,int off,int len)</p>
<p>写入字符数组的某一部分。从off开始，写入len个字符</p>
</li>
<li><p>void write(String str)</p>
<p>写入字符串。</p>
</li>
<li><p>void write(String str,int off,int len)</p>
<p>写入字符串的某一部分。</p>
</li>
<li><p>void flush()</p>
<p>刷新该流的缓冲，则立即将它们写入预期目标。</p>
</li>
<li><p>public void close throws IOException</p>
<p>关闭此输出流并释放与该流关联的所有系统资源</p>
</li>
</ul>
<h4 id="4-输入、输出标准化过程"><a href="#4-输入、输出标准化过程" class="headerlink" title="4. 输入、输出标准化过程"></a>4. 输入、输出标准化过程</h4><h5 id="4-1-输入过程："><a href="#4-1-输入过程：" class="headerlink" title="4.1 输入过程："></a>4.1 输入过程：</h5><p>① 创建File类的对象，指明读取的数据的来源。（要求此文件一定要存在）</p>
<p>② 创建相应的输入流，将File类的对象作为参数，传入流的构造器中</p>
<p>③ 具体的读入过程：创建相应的byte[] 或 char[]。</p>
<p>④ 关闭流资源</p>
<p>说明：程序中出现的异常需要使用try-catch-finally处理。</p>
<h5 id="4-2-输出过程："><a href="#4-2-输出过程：" class="headerlink" title="4.2 输出过程："></a>4.2 输出过程：</h5><p>① 创建File类的对象，指明写出的数据的位置。（不要求此文件一定要存在）</p>
<p>② 创建相应的输出流，将File类的对象作为参数，传入流的构造器中</p>
<p>③ 具体的写出过程：write(char[]/byte[] buffer,0,len)</p>
<p>④ 关闭流资源</p>
<p>说明：程序中出现的异常需要使用try-catch-finally处理。</p>
<h3 id="三、节点流（文件流）"><a href="#三、节点流（文件流）" class="headerlink" title="三、节点流（文件流）"></a>三、节点流（文件流）</h3><h4 id="1-文件字符流FileReader和FileWriter的使用"><a href="#1-文件字符流FileReader和FileWriter的使用" class="headerlink" title="1. 文件字符流FileReader和FileWriter的使用"></a>1. 文件字符流FileReader和FileWriter的使用</h4><h5 id="1-1文件的输入"><a href="#1-1文件的输入" class="headerlink" title="1.1文件的输入"></a>1.1文件的输入</h5><p>从文件中读取到内存（程序）中</p>
<p><strong>步骤：</strong></p>
<ol>
<li>建立一个流对象，将已存在的一个文件加载进流 FileReader fr = new FileReader(new File(“Test. txt”));</li>
<li>创建一个临时存放数据的数组 char[] ch = new char[1024];</li>
<li>调用流对象的读取方法将流中的数据读入到数组中。 fr.read(ch);</li>
<li>关闭资源。 fr.close();</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader1</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.File类的实例化</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.FileReader流的实例化</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.读入的操作</span></span><br><span class="line">        <span class="comment">//read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.资源的关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意点：</strong></p>
<ol>
<li>read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</li>
<li>异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</li>
<li>读入的文件一定要存在，否则就会报FileNotFoundException。</li>
</ol>
<h5 id="1-2-文件的输出"><a href="#1-2-文件的输出" class="headerlink" title="1.2 文件的输出"></a>1.2 文件的输出</h5><p>从内存（程序）到硬盘文件中</p>
<p><strong>步骤：</strong></p>
<ol>
<li>创建流对象，建立数据存放文件 File Writer fw = new File Writer(new File(“Test.txt”))</li>
<li>调用流对象的写入方法，将数据写入流 fw.write(“HelloWord”)</li>
<li>关闭流资源，并将流中的数据清空到文件中。 fw.close();</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.提供File类的对象，指明写出到的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.提供FileWriter的对象，用于数据的写出</span></span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.写出的操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;you need to have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.流资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-3-小练习"><a href="#1-3-小练习" class="headerlink" title="1.3 小练习"></a>1.3 小练习</h5><p>实现文本文件的复制操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReaderFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建File类的对象，指明读入和写出的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能使用字符流来处理图片等字节数据</span></span><br><span class="line">        <span class="comment">//            File srcFile = new File(&quot;test.jpg&quot;);</span></span><br><span class="line">        <span class="comment">//            File destFile = new File(&quot;test1.jpg&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建输入流和输出流的对象</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);</span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.数据的读入和写出操作</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;<span class="comment">//记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//每次写出len个字符</span></span><br><span class="line">            fw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭流资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="literal">null</span>)</span><br><span class="line">                fw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)</span><br><span class="line">                fr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-文件字节流FileInputSteam和FileOutputSteam的使用"><a href="#2-文件字节流FileInputSteam和FileOutputSteam的使用" class="headerlink" title="2. 文件字节流FileInputSteam和FileOutputSteam的使用"></a>2. 文件字节流FileInputSteam和FileOutputSteam的使用</h4><p>文件字节流操作与字符流操作类似，只是实例化对象操作和数据类型不同。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字节流FileInputStream处理文本文件，可能出现乱码。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.读数据</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;<span class="comment">//记录每次读取的字节的个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小练习</strong></p>
<p>实现图片文件复制操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputOutputStream</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建操流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-注意点-1"><a href="#3-注意点-1" class="headerlink" title="3. 注意点"></a>3. 注意点</h4><ul>
<li>定义路径时，可以用“/”或“\”。</li>
<li>输出操作，对应的File可以不存在的。并不会报异常。</li>
<li>File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</li>
<li>File对应的硬盘中的文件如果存在：<ul>
<li>如果流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原有文件的覆盖。</li>
<li>如果流使用的构造器是：FileWriter(file,true):不会对原有文件覆盖，而是在原有文件基础上追加内容。</li>
</ul>
</li>
<li>读取文件时，必须保证文件存在，否则会报异常。</li>
<li>对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理</li>
<li>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理</li>
</ul>
<h3 id="四、缓冲流"><a href="#四、缓冲流" class="headerlink" title="四、缓冲流"></a>四、缓冲流</h3><h4 id="1-缓冲流涉及到的类："><a href="#1-缓冲流涉及到的类：" class="headerlink" title="1. 缓冲流涉及到的类："></a>1. 缓冲流涉及到的类：</h4><ul>
<li>BufferedInputStream</li>
<li>BufferedOutputStream</li>
<li>BufferedReader</li>
<li>BufferedWriter</li>
</ul>
<h4 id="2-引入目的："><a href="#2-引入目的：" class="headerlink" title="2. 引入目的："></a>2. 引入目的：</h4><ul>
<li><p>作用：提供流的读取、写入的速度</p>
</li>
<li><p>提高读写速度的原因：内部提供了一个缓冲区。默认情况下是8kb</p>
<img src="/posts/3743959532/20200502110553.png" class="" title="image-20200502110552555"></li>
</ul>
<p><strong>处理流与节点流的对比图示</strong></p>
<img src="/posts/3743959532/20200502111051.png" class="" title="image-20200502111050587">

<img src="/posts/3743959532/20200502111058.png" class="" title="image-20200502111057666">



<h4 id="3-使用说明"><a href="#3-使用说明" class="headerlink" title="3. 使用说明"></a>3. 使用说明</h4><ul>
<li>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区。</li>
<li>当使用 BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。</li>
<li>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流。</li>
<li>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流。</li>
<li>flush()方法的使用：手动将buffer中内容写入文件。</li>
<li>如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出。</li>
</ul>
<p><strong>代码示例：</strong></p>
<h5 id="3-1使用BufferInputStream和BufferOutputStream实现非文本文件的复制"><a href="#3-1使用BufferInputStream和BufferOutputStream实现非文本文件的复制" class="headerlink" title="3.1使用BufferInputStream和BufferOutputStream实现非文本文件的复制"></a>3.1使用BufferInputStream和BufferOutputStream实现非文本文件的复制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test4.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        <span class="comment">//2.1造节点流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">//2.2造缓冲流，可以合并书写</span></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.文件读取、写出操作</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (bos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bis != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-2-使用BufferedReader和BufferedWriter实现文本文件的复制"><a href="#3-2-使用BufferedReader和BufferedWriter实现文本文件的复制" class="headerlink" title="3.2 使用BufferedReader和BufferedWriter实现文本文件的复制"></a>3.2 使用BufferedReader和BufferedWriter实现文本文件的复制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedReaderBufferedWriter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件和相应的流</span></span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>)));</span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp1.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读写操作</span></span><br><span class="line">        <span class="comment">//方式一：使用char[]数组</span></span><br><span class="line">        <span class="comment">//            char[] cbuf = new char[1024];</span></span><br><span class="line">        <span class="comment">//            int len;</span></span><br><span class="line">        <span class="comment">//            while((len = br.read(cbuf)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//                bw.write(cbuf,0,len);</span></span><br><span class="line">        <span class="comment">//    //            bw.flush();</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：使用String</span></span><br><span class="line">        String data;</span><br><span class="line">        <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//方法一：</span></span><br><span class="line">            <span class="comment">//                bw.write(data + &quot;\n&quot;);//data中不包含换行符</span></span><br><span class="line">            <span class="comment">//方法二：</span></span><br><span class="line">            bw.write(data);<span class="comment">//data中不包含换行符</span></span><br><span class="line">            bw.newLine();<span class="comment">//提供换行的操作</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(bw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-小练习"><a href="#4-小练习" class="headerlink" title="4. 小练习"></a>4. 小练习</h4><h5 id="4-1测试缓冲流和节点流文件复制速度"><a href="#4-1测试缓冲流和节点流文件复制速度" class="headerlink" title="4.1测试缓冲流和节点流文件复制速度"></a>4.1测试缓冲流和节点流文件复制速度</h5><p>节点流实现复制方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定路径下文件的复制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓冲流实现复制操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现文件复制的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileWithBuffered</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        <span class="comment">//2.1 造节点流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((srcFile));</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">//2.2 造缓冲流</span></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.复制的细节：读取、写入</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.资源关闭</span></span><br><span class="line">        <span class="comment">//要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">        <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试二者速度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCopyFileWithBuffered</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\01-视频.avi&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\03-视频.avi&quot;</span>;</span><br><span class="line"></span><br><span class="line">    copyFileWithBuffered(srcPath,destPath);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;复制操作花费的时间为：&quot;</span> + (end - start));<span class="comment">//618 - 176</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-2实现图片加密操作"><a href="#4-2实现图片加密操作" class="headerlink" title="4.2实现图片加密操作"></a>4.2实现图片加密操作</h5><p>加密操作</p>
<ul>
<li>将图片文件通过字节流读取到程序中</li>
<li>将图片的字节流逐一进行^操作</li>
<li>将处理后的图片字节流输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片的加密</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;testSecret.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buffer[i] = (<span class="type">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解密操作</p>
<ul>
<li>将加密后图片文件通过字节流读取到程序中</li>
<li>将图片的字节流逐一进行^操作（原理：A^B^B = A）</li>
<li>将处理后的图片字节流输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片的解密</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;testSecret.jpg&quot;</span>);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test4.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buffer[i] = (<span class="type">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-3-统计文本字符出现次数"><a href="#4-3-统计文本字符出现次数" class="headerlink" title="4.3 统计文本字符出现次数"></a>4.3 统计文本字符出现次数</h5><p>实现思路：</p>
<ol>
<li>遍历文本每一个字符</li>
<li>字符出现的次数存在Map中</li>
<li>把map中的数据写入文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWordCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建Map集合</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.遍历每一个字符,每一个字符出现的次数放到map中</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((c = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//int 还原 char</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> (<span class="type">char</span>) c;</span><br><span class="line">            <span class="comment">// 判断char是否在map中第一次出现</span></span><br><span class="line">            <span class="keyword">if</span> (map.get(ch) == <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(ch, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(ch, map.get(ch) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.把map中数据存在文件count.txt</span></span><br><span class="line">        <span class="comment">//3.1 创建Writer</span></span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;wordcount.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.2 遍历map,再写入数据</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : entrySet) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (entry.getKey()) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                    bw.write(<span class="string">&quot;空格=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:<span class="comment">//\t表示tab 键字符</span></span><br><span class="line">                    bw.write(<span class="string">&quot;tab键=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:<span class="comment">//</span></span><br><span class="line">                    bw.write(<span class="string">&quot;回车=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:<span class="comment">//</span></span><br><span class="line">                    bw.write(<span class="string">&quot;换行=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    bw.write(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关流</span></span><br><span class="line">        <span class="keyword">if</span> (fr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bw != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="五、转换流"><a href="#五、转换流" class="headerlink" title="五、转换流"></a>五、转换流</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><ul>
<li>转换流提供了在字节流和字符流之间的转换</li>
<li>Java API提供了两个转换流：<ul>
<li>InputstreamReader：将 Inputstream转换为Reader</li>
<li>OutputStreamWriter：将 Writer转换为OutputStream</li>
</ul>
</li>
<li>字节流中的数据都是字符时，转成字符流操作更高效。</li>
<li>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。</li>
</ul>
<h5 id="1-1-InputStreamReader"><a href="#1-1-InputStreamReader" class="headerlink" title="1.1 InputStreamReader"></a>1.1 InputStreamReader</h5><p>InputStreamReader将一个字节的输入流转换为字符的输入流 解码：字节、字节数组 —&gt;字符数组、字符串</p>
<p>构造器：</p>
<ul>
<li>public InputStreamReader(InputStream in)</li>
<li>public InputStreamReader(Inputstream in,String charsetName)//可以指定编码集</li>
</ul>
<h5 id="1-2-OutputStreamWriter"><a href="#1-2-OutputStreamWriter" class="headerlink" title="1.2 OutputStreamWriter"></a>1.2 OutputStreamWriter</h5><p>OutputStreamWriter将一个字符的输出流转换为字节的输出流 编码：字符数组、字符串 —&gt; 字节、字节数组</p>
<p>构造器：</p>
<ul>
<li>public OutputStreamWriter(OutputStream out)</li>
<li>public OutputStreamWriter(Outputstream out,String charsetName)//可以指定编码集</li>
</ul>
<p><strong>图示：</strong></p>
<img src="/posts/3743959532/20200502114234.png" class="" title="image-20200502114233303">



<h4 id="2-代码示例："><a href="#2-代码示例：" class="headerlink" title="2.代码示例："></a>2.代码示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">综合使用InputStreamReader和OutputStreamWriter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件、造流</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp_gbk.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line"></span><br><span class="line">        isr = <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        osw = <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读写过程</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关流</span></span><br><span class="line">        <span class="keyword">if</span> (isr != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                isr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (osw != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                osw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：文件编码的方式（比如：GBK），决定了解析时使用的字符集（也只能是GBK）。</p>
</blockquote>
<h4 id="3-编码集"><a href="#3-编码集" class="headerlink" title="3. 编码集"></a>3. 编码集</h4><h5 id="3-1-常见的编码表"><a href="#3-1-常见的编码表" class="headerlink" title="3.1 常见的编码表"></a>3.1 常见的编码表</h5><ul>
<li>ASCII：美国标准信息交换码。用一个字节的7位可以表示。</li>
<li>ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。</li>
<li>GB2312：中国的中文编码表。最多两个字节编码所有字符</li>
<li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</li>
<li>Unicode：国际标准码，融合了目前人类使用的所字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li>
<li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</li>
</ul>
<img src="/posts/3743959532/20200502120240.png" class="" title="image-20200502120238023">

<p><strong>说明：</strong></p>
<ul>
<li>面向传输的众多UTF(UCS Transfer Format)标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</li>
<li>Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。</li>
</ul>
<p><strong>UTF-8变长编码表示</strong></p>
<img src="/posts/3743959532/20200502120043.png" class="" title="image-20200502120042318">



<h5 id="3-2-编码应用"><a href="#3-2-编码应用" class="headerlink" title="3.2 编码应用"></a>3.2 编码应用</h5><ul>
<li>编码：字符串–&gt;字节数组</li>
<li>解码：字节数组–&gt;字符串</li>
<li>转换流的编码应用<ul>
<li>可以将字符按指定编码格式存储</li>
<li>可以对文本数据按指定编码格式来解读</li>
<li>指定编码表的动作由构造器完成</li>
</ul>
</li>
</ul>
<p><strong>使用要求：</strong></p>
<p>客户端/浏览器端 &lt;—-&gt; 后台(java,GO,Python,Node.js,php) &lt;—-&gt; 数据库</p>
<p>要求前前后后使用的字符集都要统一：UTF-8.</p>
<h3 id="六、标准输入、输出流"><a href="#六、标准输入、输出流" class="headerlink" title="六、标准输入、输出流"></a>六、标准输入、输出流</h3><h4 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h4><p><a target="_blank" rel="noopener" href="http://system.in/">System.in</a>:标准的输入流，默认从键盘输入</p>
<p>System.out:标准的输出流，默认从控制台输出</p>
<h4 id="2-主要方法"><a href="#2-主要方法" class="headerlink" title="2. 主要方法"></a>2. 主要方法</h4><p>System类的setIn(InputStream is) 方式重新指定输入的流</p>
<p>System类的setOut(PrintStream ps)方式重新指定输出的流。</p>
<h4 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3. 使用示例"></a>3. 使用示例</h4><p>从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，</p>
<p>直至当输入“e”或者“exit”时，退出程序。</p>
<p><strong>设计思路</strong></p>
<p>方法一：使用Scanner实现，调用next()返回一个字符串</p>
<p>方法二：使用System.in实现。<a target="_blank" rel="noopener" href="http://system.in/">System.in</a> —&gt; 转换流 —&gt; BufferedReader的readLine()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(data) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(data)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">upperCase</span> <span class="operator">=</span> data.toUpperCase();</span><br><span class="line">            System.out.println(upperCase);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-小练习-1"><a href="#4-小练习-1" class="headerlink" title="4. 小练习"></a>4. 小练习</h4><p>设计实现Scanner类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInput</span> &#123;</span><br><span class="line">    <span class="comment">// Read a string from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declare and initialize the string</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the string from the keyboard</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            string = br.readLine();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the string obtained from the keyboard</span></span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read an int value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a double value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a byte value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readByte</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Byte.parseByte(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a short value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readShort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Short.parseShort(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a long value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readLong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a float value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readFloat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Float.parseFloat(readString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="七、打印流"><a href="#七、打印流" class="headerlink" title="七、打印流"></a>七、打印流</h3><p>PrintStream 和 PrintWriter <strong>说明：</strong></p>
<ul>
<li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\text.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\n&#x27; 时都会刷新输出缓冲区)</span></span><br><span class="line">        ps = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fos, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;<span class="comment">// 把标准输出流(控制台输出)改成文件</span></span><br><span class="line">            System.setOut(ps);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123; <span class="comment">// 输出ASCII字符</span></span><br><span class="line">            System.out.print((<span class="type">char</span>) i);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span>) &#123; <span class="comment">// 每50个数据一行</span></span><br><span class="line">                System.out.println(); <span class="comment">// 换行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="八、数据流"><a href="#八、数据流" class="headerlink" title="八、数据流"></a>八、数据流</h3><p>DataInputStream 和 DataOutputStream <strong>作用：</strong> 用于读取或写出基本数据类型的变量或字符串</p>
<p><strong>示例代码：</strong></p>
<p>将内存中的字符串、基本数据类型的变量写出到文件中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.造对象、造流</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dos = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//数据输出</span></span><br><span class="line">        dos.writeUTF(<span class="string">&quot;Bruce&quot;</span>);</span><br><span class="line">        dos.flush();<span class="comment">//刷新操作，将内存的数据写入到文件</span></span><br><span class="line">        dos.writeInt(<span class="number">23</span>);</span><br><span class="line">        dos.flush();</span><br><span class="line">        dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        dos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (dos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造对象、造流</span></span><br><span class="line">        dis = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//2.从文件读入数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;age:&quot;</span>+age);</span><br><span class="line">        System.out.println(<span class="string">&quot;isMale:&quot;</span>+isMale);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (dis != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="九、对象流"><a href="#九、对象流" class="headerlink" title="九、对象流"></a>九、对象流</h3><h4 id="1-对象流："><a href="#1-对象流：" class="headerlink" title="1.对象流："></a>1.对象流：</h4><p>ObjectInputStream 和 ObjectOutputStream</p>
<h4 id="2-作用："><a href="#2-作用：" class="headerlink" title="2.作用："></a>2.作用：</h4><ul>
<li>ObjectOutputStream:内存中的对象—&gt;存储中的文件、通过网络传输出去：序列化过程</li>
<li>ObjectInputStream:存储中的文件、通过网络接收过来 —&gt;内存中的对象：反序列化过程</li>
</ul>
<h4 id="3-对象的序列化"><a href="#3-对象的序列化" class="headerlink" title="3. 对象的序列化"></a>3. 对象的序列化</h4><ul>
<li>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</li>
<li>序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原。</li>
<li>序列化是RMI(Remote Method Invoke-远程方法调用)过程的参数和返回值都必须实现的机制，RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础。</li>
<li>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出 NotserializableEXception异常<ul>
<li>Serializable</li>
<li>Externalizable</li>
</ul>
</li>
<li>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：<ul>
<li>private static final long serialVersionUID;</li>
<li>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID可能发生变化。故建议显式声明。</li>
</ul>
</li>
<li>简单来说，Java的序列化机制是通过在运行时判断类的serialversionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialversionUID与本地相应实体类的serialversionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)</li>
</ul>
<h4 id="4-实现序列化的对象所属的类需要满足："><a href="#4-实现序列化的对象所属的类需要满足：" class="headerlink" title="4.实现序列化的对象所属的类需要满足："></a>4.实现序列化的对象所属的类需要满足：</h4><ol>
<li>需要实现接口：Serializable（标识接口）</li>
<li>当前类提供一个全局常量：serialVersionUID（序列版本号）</li>
<li>除了当前Person类需要实现Serializable接口之外，还必须保证其内部所属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</li>
</ol>
<p>补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p>
<h4 id="5-对象流的使用"><a href="#5-对象流的使用" class="headerlink" title="5. 对象流的使用"></a>5. 对象流的使用</h4><h5 id="5-1序列化代码实现"><a href="#5-1序列化代码实现" class="headerlink" title="5.1序列化代码实现"></a>5.1序列化代码实现</h5><p>序列化：将对象写入磁盘或进行网络传输</p>
<p>要求被序列化对象必须实现序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectOutputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建对象，创建流</span></span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">        <span class="comment">//2.操作流</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱北京天安门&quot;</span>));</span><br><span class="line">        oos.flush();<span class="comment">//刷新操作</span></span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王铭&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张学良&quot;</span>,<span class="number">23</span>,<span class="number">1001</span>,<span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">5000</span>)));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(oos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//3.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-2-反序列化代码实现"><a href="#5-2-反序列化代码实现" class="headerlink" title="5.2 反序列化代码实现"></a>5.2 反序列化代码实现</h5><p>反序列化：将磁盘的对象数据源读出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectInputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ois != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="十、任意存取文件流"><a href="#十、任意存取文件流" class="headerlink" title="十、任意存取文件流"></a>十、任意存取文件流</h3><p>RandomAccessFile的使用</p>
<h4 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a>1.简介</h4><ul>
<li>RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口</li>
<li>RandomAccessFile既可以作为一个输入流，又可以作为一个输出流</li>
<li>RandomAccessFile类支持“随机访问”的方式，程序可以直接跳到文件的任意地方来读、写文件<ul>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul>
</li>
<li>RandomAccessFile对象包含一个记录指针，用以标示当前读写处的位置</li>
<li>RandomaccessFile类对象可以自由移动记录指针：<ul>
<li>long getFilePointer()：获取文件记录指针的当前位置</li>
<li>void seek(long pos)：将文件记录指针定位到pos位置</li>
</ul>
</li>
</ul>
<p><strong>构造器</strong></p>
<p>public RandomAccessFile(File file,String mode)</p>
<p>public RandomAccessFile(String name,String mode)</p>
<h4 id="2-使用说明："><a href="#2-使用说明：" class="headerlink" title="2.使用说明："></a>2.使用说明：</h4><ol>
<li>如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。</li>
<li>如果写出到的文件存在，则会对原文件内容进行覆盖。（默认情况下，从头覆盖）</li>
<li>可以通过相关的操作，实现RandomAccessFile“插入”数据的效果。借助seek(int pos)方法</li>
<li>创建RandomAccessFile类实例需要指定一个mode参数，该参数指定RandomAccessFile的访问模式:<ul>
<li>r：以只读方式打开</li>
<li>rw：打开以便读取和写入</li>
<li>rwd：打开以便读取和写入；同步文件内容的更新</li>
<li>rws：打开以便读取和写入；同步文件内容和元数据的更新</li>
</ul>
</li>
<li>如果模式为只读r,则不会创建文件，而是会去读取一个已经存在的文件,读取的文件不存在则会出现异常。如果模式为rw读写,文件不存在则会去创建文件，存在则不会创建。</li>
</ol>
<h4 id="3-使用示例-1"><a href="#3-使用示例-1" class="headerlink" title="3. 使用示例"></a>3. 使用示例</h4><p>文件的读取和写出操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建对象，创建流</span></span><br><span class="line">        raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        raf2 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//2.操作流</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            raf2.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        <span class="keyword">if</span>(raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(raf2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用RandomAccessFile实现数据的插入效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        raf1.seek(<span class="number">3</span>);<span class="comment">//将指针调到角标为3的位置</span></span><br><span class="line">        <span class="comment">//            //方式一</span></span><br><span class="line">        <span class="comment">//            //保存指针3后面的所有数据到StringBuilder中</span></span><br><span class="line">        <span class="comment">//            StringBuilder builder = new StringBuilder((int) new File(&quot;hello.txt&quot;).length());</span></span><br><span class="line">        <span class="comment">//            byte[] buffer = new byte[20];</span></span><br><span class="line">        <span class="comment">//            int len;</span></span><br><span class="line">        <span class="comment">//            while ((len = raf1.read(buffer)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//                builder.append(new String(buffer,0,len));</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调回指针，写入“xyz”</span></span><br><span class="line">        raf1.seek(<span class="number">3</span>);</span><br><span class="line">        raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//将StringBuilder中的数据写入到文件中</span></span><br><span class="line">        raf1.write(baos.toString().getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="十一、流的基本应用总结"><a href="#十一、流的基本应用总结" class="headerlink" title="十一、流的基本应用总结"></a>十一、流的基本应用总结</h3><ul>
<li><p>流是用来处理数据的。</p>
</li>
<li><p>处理数据时，一定要先明确数据源，与数据目的地数据源可以是文件，可以是键盘数据目的地可以是文件、显示器或者其他设备</p>
</li>
<li><p>而流只是在帮助数据进行传输，并对传输的数据进行处理，比如过滤处理、转换处理等</p>
</li>
<li><p>除去RandomAccessFile类外所有的流都继承于四个基本数据流抽象类InputSteam、OutputSteam、Reader、Writer</p>
</li>
<li><p>不同的操作流对应的后缀均为四个抽象基类中的某一个</p>
<img src="/posts/3743959532/20200502091616.png" class="" title="image-20200502091615386"></li>
<li><p>不同处理流的使用方式都是标准操作：</p>
<ul>
<li>创建文件对象，创建相应的流</li>
<li>处理流数据</li>
<li>关闭流</li>
<li>用try-catch-finally处理异常</li>
</ul>
</li>
</ul>
<h3 id="十二、NIO"><a href="#十二、NIO" class="headerlink" title="十二、NIO"></a>十二、NIO</h3><p>Path、Paths、Files的使用，介绍比较简单，后期会再抽时间详细写有关NIO的博客。</p>
<h4 id="1-NIO的使用说明："><a href="#1-NIO的使用说明：" class="headerlink" title="1.NIO的使用说明："></a>1.NIO的使用说明：</h4><ul>
<li>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO AP。</li>
<li>NIO与原来的IO同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。</li>
<li>NIO将以更加高效的方式进行文件的读写操作。</li>
<li>JDK 7.0对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，称他为 NIO.2。</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO</span><br><span class="line">|-----java.nio.channels.Channel</span><br><span class="line">      |---- FileChannel：处理本地文件</span><br><span class="line">      |---- SocketChannel：TCP网络编程的客户端的Channel</span><br><span class="line">      |---- ServerSocketChannel：TCP网络编程的服务器端的Channel</span><br><span class="line">      |---- DatagramChannel：UDP网络编程中发送端和接收端的Channel</span><br></pre></td></tr></table></figure>



<h4 id="2-Path接口-—JDK-7-0提供"><a href="#2-Path接口-—JDK-7-0提供" class="headerlink" title="2.Path接口 —JDK 7.0提供"></a>2.Path接口 —JDK 7.0提供</h4><ul>
<li>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</li>
<li>NIO.2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资源也可以不存在。</li>
</ul>
<h5 id="2-1Path的说明："><a href="#2-1Path的说明：" class="headerlink" title="2.1Path的说明："></a>2.1Path的说明：</h5><p>Path替换原有的File类。</p>
<ul>
<li>在以前IO操作都是这样写的：<ul>
<li>import java.io.File</li>
<li>File file = new File(“index.html”);</li>
</ul>
</li>
<li>但在Java7中，我们可以这样写：<ul>
<li>import java.nio.file.Path;</li>
<li>import java.nio.file.Paths;</li>
<li>Path path = Paths.get(“index. html”);</li>
</ul>
</li>
</ul>
<h5 id="2-2-Paths的使用"><a href="#2-2-Paths的使用" class="headerlink" title="2.2 Paths的使用"></a>2.2 Paths的使用</h5><ul>
<li>Paths类提供的静态get()方法用来获取Path对象：</li>
<li>static Path get(String first， String….more)：用于将多个字符串串连成路径</li>
<li>static Path get(URI uri)：返回指定uri对应的Path路径</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;hello.txt&quot;</span>);<span class="comment">//new File(String filepath)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\&quot;</span>, <span class="string">&quot;test\\test1\\haha.txt&quot;</span>);<span class="comment">//new File(String parent,String filename);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path3</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(path1);</span><br><span class="line">    System.out.println(path2);</span><br><span class="line">    System.out.println(path3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-3-常用方法"><a href="#2-3-常用方法" class="headerlink" title="2.3 常用方法"></a>2.3 常用方法</h5><ul>
<li>String toString() ： 返回调用 Path 对象的字符串表示形式</li>
<li>boolean startsWith(String path) : 判断是否以 path 路径开始</li>
<li>boolean endsWith(String path) : 判断是否以 path 路径结束</li>
<li>boolean isAbsolute() : 判断是否是绝对路径</li>
<li>Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</li>
<li>Path getRoot() ：返回调用 Path 对象的根路径</li>
<li>Path getFileName() : 返回与调用 Path 对象关联的文件名</li>
<li>int getNameCount() : 返回Path 根目录后面元素的数量</li>
<li>Path getName(int idx) : 返回指定索引位置 idx 的路径名称</li>
<li>Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</li>
<li>Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象</li>
<li>File toFile(): 将Path转化为File类的对象</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\&quot;</span>, <span class="string">&quot;nio\\nio1\\nio2\\hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//		String toString() ： 返回调用 Path 对象的字符串表示形式</span></span><br><span class="line">    System.out.println(path1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//		boolean startsWith(String path) : 判断是否以 path 路径开始</span></span><br><span class="line">    System.out.println(path1.startsWith(<span class="string">&quot;d:\\nio&quot;</span>));</span><br><span class="line">    <span class="comment">//		boolean endsWith(String path) : 判断是否以 path 路径结束</span></span><br><span class="line">    System.out.println(path1.endsWith(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//		boolean isAbsolute() : 判断是否是绝对路径</span></span><br><span class="line">    System.out.println(path1.isAbsolute() + <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    System.out.println(path2.isAbsolute() + <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    <span class="comment">//		Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</span></span><br><span class="line">    System.out.println(path1.getParent());</span><br><span class="line">    System.out.println(path2.getParent());</span><br><span class="line">    <span class="comment">//		Path getRoot() ：返回调用 Path 对象的根路径</span></span><br><span class="line">    System.out.println(path1.getRoot());</span><br><span class="line">    System.out.println(path2.getRoot());</span><br><span class="line">    <span class="comment">//		Path getFileName() : 返回与调用 Path 对象关联的文件名</span></span><br><span class="line">    System.out.println(path1.getFileName() + <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    System.out.println(path2.getFileName() + <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    <span class="comment">//		int getNameCount() : 返回Path 根目录后面元素的数量</span></span><br><span class="line">    <span class="comment">//		Path getName(int idx) : 返回指定索引位置 idx 的路径名称</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path1.getNameCount(); i++) &#123;</span><br><span class="line">        System.out.println(path1.getName(i) + <span class="string">&quot;*****&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//		Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</span></span><br><span class="line">    System.out.println(path1.toAbsolutePath());</span><br><span class="line">    System.out.println(path2.toAbsolutePath());</span><br><span class="line">    <span class="comment">//		Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path3</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\&quot;</span>, <span class="string">&quot;nio&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path4</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;nioo\\hi.txt&quot;</span>);</span><br><span class="line">    path3 = path3.resolve(path4);</span><br><span class="line">    System.out.println(path3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//		File toFile(): 将Path转化为File类的对象</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> path1.toFile();<span class="comment">//Path---&gt;File的转换</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Path</span> <span class="variable">newPath</span> <span class="operator">=</span> file.toPath();<span class="comment">//File---&gt;Path的转换</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-Files类"><a href="#3-Files类" class="headerlink" title="3.Files类"></a>3.Files类</h4><p>java.nio.file.Files用于操作文件或目录的工具类</p>
<h5 id="3-1-Files类常用方法"><a href="#3-1-Files类常用方法" class="headerlink" title="3.1 Files类常用方法"></a>3.1 Files类常用方法</h5><ul>
<li><p>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</p>
<p>要想复制成功，要求path1对应的物理上的文件存在。path1对应的文件没有要求。</p>
</li>
<li><p>Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING);</p>
</li>
<li><p>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录</p>
<p>要想执行成功，要求path对应的物理上的文件目录不存在。一旦存在，抛出异常。</p>
</li>
<li><p>Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件</p>
</li>
<li><p>要想执行成功，要求path对应的物理上的文件不存在。一旦存在，抛出异常。</p>
</li>
<li><p>void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错</p>
</li>
<li><p>void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除.如果不存在，正常执行结束</p>
</li>
<li><p>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</p>
<p>要想执行成功，src对应的物理上的文件需要存在，dest对应的文件没有要求。</p>
</li>
<li><p>long size(Path path) : 返回 path 指定文件的大小</p>
</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//		Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</span></span><br><span class="line">    <span class="comment">//要想复制成功，要求path1对应的物理上的文件存在。path1对应的文件没有要求。</span></span><br><span class="line">    <span class="comment">//		Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//		Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录</span></span><br><span class="line">    <span class="comment">//要想执行成功，要求path对应的物理上的文件目录不存在。一旦存在，抛出异常。</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path3</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio\\nio1&quot;</span>);</span><br><span class="line">    <span class="comment">//		Files.createDirectory(path3);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//		Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件</span></span><br><span class="line">    <span class="comment">//要想执行成功，要求path对应的物理上的文件不存在。一旦存在，抛出异常。</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path4</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio\\hi.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//		Files.createFile(path4);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//		void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错</span></span><br><span class="line">    <span class="comment">//		Files.delete(path4);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//		void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除.如果不存在，正常执行结束</span></span><br><span class="line">    Files.deleteIfExists(path3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//		Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</span></span><br><span class="line">    <span class="comment">//要想执行成功，src对应的物理上的文件需要存在，dest对应的文件没有要求。</span></span><br><span class="line">    <span class="comment">//		Files.move(path1, path2, StandardCopyOption.ATOMIC_MOVE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//		long size(Path path) : 返回 path 指定文件的大小</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Files.size(path2);</span><br><span class="line">    System.out.println(size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="3-2-Files类常用方法：用于判断"><a href="#3-2-Files类常用方法：用于判断" class="headerlink" title="3.2 Files类常用方法：用于判断"></a>3.2 Files类常用方法：用于判断</h5><ul>
<li><p>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</p>
</li>
<li><p>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</p>
<p>不要求此path对应的物理文件存在。</p>
</li>
<li><p>boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</p>
</li>
<li><p>boolean isHidden(Path path) : 判断是否是隐藏文件</p>
<p>要求此path对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常。</p>
</li>
<li><p>boolean isReadable(Path path) : 判断文件是否可读</p>
</li>
<li><p>boolean isWritable(Path path) : 判断文件是否可写</p>
</li>
<li><p>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</p>
</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//		boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</span></span><br><span class="line">    System.out.println(Files.exists(path2, LinkOption.NOFOLLOW_LINKS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//		boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</span></span><br><span class="line">    <span class="comment">//不要求此path对应的物理文件存在。</span></span><br><span class="line">    System.out.println(Files.isDirectory(path1, LinkOption.NOFOLLOW_LINKS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//		boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//		boolean isHidden(Path path) : 判断是否是隐藏文件</span></span><br><span class="line">    <span class="comment">//要求此path对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常。</span></span><br><span class="line">    <span class="comment">//		System.out.println(Files.isHidden(path1));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//		boolean isReadable(Path path) : 判断文件是否可读</span></span><br><span class="line">    System.out.println(Files.isReadable(path1));</span><br><span class="line">    <span class="comment">//		boolean isWritable(Path path) : 判断文件是否可写</span></span><br><span class="line">    System.out.println(Files.isWritable(path1));</span><br><span class="line">    <span class="comment">//		boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</span></span><br><span class="line">    System.out.println(Files.notExists(path1, LinkOption.NOFOLLOW_LINKS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong></p>
<ul>
<li>StandardOpenOption.READ:表示对应的Channel是可读的。</li>
<li>StandardOpenOption.WRITE：表示对应的Channel是可写的。</li>
<li>StandardOpenOption.CREATE：如果要写出的文件不存在，则创建。如果存在，忽略</li>
<li>StandardOpenOption.CREATE_NEW：如果要写出的文件不存在，则创建。如果存在，抛异常</li>
</ul>
<h5 id="3-3-Files类常用方法：用于操作内容"><a href="#3-3-Files类常用方法：用于操作内容" class="headerlink" title="3.3 Files类常用方法：用于操作内容"></a>3.3 Files类常用方法：用于操作内容</h5><ul>
<li>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</li>
<li>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</li>
<li>SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。</li>
<li>DirectoryStream<Path> newDirectoryStream(Path path) : 打开 path 指定的目录</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//		InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Files.newInputStream(path1, StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//		OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> Files.newOutputStream(path1, StandardOpenOption.WRITE,StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//		SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。</span></span><br><span class="line">    <span class="type">SeekableByteChannel</span> <span class="variable">channel</span> <span class="operator">=</span> Files.newByteChannel(path1, StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//		DirectoryStream&lt;Path&gt;  newDirectoryStream(Path path) : 打开 path 指定的目录</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;e:\\teach&quot;</span>);</span><br><span class="line">    DirectoryStream&lt;Path&gt; directoryStream = Files.newDirectoryStream(path2);</span><br><span class="line">    Iterator&lt;Path&gt; iterator = directoryStream.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="十四、网络编程"><a href="#十四、网络编程" class="headerlink" title="十四、网络编程"></a>十四、网络编程</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><ol>
<li>计算机网络：<ul>
<li>把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息共享硬件、软件、数据信息等资源。</li>
</ul>
</li>
<li>网络编程的目的: 直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯</li>
<li>实现网络通信需要解决的两个问题:<ul>
<li>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用</li>
<li>找到主机后如何可靠高效地进行数据传输</li>
</ul>
</li>
</ol>
<h3 id="二、网络通讯要素"><a href="#二、网络通讯要素" class="headerlink" title="二、网络通讯要素"></a>二、网络通讯要素</h3><ul>
<li>解决问题一：IP和端口号</li>
<li>解决问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层）</li>
</ul>
<p><strong>网络通讯协议</strong></p>
<img src="/posts/3743959532/20200503155401.png" class="" title="image-20200503155354025">

<p><strong>通讯过程</strong></p>
<img src="/posts/3743959532/20200503155429.png" class="" title="image-20200503155428227">

<h4 id="3-通讯要素一：IP和端口号"><a href="#3-通讯要素一：IP和端口号" class="headerlink" title="3. 通讯要素一：IP和端口号"></a>3. 通讯要素一：IP和端口号</h4><h5 id="3-1-IP的理解"><a href="#3-1-IP的理解" class="headerlink" title="3.1 IP的理解"></a>3.1 IP的理解</h5><ul>
<li><p>IP:唯一的标识 Internet 上的计算机（通信实体）</p>
</li>
<li><p>在Java中使用InetAddress类代表IP</p>
</li>
<li><p>IP分类：IPv4 和 IPv6 ; 万维网 和 局域网</p>
</li>
<li><p>域名: 通过域名解析服务器将域名解析为IP地址 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> <a target="_blank" rel="noopener" href="http://www.mi.com/">www.mi.com</a> <a target="_blank" rel="noopener" href="http://www.jd.com/">www.jd.com</a></p>
</li>
<li><p>域名解析：域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成IP地址，这样才能和主机建立连接。</p>
</li>
<li><p>本地回路地址：127.0.0.1 对应着：localhost</p>
</li>
</ul>
<h5 id="3-2-端口号："><a href="#3-2-端口号：" class="headerlink" title="3.2 端口号："></a>3.2 端口号：</h5><p>用于标识正在计算机上运行的进程。</p>
<ul>
<li>要求：不同的进程不同的端口号</li>
<li>范围：被规定为一个 16 位的整数 0~65535。</li>
<li>分类：<ul>
<li>公认端口：0~1023.被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，TeInet占用端口23）。</li>
<li>注册端口：1024~49151.分配给用户进程或应用程序。（如：Tomcat占用端口8080，MSQL占用端口3306，Oracle占用端口1521等）。</li>
<li>动态私有端口：49152~65535。</li>
</ul>
</li>
</ul>
<h5 id="3-3-InetAddress类"><a href="#3-3-InetAddress类" class="headerlink" title="3.3 InetAddress类"></a>3.3 InetAddress类</h5><p>此类的一个对象就代表着一个具体的IP地址</p>
<h6 id="3-2-1实例化"><a href="#3-2-1实例化" class="headerlink" title="3.2.1实例化"></a>3.2.1实例化</h6><p>getByName(String host) /getLocalHost()</p>
<h6 id="3-2-2常用方法"><a href="#3-2-2常用方法" class="headerlink" title="3.2.2常用方法"></a>3.2.2常用方法</h6><p>getHostName() / getHostAddress()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAddressTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.10.14&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(inet1);</span><br><span class="line"></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">            System.out.println(inet2);</span><br><span class="line"></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet3</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            System.out.println(inet3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取本地ip</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet4</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(inet4);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//getHostName()</span></span><br><span class="line">            System.out.println(inet2.getHostName());</span><br><span class="line">            <span class="comment">//getHostAddress()</span></span><br><span class="line">            System.out.println(inet2.getHostAddress());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-通信要素二：网络通信协议"><a href="#4-通信要素二：网络通信协议" class="headerlink" title="4. 通信要素二：网络通信协议"></a>4. 通信要素二：网络通信协议</h4><h5 id="4-1分层模型"><a href="#4-1分层模型" class="headerlink" title="4.1分层模型"></a>4.1分层模型</h5><img src="/posts/3743959532/20200503160651.png" class="" title="image-20200503160650146">

<h5 id="4-2-TCP和UDP的区别"><a href="#4-2-TCP和UDP的区别" class="headerlink" title="4.2 TCP和UDP的区别"></a>4.2 TCP和UDP的区别</h5><p><strong>TCP协议</strong>：</p>
<ul>
<li>使用TCP协议前，须先建立TCP连接，形成传输数据通道</li>
<li>传输前，采用“三次握手”方式，点对点通信，是可靠的</li>
<li>TCP协议进行通信的两个应用进程：客户端、服务端。</li>
<li>在连接中可进行大数据量的传输</li>
<li>传输完毕，需释放已建立的连接，效率低</li>
</ul>
<p><strong>UDP协议：</strong></p>
<ul>
<li>将数据、源、目的封装成数据包，不需要建立连接</li>
<li>每个数据报的大小限制在64K内</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>
<li>可以广播发送</li>
<li>发送数据结束时无需释放资源，开销小，速度快</li>
</ul>
<h5 id="4-3-TCP三次握手和四次挥手"><a href="#4-3-TCP三次握手和四次挥手" class="headerlink" title="4.3 TCP三次握手和四次挥手"></a>4.3 TCP三次握手和四次挥手</h5><img src="/posts/3743959532/20200503160946.png" class="" title="image-20200503160945073">

<img src="/posts/3743959532/20200503160954.png" class="" title="image-20200503160952992">

<h4 id="5-套接字Socket"><a href="#5-套接字Socket" class="headerlink" title="5. 套接字Socket"></a>5. 套接字Socket</h4><p>端口号与IP地址的组合得出一个网络套接字：Socket</p>
<ul>
<li>利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。</li>
<li>网络上具有唯一标识的P地址和端口号组合在一起才能构成唯一能识别的标识符套接字。</li>
<li>通信的两端都要有 Socket，是两台机器间通信的端点。</li>
<li>网络通信其实就是 Socket间的通信</li>
<li>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</li>
<li>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端</li>
<li>Socket分类<ul>
<li>流套接字(stream socket)：使用TCP提供可依赖的字节流服务</li>
<li>数据报套接字(datagram socket)：使用UDP提供“尽力而为”的数据报服务</li>
</ul>
</li>
</ul>
<img src="/posts/3743959532/20200503162306.png" class="" title="image-20200503162305170">

<h3 id="三、TCP网络编程"><a href="#三、TCP网络编程" class="headerlink" title="三、TCP网络编程"></a>三、TCP网络编程</h3><p>Java语言的基于套接字Socket编程分为客户端和服务端</p>
<p><strong>基于TCP的Socket通信模型</strong></p>
<img src="/posts/3743959532/20200503162559.png" class="" title="image-20200503162557927">

<h4 id="1-基于Socke的TCP编程"><a href="#1-基于Socke的TCP编程" class="headerlink" title="1.基于Socke的TCP编程"></a>1.基于Socke的TCP编程</h4><h5 id="1-1客户端Socket的工作过程"><a href="#1-1客户端Socket的工作过程" class="headerlink" title="1.1客户端Socket的工作过程"></a>1.1客户端Socket的工作过程</h5><ul>
<li>创建Socket：根据指定服务端的P地址或端口号构造Sσcket类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li>
<li>打开连接到 Socket的输入出流：使用getInputstream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输</li>
<li>按照一定的协议对Socket进行读/写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程</li>
<li>关闭 Socket：断开客户端到服务器的连接，释放线路</li>
</ul>
<p><strong>说明</strong>：</p>
<ul>
<li>客户端程序可以使用Socket类创建对象，创建的同时会自动向服务器方发起连接。</li>
<li>Socket的构造器是：<ul>
<li>Socket(String host，int port) throws UnknownHostException，EXCeption：向服务器（域名是host,端口号为port）发起TCP连接，若成功，则创建Socket对象，否则抛出异常。</li>
<li>Socket(InetAddress address，int port)throws IOException：根据InetAddress对象所表示的IP地址以及端口号port发起连接</li>
</ul>
</li>
<li>客户端建立 socketAtClient对象的过程就是向服务器发出套接字连接请求</li>
</ul>
<h5 id="1-2-服务器端Socket的工作过程："><a href="#1-2-服务器端Socket的工作过程：" class="headerlink" title="1.2 服务器端Socket的工作过程："></a>1.2 服务器端Socket的工作过程：</h5><ul>
<li>调用ServerSocket(int port)：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li>
<li>调用accept0()：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</li>
<li>调用该Socket类对象的getOutputStream()和getInputStream()：获取输出流和输入流，开始网络数据的发送和接收。</li>
<li>关闭 ServerSocket和Socket对象：客户端访问结束，关闭通信套接字。</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>ServerSocket对象负责等待客户端请求建立套接字连接，类似邮局某个窗口中的业务员。也就是说，服务器必须事先建立一个等待客户请求建立套接字连接的 Server Socket对象。</li>
<li>所谓“接收”客户的套接字请求，就是 accept()方法会返回一个Socket对象</li>
</ul>
<h5 id="1-3-代码示例"><a href="#1-3-代码示例" class="headerlink" title="1.3 代码示例"></a>1.3 代码示例</h5><p>例子1：客户端发送信息给服务端，服务端将数据显示在控制台上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.14.100&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet,<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.获取一个输出流，用于输出数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3.写出数据的操作</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是客户端mm&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.资源的关闭</span></span><br><span class="line">            <span class="keyword">if</span>(os != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">            socket = ss.accept();</span><br><span class="line">            <span class="comment">//3.获取输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不建议这样写，可能会有乱码</span></span><br><span class="line">            <span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line">            <span class="comment">//        int len;</span></span><br><span class="line">            <span class="comment">//        while((len = is.read(buffer)) != -1)&#123;</span></span><br><span class="line">            <span class="comment">//            String str = new String(buffer,0,len);</span></span><br><span class="line">            <span class="comment">//            System.out.print(str);</span></span><br><span class="line">            <span class="comment">//        &#125;</span></span><br><span class="line">            <span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自于：&quot;</span> + socket.getInetAddress().getHostAddress() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(baos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//5.关闭资源</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ss != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题2：客户端发送文件给服务端，服务端将文件保存在本地。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.</span></span><br><span class="line">        fis.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty1.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//5.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.</span></span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPTest3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭数据的输出</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.接收来自于服务器端的数据，并显示到控制台上</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] bufferr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len1;</span><br><span class="line">        <span class="keyword">while</span>((len1 = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer,<span class="number">0</span>,len1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.</span></span><br><span class="line">        fis.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        baos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty2.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//5.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;图片传输完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.服务器端给予客户端反馈</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;你好，美女，照片我已收到，非常漂亮！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.</span></span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、UDP网络编程"><a href="#四、UDP网络编程" class="headerlink" title="四、UDP网络编程"></a>四、UDP网络编程</h3><h4 id="1-简述-1"><a href="#1-简述-1" class="headerlink" title="1. 简述"></a>1. 简述</h4><ul>
<li>类DatagramSocket和DatagramPacket实现了基于UDP协议网络程序。</li>
<li>UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</li>
<li>DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号</li>
<li>UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。</li>
</ul>
<h4 id="2-DatagramSocket类常用方法"><a href="#2-DatagramSocket类常用方法" class="headerlink" title="2. DatagramSocket类常用方法"></a>2. DatagramSocket类常用方法</h4><img src="/posts/3743959532/20200503165829.png" class="" title="image-20200503165828431">

<img src="/posts/3743959532/20200503165848.png" class="" title="image-20200503165847783">

<h4 id="3-DatagramSocket类的使用"><a href="#3-DatagramSocket类的使用" class="headerlink" title="3. DatagramSocket类的使用"></a>3. DatagramSocket类的使用</h4><p>流程：</p>
<ol>
<li>DatagramSocket与DatagramPacket</li>
<li>建立发送端，接收端</li>
<li>建立数据包</li>
<li>调用 Socket的发送、接收方法</li>
<li>关闭 Socket</li>
</ol>
<p>注意：发送端与接收端是两个独立的运行程序</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sender</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是UDP方式发送的导弹&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = str.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,<span class="number">0</span>,data.length,inet,<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiver</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line"></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、URL编程"><a href="#五、URL编程" class="headerlink" title="五、URL编程"></a>五、URL编程</h3><ul>
<li>URL(Uniform Resource Locator)：统一资源定位符，它表示Internet上某一资源的地址。</li>
<li>它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</li>
<li>通过URL我们可以访问 Internet上的各种网络资源，比如最常见的www，ftp站点。浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源</li>
<li>URL的基本结构由5部分组成: &lt;传输协议&gt;：//&lt;主机名&gt;：&lt;端口号&gt;/&lt;文件名&gt;#片段名？参数列表 例如： <a target="_blank" rel="noopener" href="http://192.168.1.100:8080/helloworld/indexjsp#a?username=shkstart&amp;password=123">http://192.168.1.100:8080/helloworld/indexjsp#a?username=shkstart&amp;password=123</a> #片段名：即锚点，例如看小说，直接定位到章节 参数列表格式：参数名=参数值&amp;参数名=参数值…</li>
</ul>
<h4 id="1-URL类"><a href="#1-URL类" class="headerlink" title="1. URL类"></a>1. URL类</h4><h5 id="1-1-构造器"><a href="#1-1-构造器" class="headerlink" title="1.1 构造器"></a>1.1 构造器</h5><p>为了表示URL，java.net中实现了类URL。我们可以通过下面的构造器来初始化一个URL对象</p>
<ul>
<li>public URL(String spec)：通过一个表示URL地址的字符串可以构造一个URL对象。 例如：URL url = new URL（”<a target="_blank" rel="noopener" href="http://www.baidu.com/&quot;">http://www.baidu.com/&quot;</a>);</li>
<li>public URL(URL context,String spec）：通过基URL和相对URL构造一个URL对象 例如： URL downloadeUrl = new URL（url,”download.html”);</li>
<li>public URL(String protocol,String host,String file); 例如：new URL(“http”,”<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;,80,&quot;download.html&quot;/">www.baidu.com&quot;,80,&quot;download.html&quot;</a>);</li>
<li>public URL(String protocol,String host,int port,String file); 例如：new URL(“http”,”<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;,80,&quot;download.html&quot;/">www.baidu.com&quot;,80,&quot;download.html&quot;</a>);</li>
</ul>
<p>注意：URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用try-catch语句进行捕获。</p>
<h5 id="1-2-方法"><a href="#1-2-方法" class="headerlink" title="1.2 方法"></a>1.2 方法</h5><ul>
<li>public String getProtocol( ) 获取该URL的协议名</li>
<li>public String getHost( ) 获取该URL的主机名</li>
<li>public String getPort( ) 获取该URL的端口号</li>
<li>public String getPath( ) 获取该URL的文件路径</li>
<li>public String getFile( ) 获取该URL的文件名</li>
<li>public String getQuery( ) 获取该URL的查询名</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?username=Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            public String getProtocol(  )     获取该URL的协议名</span></span><br><span class="line">            System.out.println(url.getProtocol());</span><br><span class="line"><span class="comment">//            public String getHost(  )           获取该URL的主机名</span></span><br><span class="line">            System.out.println(url.getHost());</span><br><span class="line"><span class="comment">//            public String getPort(  )            获取该URL的端口号</span></span><br><span class="line">            System.out.println(url.getPort());</span><br><span class="line"><span class="comment">//            public String getPath(  )           获取该URL的文件路径</span></span><br><span class="line">            System.out.println(url.getPath());</span><br><span class="line"><span class="comment">//            public String getFile(  )             获取该URL的文件名</span></span><br><span class="line">            System.out.println(url.getFile());</span><br><span class="line"><span class="comment">//            public String getQuery(   )        获取该URL的查询名</span></span><br><span class="line">            System.out.println(url.getQuery());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：通过URL下载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">            urlConnection.connect();</span><br><span class="line"></span><br><span class="line">            is = urlConnection.getInputStream();</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;beauty3.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;下载完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(urlConnection != <span class="literal">null</span>)&#123;</span><br><span class="line">                urlConnection.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十五、Java反射机制"><a href="#十五、Java反射机制" class="headerlink" title="十五、Java反射机制"></a>十五、Java反射机制</h2><h3 id="一、反射的概述"><a href="#一、反射的概述" class="headerlink" title="一、反射的概述"></a>一、反射的概述</h3><h4 id="1-反射的简介"><a href="#1-反射的简介" class="headerlink" title="1. 反射的简介"></a>1. 反射的简介</h4><ul>
<li>Reflection（反射)是被视为<code>动态语言</code>的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</li>
<li>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</li>
</ul>
<p>通常的方式：引入需要的“包类”名称—-&gt;通过“new”实例化—-&gt;获得实例化对象</p>
<p>反射的方式：实例化对象—-&gt;getClass()方法—-&gt;得到完整的“包类”名称</p>
<p>框架 = 注解 + 反射 + 设计模式</p>
<h4 id="2-反射动态性体现"><a href="#2-反射动态性体现" class="headerlink" title="2. 反射动态性体现"></a>2. 反射动态性体现</h4><p>只有当程序运行时我们才能知道调用的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);<span class="comment">//0,1,2</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                classPath = <span class="string">&quot;com.atguigu.java.Person&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> getInstance(classPath);</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个指定类的对象。</span></span><br><span class="line"><span class="comment">    classPath:指定类的全类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span>  Class.forName(classPath);</span><br><span class="line">    <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-反射机制提供的功能"><a href="#3-反射机制提供的功能" class="headerlink" title="3. 反射机制提供的功能"></a>3. 反射机制提供的功能</h4><ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">    <span class="comment">//1.通过反射，创建Person类对象</span></span><br><span class="line">    Constructor&lt;Person&gt; cons = clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    System.out.println(person);<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.通过反射，调用对象指定的属性、方法</span></span><br><span class="line">    <span class="comment">//调用属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    age.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    age.set(person, <span class="number">10</span>);</span><br><span class="line">    System.out.println(person.toString());<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=10&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    show.invoke(person);<span class="comment">//my name is Tom and age is 10</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">    <span class="comment">//通过反射，可以调用Person类的私有结构的。比如：私有的构造器、方法、属性</span></span><br><span class="line">    <span class="comment">//调用私有的构造器</span></span><br><span class="line">    Constructor&lt;Person&gt; cons1 = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    cons1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> cons1.newInstance(<span class="string">&quot;Bruce&quot;</span>);</span><br><span class="line">    System.out.println(p1);<span class="comment">//Person&#123;name=&#x27;Bruce&#x27;, age=0&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    name.set(p1, <span class="string">&quot;Jarry&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有的方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">nation</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;nation&quot;</span>, String.class);</span><br><span class="line">    nation.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">nation1</span> <span class="operator">=</span> (String) nation.invoke(p1, <span class="string">&quot;China&quot;</span>);<span class="comment">//相当于String nation = p1.showNation(&quot;China&quot;)</span></span><br><span class="line">    System.out.println(nation1);<span class="comment">//I come from China</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-相关API"><a href="#4-相关API" class="headerlink" title="4. 相关API"></a>4. 相关API</h4><ul>
<li>java.lang.Class:反射的源头</li>
<li>java.lang.reflect.Method</li>
<li>java.lang.reflect.Field</li>
<li>java.lang.reflect.Constructor</li>
<li>….</li>
</ul>
<h3 id="二、Class类"><a href="#二、Class类" class="headerlink" title="二、Class类"></a>二、Class类</h3><h4 id="1-Class简述"><a href="#1-Class简述" class="headerlink" title="1. Class简述"></a>1. Class简述</h4><ul>
<li><p>在Object类中定义了以下的方法，此方法将被所有子类继承：</p>
<p>public final Class getClass()</p>
</li>
<li><p>以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即可以通过对象反射求出类的名称。</p>
</li>
<li><p>对象使用反射后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个结构（ class/interface/enum/annotation/primitive type/void/[]）的有关信息。</p>
<ul>
<li>Class本身也是一个类</li>
<li>Class对象只能由系统建立对象</li>
<li>一个加载的类在JVM中只会有一个Class实例</li>
<li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li>
<li>每个类的实例都会记得自己是由哪个Class实例所生成</li>
<li>通过Class可以完整地得到一个类中的所有被加载的结构</li>
<li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li>
</ul>
</li>
</ul>
<p><strong>类的加载过程：</strong></p>
<ul>
<li>程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。</li>
<li>换句话说，Class的实例就对应着一个运行时类。</li>
<li>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</li>
</ul>
<p><code>类本身也是一个对象~~~</code></p>
<h4 id="2-Class类的常用方法"><a href="#2-Class类的常用方法" class="headerlink" title="2. Class类的常用方法"></a>2. Class类的常用方法</h4><img src="/posts/3743959532/20200505221745.png" class="" title="image-20200505221744128">

<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Class的实例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;test1.Person&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(str);</span><br><span class="line"><span class="comment">//调用Class的空参构造器创建对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance;</span><br><span class="line"><span class="comment">//获取clazz的name属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">field.set(obj,<span class="string">&quot;Jarry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> filed.get(obj);</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="comment">//test1.Person为test1包下的Person类</span></span><br></pre></td></tr></table></figure>



<h4 id="3-获取Class实例的几种方式："><a href="#3-获取Class实例的几种方式：" class="headerlink" title="3. 获取Class实例的几种方式："></a>3. 获取Class实例的几种方式：</h4><p>Class实例 对应着一个运行时类，加载到内存中的运行时类，会缓存一段时间，在此时间内，我们可以通过不同的方式来获取运行时类！</p>
<p>1）已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高 实例：<code>Class clazz = String.class;</code> </p>
<p>2）已知某个类的实例，调用该实例的getclass()方法获取Class对象 实例：<code>Class clazz=person.getclass()</code>; </p>
<p>3）已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出 <code>ClassNotFoundException</code>（比较常用） 实例：<code>Class clazz = Class.forName(String classPath)</code> </p>
<p>4）通过类加载器 <code>ClassLoader cl = this.getclass().getClassLoader();</code> <code>Class clazz = cl.loadClass(&quot;类的全类名&quot;);</code></p>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//方式一：调用运行时类的属性：.class</span></span><br><span class="line">    Class&lt;Person&gt; clazz1 = Person.class;</span><br><span class="line">    System.out.println(clazz1);<span class="comment">//class cn.bruce.java.Person</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：通过运行时类的对象,调用getClass()</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; clazz2 = p1.getClass();</span><br><span class="line">    System.out.println(clazz2);<span class="comment">//class cn.bruce.java.Person</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式三：调用Class的静态方法：forName(String classPath)</span></span><br><span class="line">    Class&lt;?&gt; clazz3 = Class.forName(<span class="string">&quot;cn.bruce.java.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz3);<span class="comment">//class cn.bruce.java.Person</span></span><br><span class="line"></span><br><span class="line">    System.out.println(clazz1 == clazz2);<span class="comment">//true</span></span><br><span class="line">    System.out.println(clazz1 == clazz3);<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//方式四：使用类的加载器：ClassLoader  (了解)</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectionTest.class.getClassLoader();</span><br><span class="line">    Class&lt;?&gt; clazz4 = classLoader.loadClass(<span class="string">&quot;cn.bruce.java.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz4);<span class="comment">//class cn.bruce.java.Person</span></span><br><span class="line">    System.out.println(clazz1 == clazz4);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：创建类的对象的方式?</strong></p>
<p>方式一：new + 构造器</p>
<p>方式二：要创建Xxx类的对象，可以考虑：Xxx、Xxxs、XxxFactory、XxxBuilder类中查看是否有静态方法的存在。可以调用其静态方法，创建Xxx对象。</p>
<p>方式三：通过反射</p>
<h4 id="4-Class实例可以代表的结构"><a href="#4-Class实例可以代表的结构" class="headerlink" title="4. Class实例可以代表的结构"></a>4. Class实例可以代表的结构</h4><p>（1）class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</p>
<p>（2）interface：接口</p>
<p>（3）[]：数组</p>
<p>（4）enum：枚举</p>
<p>（5）annotation：注解@interface</p>
<p>（6）primitive type：基本数据类型</p>
<p>（7）void</p>
<blockquote>
<p>在Java中万事万物皆对象</p>
</blockquote>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    Class&lt;Object&gt; c1 = Object.class;</span><br><span class="line">    Class&lt;Comparable&gt; c2 = Comparable.class;</span><br><span class="line">    Class&lt;String[]&gt; c3 = String[].class;</span><br><span class="line">    Class&lt;<span class="type">int</span>[][]&gt; c4 = <span class="type">int</span>[][].class;</span><br><span class="line">    Class&lt;ElementType&gt; c5 = ElementType.class;</span><br><span class="line">    Class&lt;Override&gt; c6 = Override.class;</span><br><span class="line">    Class&lt;Integer&gt; c7 = <span class="type">int</span>.class;</span><br><span class="line">    Class&lt;Void&gt; c8 = <span class="keyword">void</span>.class;</span><br><span class="line">    Class&lt;Class&gt; c9 = Class.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] i1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[] i2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">int</span>[]&gt; c10 = i1.getClass();</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">int</span>[]&gt; c11 = i2.getClass();</span><br><span class="line">    <span class="comment">// 只要数组的元素类型与维度一样，就是同一个Class</span></span><br><span class="line">    System.out.println(c10 == c11);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、类的加载"><a href="#三、类的加载" class="headerlink" title="三、类的加载"></a>三、类的加载</h3><h4 id="1-类的加载过程"><a href="#1-类的加载过程" class="headerlink" title="1. 类的加载过程"></a>1. 类的加载过程</h4><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过以下三个步骤对该类进行初始化。</p>
<img src="/posts/3743959532/20200505224801.png" class="" title="image-20200505224800360">

<ul>
<li>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与。</li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul>
<li>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题。</li>
<li>准备：正式为类变量(static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li>
</ul>
</li>
<li>初始化：<ul>
<li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</li>
</ul>
</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoadingTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String [] args)</span>&#123;</span><br><span class="line">        System.out.println(test.m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一步：加载</span></span><br><span class="line"><span class="comment">//第二步：链接结束后m=0</span></span><br><span class="line"><span class="comment">//第三步：初始化结束后，m的值由&lt;clinit&gt;()方法执行决定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个test构造器&lt;clinit&gt;()方法由类变量的赋值和静态代码块中的语句按照顺序合并产生，类似于</span></span><br><span class="line"><span class="comment">&lt;clinit&gt;()&#123;</span></span><br><span class="line"><span class="comment">m = 300;</span></span><br><span class="line"><span class="comment">m = 100;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="2-Java类编译、运行的执行的流程"><a href="#2-Java类编译、运行的执行的流程" class="headerlink" title="2. Java类编译、运行的执行的流程"></a>2. Java类编译、运行的执行的流程</h4><img src="/posts/3743959532/20200505230511.png" class="" title="image-20200505230510894">



<h4 id="3-类的加载器的作用"><a href="#3-类的加载器的作用" class="headerlink" title="3. 类的加载器的作用"></a>3. 类的加载器的作用</h4><ul>
<li>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</li>
<li>类缓存：标准的 JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</li>
</ul>
<h4 id="4-类的加载器的分类"><a href="#4-类的加载器的分类" class="headerlink" title="4. 类的加载器的分类"></a>4. 类的加载器的分类</h4><img src="/posts/3743959532/20200505230532.png" class="" title="image-20200505230531154">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//对于自定义类，使用系统类加载器进行加载</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);</span><br><span class="line">    <span class="comment">//调用系统类加载器的getParent()：获取扩展类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> classLoader.getParent();</span><br><span class="line">    System.out.println(classLoader1);</span><br><span class="line">    <span class="comment">//调用扩展类加载器的getParent()：无法获取引导类加载器</span></span><br><span class="line">    <span class="comment">//引导类加载器主要负责加载java的核心类库，无法加载自定义类的。</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> classLoader1.getParent();</span><br><span class="line">    System.out.println(classLoader2);</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader3</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-使用Classloader加载src目录下的配置文件"><a href="#5-使用Classloader加载src目录下的配置文件" class="headerlink" title="5. 使用Classloader加载src目录下的配置文件"></a>5. 使用Classloader加载src目录下的配置文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//        //读取配置文件的方式一：</span></span><br><span class="line">    <span class="comment">//        //此时的文件默认在当前的module下。</span></span><br><span class="line">    <span class="comment">//        FileInputStream fis = null;</span></span><br><span class="line">    <span class="comment">//        try &#123;</span></span><br><span class="line">    <span class="comment">//            fis = new FileInputStream(&quot;jdbc1.properties&quot;);</span></span><br><span class="line">    <span class="comment">//            pros.load(fis);</span></span><br><span class="line">    <span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line">    <span class="comment">//            e.printStackTrace();</span></span><br><span class="line">    <span class="comment">//        &#125; finally &#123;</span></span><br><span class="line">    <span class="comment">//            if (fis != null) &#123;</span></span><br><span class="line">    <span class="comment">//                try &#123;</span></span><br><span class="line">    <span class="comment">//                    fis.close();</span></span><br><span class="line">    <span class="comment">//                &#125; catch (IOException e) &#123;</span></span><br><span class="line">    <span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">    <span class="comment">//                &#125;</span></span><br><span class="line">    <span class="comment">//            &#125;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取配置文件的方式二：使用ClassLoader</span></span><br><span class="line">    <span class="comment">//配置文件默认识别为：当前module的src下</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pros.load(is);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user + <span class="string">&quot; password =&quot;</span> + password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、反射的应用"><a href="#四、反射的应用" class="headerlink" title="四、反射的应用"></a>四、反射的应用</h3><h4 id="1-创建运行时类的对象"><a href="#1-创建运行时类的对象" class="headerlink" title="1. 创建运行时类的对象"></a>1. 创建运行时类的对象</h4><h5 id="1-1代码举例"><a href="#1-1代码举例" class="headerlink" title="1.1代码举例"></a>1.1代码举例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//方式一</span></span><br><span class="line">    Class&lt;Person&gt; clazz1 = Person.class;</span><br><span class="line">    <span class="comment">//方式二</span></span><br><span class="line">    Class&lt;Person&gt; clazz2 = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;cn.bruce.java.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> clazz1.newInstance();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> clazz2.newInstance();</span><br><span class="line">    System.out.println(person1);</span><br><span class="line">    System.out.println(person2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-2-说明"><a href="#1-2-说明" class="headerlink" title="1.2 说明"></a>1.2 说明</h5><p>newInstance():调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。</p>
<p>要想此方法正常的创建运行时类的对象，要求：</p>
<ul>
<li>运行时类必须提供空参的构造器</li>
<li>空参的构造器的访问权限得够。通常，设置为public。</li>
</ul>
<p>在javabean中要求提供一个public的空参构造器。原因：</p>
<ul>
<li>便于通过反射，创建运行时类的对象</li>
<li>便于子类继承此运行时类时，默认调用super()时，保证父类此构造器</li>
</ul>
<h4 id="2-获取运行时类的完整结构"><a href="#2-获取运行时类的完整结构" class="headerlink" title="2. 获取运行时类的完整结构"></a>2. 获取运行时类的完整结构</h4><p>我们可以通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等。。。。</p>
<h5 id="2-1-使用反射可以取得："><a href="#2-1-使用反射可以取得：" class="headerlink" title="2.1 使用反射可以取得："></a>2.1 使用反射可以取得：</h5><ol>
<li><p>实现的全部接口： public Class&lt;?&gt;[] getInterfaces() 确定此对象所表示的类或接口实现的接口。</p>
</li>
<li><p>所继承的父类： public Class&lt;? Super T&gt; getSuperclass() 返回表示此Class所表示的实体（类、接口、基本类型）的父类的Class。</p>
</li>
<li><p>全部的构造器：</p>
<p>public Constructor<T>[] getConstructors()</p>
<p>返回此Class对象所表示的类的所有public构造方法。</p>
<p>public Constructor<T>[] getDeclaredConstructors()</p>
<p>返回此Class对象表示的类声明的所有构造方法。</p>
<p>在Constructor类中:</p>
<ul>
<li>取得修饰符：public int getModifiers();</li>
<li>取得方法名称： public String getName();</li>
<li>取得参数的类型： public Class&lt;?&gt; getParameterTypes();</li>
</ul>
</li>
<li><p>全部的方法：</p>
<p>public Method[] getDeclaredMethods()</p>
<p>返回此Class对象所表示的类或接口的全部方法</p>
<p>public Method[] getMethods()</p>
<p>返回此Class对象所表示的类或接口的public的方法</p>
<p>Method类中：</p>
<ul>
<li>public Class&lt;?&gt; getReturnType()取得全部的返回值</li>
<li>public Class&lt;?&gt;[] getParameterTypes()取得全部的参数</li>
<li>public int getModifiers()取得修饰符</li>
<li>public Class&lt;?&gt; [] getEXceptionTypes()取得异常信息</li>
</ul>
</li>
<li><p>全部的Field:</p>
<p>public Field[] getFields()</p>
<p>返回此Class对象所表示的类或接口的public的Field。</p>
<p>public Field[] getDeclaredFields()</p>
<p>返回此Class对象所表示的类或接口的全部Field</p>
<p>Field方法中</p>
<ul>
<li>public int getModifiers()以整数形式返回此Field的修饰符</li>
<li>public Class&lt;?&gt; getType()得到Field的属性类型</li>
<li>public String getName()返回Field的名称。</li>
</ul>
</li>
<li><p>Annotation相关</p>
<p>get Annotation(Class<T> annotationClass)</p>
<p>getDeclaredAnnotations()</p>
</li>
<li><p>泛型相关</p>
<p>获取父类泛型类型：Type getGenericSuperclass()</p>
<p>泛型类型：ParameterizedType</p>
<p>获取实际的泛型类型参数数组：getActualTypeArguments()</p>
</li>
<li><p>类所在的包 Package getPackage()</p>
</li>
</ol>
<h5 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h5><p><strong>获取属性Fieled</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FiledTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">//获取属性结构</span></span><br><span class="line">        <span class="comment">//getFields():获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">        Field[] fields = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             fields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所有属性。（不包含父类中声明的属性）</span></span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             declaredFields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//权限修饰符  数据类型 变量名</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cn.bruce.java1.Person&quot;</span>);</span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             declaredFields) &#123;</span><br><span class="line">            <span class="comment">//1.权限修饰符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">            System.out.print(Modifier.toString(modifiers)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.数据类型</span></span><br><span class="line">            Class&lt;?&gt; type = f.getType();</span><br><span class="line">            System.out.print(type.getName()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.变量名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fName</span> <span class="operator">=</span> f.getName();</span><br><span class="line">            System.out.print(fName);</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取方法Method</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">//getMethods():获取当前运行时类及其所有父类中声明为public权限的方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             methods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredMethods():获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</span></span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             declaredMethods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Xxxx</span></span><br><span class="line"><span class="comment">    权限修饰符  返回值类型  方法名(参数类型1 形参名1,...) throws XxxException&#123;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cn.bruce.java1.Person&quot;</span>);</span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             declaredMethods) &#123;</span><br><span class="line">            <span class="comment">//1.获取方法声明的注解</span></span><br><span class="line">            Annotation[] annos = m.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span> (Annotation a :</span><br><span class="line">                 annos) &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.权限修饰符</span></span><br><span class="line">            System.out.print(Modifier.toString(m.getModifiers())+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.返回值类型</span></span><br><span class="line">            System.out.print(m.getReturnType().getName() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.方法名</span></span><br><span class="line">            System.out.print(m.getName());</span><br><span class="line">            System.out.print(<span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.形参列表</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (!(parameterTypes == <span class="literal">null</span> &amp;&amp; parameterTypes.length == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == parameterTypes.length - <span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.print(parameterTypes[i].getName() + <span class="string">&quot; args_&quot;</span> + i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(parameterTypes[i].getName() + <span class="string">&quot;args_&quot;</span> + i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6.抛出的异常</span></span><br><span class="line">            Class&lt;?&gt;[] exceptionTypes = m.getExceptionTypes();</span><br><span class="line">            <span class="keyword">if</span> (exceptionTypes.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;throws &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; exceptionTypes.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==exceptionTypes.length -<span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.print(exceptionTypes[i].getName());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(exceptionTypes[i].getName()+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取其他结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherTest</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取构造器结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">//getConstructors():获取当前运行时类中声明为public的构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c :</span><br><span class="line">             constructors) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredConstructors():获取当前运行时类中声明的所有的构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c :</span><br><span class="line">             declaredConstructors) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的父类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="built_in">super</span> Person&gt; superclass = clazz.getSuperclass();</span><br><span class="line">        System.out.println(superclass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">        System.out.println(genericSuperclass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类的泛型</span></span><br><span class="line"><span class="comment">    代码：逻辑性代码  vs 功能性代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">        <span class="comment">//获取泛型类型</span></span><br><span class="line">        Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line">        <span class="comment">//        System.out.println(actualTypeArguments[0].getTypeName());</span></span><br><span class="line">        System.out.println(((Class)actualTypeArguments[<span class="number">0</span>]).getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类实现的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class c : interfaces)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//获取运行时类的父类实现的接口</span></span><br><span class="line">        Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class c : interfaces1)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取运行时类所在的包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Package</span> <span class="variable">pack</span> <span class="operator">=</span> clazz.getPackage();</span><br><span class="line">        System.out.println(pack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取运行时类声明的注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annos : annotations)&#123;</span><br><span class="line">            System.out.println(annos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-调用运行时类的指定结构"><a href="#3-调用运行时类的指定结构" class="headerlink" title="3. 调用运行时类的指定结构"></a>3. 调用运行时类的指定结构</h4><h5 id="3-1-调用指定的属性"><a href="#3-1-调用指定的属性" class="headerlink" title="3.1 调用指定的属性"></a>3.1 调用指定的属性</h5><p>在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。</p>
<ul>
<li><p>public Field getField(String name)返回此Class对象表示的类或接口的指定的public的Field。</p>
</li>
<li><p>public Field getDeclaredField(String name)返回此Class对象表示的类或接口的指定的Field。</p>
<p>在Field中:</p>
</li>
<li><p>public Object get(object obj)取得指定对象obj上此 Field的属性内容</p>
</li>
<li><p>public void set(Object obj,Object value)设置指定对象obj上此Field的属性内容</p>
</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前属性是可访问的</span></span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//3.获取、设置指定对象的此属性值</span></span><br><span class="line">    name.set(p,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(name.get(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-2调用指定的方法（常用）"><a href="#3-2调用指定的方法（常用）" class="headerlink" title="3.2调用指定的方法（常用）"></a>3.2调用指定的方法（常用）</h5><p>通过反射，调用类中的方法，通过Method类完成。步骤:</p>
<ol>
<li>通过Class类的getMethod(String name,Class… parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。</li>
<li>之后使用 Object invoke(Object obj， Object[] args)进行调用，并向方法中传递要设置的ob对象的参数信息。</li>
</ol>
<img src="/posts/3743959532/20200506083836.png" class="" title="image-20200506083834793">

<p><strong>Object invoke(object obj,Object… args)方法：</strong></p>
<ol>
<li>Object对应原方法的返回值，若原方法无返回值，此时返回null</li>
<li>若原方法若为静态方法，此时形参Object obj可为null</li>
<li>若原方法形参列表为空，则Object[] args为null</li>
<li>若原方法声明为private，则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。</li>
</ol>
<p><strong>关于setAccessible方法的使用：</strong></p>
<ul>
<li>Method和Field、Constructor对象都有setAccessible()方法。</li>
<li>setAccessible是启动和禁用访问安全检查的开关</li>
<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检査。</li>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true. 使得原本无法访问的私有成员也可以访问</li>
<li>参数值为false则指示反射的对象应该实施Java语言访问检査。</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的某个方法</span></span><br><span class="line"><span class="comment">        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前方法是可访问的</span></span><br><span class="line">    show.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参</span></span><br><span class="line"><span class="comment">        invoke()的返回值即为对应类中调用的方法的返回值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> show.invoke(person, <span class="string">&quot;CHN&quot;</span>);</span><br><span class="line">    System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************如何调用静态方法*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">showDesc</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">    showDesc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//如果调用的运行时类中的方法没有返回值，则此invoke()返回null</span></span><br><span class="line">    <span class="comment">//Object returnVal = showDesc.invoke(null);</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> showDesc.invoke(Person.class);</span><br><span class="line">    System.out.println(returnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-3-调用指定的构造器"><a href="#3-3-调用指定的构造器" class="headerlink" title="3.3 调用指定的构造器"></a>3.3 调用指定的构造器</h5><p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Person(String name)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的构造器</span></span><br><span class="line"><span class="comment">        getDeclaredConstructor():参数：指明构造器的参数列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证此构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调用此构造器创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(per);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4. 动态代理"></a>4. 动态代理</h4><h5 id="4-1代理设计模式的原理"><a href="#4-1代理设计模式的原理" class="headerlink" title="4.1代理设计模式的原理:"></a>4.1代理设计模式的原理:</h5><p>使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p>
<h5 id="4-2-静态代理"><a href="#4-2-静态代理" class="headerlink" title="4.2 静态代理"></a>4.2 静态代理</h5><p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClothFactory</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Nike 生产衣服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClothFactory factory;<span class="comment">//用被代理类对象进行实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyClothFactory</span><span class="params">(ClothFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些准备工作&quot;</span>);</span><br><span class="line"></span><br><span class="line">        factory.produceCloth();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些后续的收尾工作&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建被代理类的对象</span></span><br><span class="line">        <span class="type">ClothFactory</span> <span class="variable">nike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NikeClothFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建代理类的对象</span></span><br><span class="line">        <span class="type">ProxyClothFactory</span> <span class="variable">proxyClothFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyClothFactory</span>(nike);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态代理的缺点：</strong></p>
<p>① 代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。</p>
<p>② 每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。</p>
<h5 id="4-3-动态代理的特点："><a href="#4-3-动态代理的特点：" class="headerlink" title="4.3 动态代理的特点："></a>4.3 动态代理的特点：</h5><p>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</p>
<p><strong>相比于静态代理的优点：</strong></p>
<p>抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。</p>
<h5 id="4-4-动态代理的实现"><a href="#4-4-动态代理的实现" class="headerlink" title="4.4 动态代理的实现"></a>4.4 动态代理的实现</h5><h6 id="4-4-1-需要解决的两个主要问题："><a href="#4-4-1-需要解决的两个主要问题：" class="headerlink" title="4.4.1 需要解决的两个主要问题："></a>4.4.1 需要解决的两个主要问题：</h6><p>问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。</p>
<p>（通过 <code>Proxy.newProxyInstance()</code> 实现）</p>
<p>问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法。</p>
<p>（通过 <code>InvocationHandler</code> 接口的实现类及其方法 <code>invoke()</code> )</p>
<h6 id="4-4-2-动态代理相关的API："><a href="#4-4-2-动态代理相关的API：" class="headerlink" title="4.4.2 动态代理相关的API："></a>4.4.2 动态代理相关的API：</h6><p>Proxy：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。提供用于创建动态代理类和动态代理对象的静态方法。</p>
<ul>
<li><code>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;...interface)</code> 创建一个动态代理类所对应的Class对象</li>
<li><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;...interface, InvocationHandler h)</code> 直接创建一个动态代理对象</li>
</ul>
<h6 id="4-4-3-动态代理实现步骤："><a href="#4-4-3-动态代理实现步骤：" class="headerlink" title="4.4.3 动态代理实现步骤："></a>4.4.3 动态代理实现步骤：</h6><ol>
<li>创建一个实现接口 <code>InvocationHandler</code> 的类，它必须实现invoke方法，以完成代理的具体操作。</li>
<li>创建被代理类以及接口</li>
<li>通过Proxy的静态方法 <code>newProxyInstance(ClassLoader loader, Class&lt;?&gt;...interface, InvocationHandler h)</code> 创建一个接口代理</li>
<li>通过代理类的实例调用被代理类的方法</li>
</ol>
<h6 id="4-4-2-代码实现："><a href="#4-4-2-代码实现：" class="headerlink" title="4.4.2 代码实现："></a>4.4.2 代码实现：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    String <span class="title function_">getBelief</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">implements</span> <span class="title class_">Human</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBelief</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I like eat &quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要想实现动态代理，需要解决的问题？</span></span><br><span class="line"><span class="comment">问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。</span></span><br><span class="line"><span class="comment">问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建继承了InvocationHandler接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHanlder</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中的invoke()的返回值。</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="comment">//调用此方法，返回一个代理类的对象。解决问题一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="type">MyInvocationHanlder</span> <span class="variable">hanlder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHanlder</span>();</span><br><span class="line">        hanlder.bind(obj);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),hanlder);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SuperMan</span> <span class="variable">superMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();</span><br><span class="line">        <span class="comment">//proxyInstance:代理类的对象</span></span><br><span class="line">        <span class="type">Human</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">belief</span> <span class="operator">=</span> proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;火锅&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-动态代理与AOP"><a href="#5-动态代理与AOP" class="headerlink" title="5. 动态代理与AOP"></a>5. 动态代理与AOP</h4><ul>
<li>使用 Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理。</li>
<li>这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异：</li>
<li>AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理</li>
</ul>
<img src="/posts/3743959532/20200506110950.png" class="" title="image-20200506110949054">

<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuntingDog</span> <span class="keyword">implements</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只猎狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我跑的很快&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======通用方法一=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======通用方法二=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态代理实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler1</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">//需要被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetTarget</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">DogUtils</span> <span class="variable">dogUtils</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DogUtils</span>();</span><br><span class="line">        <span class="comment">//执行DogUtils对象中的method1</span></span><br><span class="line">        dogUtils.method1();</span><br><span class="line">        <span class="comment">//通过obj对象来调用执行method方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//执行DogUtils对象中的method2</span></span><br><span class="line">        dogUtils.method2();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyProxyFactory1</span> &#123;</span><br><span class="line">    <span class="comment">//为target生成动态代理对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个MyInvocationHandler对象</span></span><br><span class="line">        <span class="type">MyInvocationHandler1</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler1</span>();</span><br><span class="line">        <span class="comment">//为MyInvocationHandler设置target对象</span></span><br><span class="line">        handler.SetTarget(target);</span><br><span class="line">        <span class="comment">//创建返回一个动态代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuntingDog</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) MyProxyFactory1.getProxy(target);</span><br><span class="line">        dog.info();</span><br><span class="line">        dog.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io">Eric</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericwjian.github.io/posts/3743959532/">https://ericwjian.github.io/posts/3743959532/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericwjian.github.io" target="_blank">Eric</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/3661501281/" title="Mybatis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mybatis</div></div></a></div><div class="next-post pull-right"><a href="/posts/3119647264/" title="webpack"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">webpack</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2596706042/" title="Java新特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-12</div><div class="title">Java新特性</div></div></a></div><div><a href="/posts/1602673635/" title="Java8 Stream"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-12</div><div class="title">Java8 Stream</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Eric</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/wangjian_uuid" target="_blank" title="Gitee"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:358070983@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=358070983&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="toc-text">一、Java语言概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E5%B9%B3%E5%8F%B0"><span class="toc-text">1、Java技术体系平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81java%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99-%E7%BC%96%E8%AF%91-%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">2、java程序编写-编译-运行的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B3%A8%E9%87%8A-Comment"><span class="toc-text">3、注释:Comment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">二、基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-text">1、关键字与保留字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Java%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">1、Java关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81-%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-text">2、 保留字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">2、标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">3、变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">1、变量的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%8C%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-text">1 按数据类型分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8C%89%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-text">2 按声明的位置的不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3 数据类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">2、基本数据类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-text">1 自动类型转换：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">2 强制类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-String%E4%B8%8E8%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-text">3 String与8种基本数据类型间的运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4、运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">三、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">1、数组的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">2、数组相关的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">3、数组的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">4、数组的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">5、数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">6、数组的排序算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Arrays-%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7、Arrays 工具类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-text">8、数组的常见异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A"><span class="toc-text">四、面向对象(上)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-text">1、面向对象的三大特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">2、核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-text">3、类的成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%B1%9E%E6%80%A7"><span class="toc-text">4、属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">5、方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95"><span class="toc-text">1、什么是方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD-overload"><span class="toc-text">2、方法的重载(overload)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82"><span class="toc-text">3、可变个数的形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%B0%81%E8%A3%85%E5%92%8C%E9%9A%90%E8%97%8F"><span class="toc-text">4、封装和隐藏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">6、构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">1、构造器的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">2、构造器的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">3、构造器的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E9%87%8D%E8%BD%BD"><span class="toc-text">4、构造器重载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">7、this关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD"><span class="toc-text">五、面向对象(中)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-text">1、继承性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-text">1、为什么要有继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">2、作用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%B3%A8%E6%84%8F"><span class="toc-text">3、注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-text">4、方法的重写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E8%A6%81%E6%B1%82"><span class="toc-text">2、要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81-%E6%B3%A8%E6%84%8F"><span class="toc-text">3、 注意</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Asuper"><span class="toc-text">5、关键字：super</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">2、多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%A4%9A%E6%80%81%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1、多态性是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81instanceof-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">2、instanceof 操作符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Object%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3、Object类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81-%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8Eequals%E6%96%B9%E6%B3%95"><span class="toc-text">4、&#x3D;&#x3D;操作符与equals方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B"><span class="toc-text">六、面向对象(下)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81static"><span class="toc-text">1、static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">2、单例设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">3、代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81final"><span class="toc-text">4、final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">5、抽象类和抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%8E%A5%E5%8F%A3"><span class="toc-text">6、接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E5%AE%9A"><span class="toc-text">2、接口的特定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy"><span class="toc-text">3、代理模式(Proxy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">4、内部类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">七、异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">1、异常体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-text">2、常见异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81try-catch-finally"><span class="toc-text">3、try-catch-finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81throws"><span class="toc-text">4、throws</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-text">5、手动抛出异常对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-text">6、自定义异常类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-text">1.如何自定义异常类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">八、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1、基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">2、线程的创建和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%96%B9%E5%BC%8F%E4%B8%80-%E7%BB%A7%E6%89%BF%E4%BA%8EThread%E7%B1%BB"><span class="toc-text">1、方式一:继承于Thread类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">1、使用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2、注意事项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81Thread-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">3、Thread 类的常用方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-text">2、实现Runnable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-text">1、使用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">3、两种方式的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4、线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-text">5、线程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%83%8C%E6%99%AF"><span class="toc-text">1、背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Java%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">2、Java解决方案：同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">1、方式一：同步代码块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-text">2、方式二：同步方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-text">3、线程的同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-text">1、单例模式，懒汉式-线程不安全的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-text">2、线程的死锁问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Lock%E9%94%81"><span class="toc-text">4、Lock锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">5、面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81synchronized-%E4%B8%8E-Lock%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-text">1、synchronized 与 Lock的异同？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81Java%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%8C%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%B9%B6%E5%AF%B9%E6%AF%94%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-text">2、Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E8%AE%AF"><span class="toc-text">6、线程的通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">1. 线程通信涉及到的三个方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">2. 说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">3、面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">4、生产者消费者问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">7、新增线程创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-text">1、新增方式一：实现Callable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">2、新增方式二：使用线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="toc-text">8、面试题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Java%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">九、Java常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81String%E7%B1%BB"><span class="toc-text">1、String类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0-1"><span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81String%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">2、String的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-String%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-text">1. String的不可变性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-String%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">2. String实例化方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B9%E5%BC%8F%E8%B5%8B%E5%80%BC%E5%AF%B9%E6%AF%94"><span class="toc-text">3. 字符串拼接方式赋值对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-String%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1"><span class="toc-text">4. String使用陷阱</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-String%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">5. String类常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-text">1 字符串操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-text">2 查找字符串中的字符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-text">3 字符串操作方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-String%E4%B8%8E%E5%85%B6%E4%BB%96%E7%BB%93%E6%9E%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">6. String与其他结构的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-String%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">1 String与基本数据类型、包装类之间的转换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">2 与字符数组之间的转换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E4%B8%8E%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">3 与字节数组之间的转换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E4%B8%8EStringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">4 与StringBuffer、StringBuilder之间的转换</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-JVM%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">7. JVM中字符串常量池存放位置说明：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81StringBuffer%E5%92%8CStringBuilder"><span class="toc-text">3、StringBuffer和StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81StringBuffer%E7%B1%BB"><span class="toc-text">1、StringBuffer类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-text">1.概述：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">2.常用方法：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81StringBuilder%E7%B1%BB"><span class="toc-text">2、StringBuilder类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B8%89%E8%80%85%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">1. String、StringBuffer、StringBuilder三者的对比</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81StringBuffer%E4%B8%8EStringBuilder%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-text">2、StringBuffer与StringBuilder的内存解析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%AF%B9%E6%AF%94String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B8%89%E8%80%85%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87"><span class="toc-text">3. 对比String、StringBuffer、StringBuilder三者的执行效率</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81JDK-8-0%E4%BB%A5%E5%89%8D%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-text">2、JDK 8.0以前的日期时间API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-java-lang-System%E7%B1%BB"><span class="toc-text">1. java.lang.System类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-java-util-Date%E7%B1%BB"><span class="toc-text">2. java.util.Date类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">1 构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2 常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-java-util-Date%E7%B1%BB%E4%B8%8Ejava-sql-Date%E7%B1%BB"><span class="toc-text">3  java.util.Date类与java.sql.Date类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-java-text-SimpleDateFormat%E7%B1%BB"><span class="toc-text">3. java.text.SimpleDateFormat类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-SimpleDateFormat%E5%AF%B9%E6%97%A5%E6%9C%9FDate%E7%B1%BB%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%92%8C%E8%A7%A3%E6%9E%90"><span class="toc-text">1. SimpleDateFormat对日期Date类的格式化和解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-SimpleDateFormat%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96-new-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">2. SimpleDateFormat的实例化:new + 构造器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Calendar%E7%B1%BB%EF%BC%9A%E6%97%A5%E5%8E%86%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">4. Calendar类：日历类、抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">1 实例化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-text">2 常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81JDK-8-0%E4%B8%AD%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-text">3、JDK 8.0中新的日期时间类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API%E7%9A%84%E8%BF%AD%E4%BB%A3%EF%BC%9A"><span class="toc-text">1. 日期时间API的迭代：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%89%8D%E4%B8%A4%E4%BB%A3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">2. 前两代的问题：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Java-8-0%E4%B8%AD%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API%E6%B6%89%E5%8F%8A%E7%9A%84%E5%8C%85"><span class="toc-text">3. Java 8.0中新的日期时间API涉及的包:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9C%AC%E5%9C%B0%E6%97%A5%E6%9C%9F%E3%80%81%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E3%80%81%E6%9C%AC%E5%9C%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-text">4. 本地日期、本地时间、本地日期时间的使用：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">1 代码：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E6%97%B6%E9%97%B4%E7%82%B9%EF%BC%9AInstant"><span class="toc-text">5、时间点：Instant</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">1 说明：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">2 代码示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%B1%BB%EF%BC%9ADateTimeFormatter"><span class="toc-text">6、日期时间格式化类：DateTimeFormatter</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AF%B4%E6%98%8E%EF%BC%9A-1"><span class="toc-text">1 说明：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A-1"><span class="toc-text">2 常用方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">3、代码示例：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%85%B6%E5%AE%83API%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7、其它API的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Java%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-text">4、Java比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java%E6%AF%94%E8%BE%83%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E8%83%8C%E6%99%AF%EF%BC%9A"><span class="toc-text">1. Java比较器的使用背景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%EF%BC%9A%E4%BD%BF%E7%94%A8Comparable%E6%8E%A5%E5%8F%A3"><span class="toc-text">2. 自然排序：使用Comparable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E8%AF%B4%E6%98%8E"><span class="toc-text">2.1 说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-text">2.2 自定义类代码举例：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F%EF%BC%9A%E4%BD%BF%E7%94%A8Comparator%E6%8E%A5%E5%8F%A3"><span class="toc-text">3. 定制排序：使用Comparator接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E8%AF%B4%E6%98%8E"><span class="toc-text">3.1 说明:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-text">3.2 代码举例：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%A4%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-text">4. 两种排序方式对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">5、其他常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-System%E7%B1%BB"><span class="toc-text">1.System类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Math%E7%B1%BB"><span class="toc-text">2.Math类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-BigInteger%E7%B1%BB%E3%80%81BigDecimal%E7%B1%BB"><span class="toc-text">3.BigInteger类、BigDecimal类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB-amp-%E6%B3%A8%E8%A7%A3"><span class="toc-text">十、枚举类&amp;注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1、枚举类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">1. 枚举类的说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%9F"><span class="toc-text">2. 如何自定义枚举类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-JDK-5-0-%E6%96%B0%E5%A2%9E%E4%BD%BF%E7%94%A8enum%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB%E3%80%82"><span class="toc-text">3. JDK 5.0 新增使用enum定义枚举类。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Enum%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">Enum类的常用方法：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%94%A8Enum%E7%B1%BB%E5%AE%9A%E4%B9%89%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%88%86%E5%88%AB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-text">4、用Enum类定义的枚举类对象分别实现接口：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2、注解的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">1. 注解的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">2. 注解的使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-text">示例一：生成文档相关的注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E6%A3%80%E6%9F%A5-JDK%E5%86%85%E7%BD%AE%E7%9A%84%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3"><span class="toc-text">示例二：在编译时进行格式检查(JDK内置的个基本注解)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">3. 如何自定义注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%83%E6%B3%A8%E8%A7%A3-%EF%BC%9A"><span class="toc-text">4. 元注解 ：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-JDK8%E4%B8%AD%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">5.  JDK8中注解的新特性 :</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Java%E9%9B%86%E5%90%88"><span class="toc-text">十一、Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">1、集合框架概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">1. 数组存储的特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E7%9A%84%E5%BC%8A%E7%AB%AF%EF%BC%9A"><span class="toc-text">2.数组存储的弊端：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">3. 集合存储的优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%9B%86%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">4. 集合的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84"><span class="toc-text">5. 集合的框架结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Collection-%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-text">2、Collection 接口方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">3、Iterator迭代器接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%81%8D%E5%8E%86Collection%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">1. 遍历Collection的两种方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-java-utils%E5%8C%85%E4%B8%8B%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3%EF%BC%9AIterator"><span class="toc-text">2. java.utils包下定义的迭代器接口：Iterator</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">2.1说明：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">2.2作用：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="toc-text">2.3如何获取实例：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4%E9%81%8D%E5%8E%86%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">2.4遍历的代码实现：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-iterator%E4%B8%ADremove-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-text">2.5 iterator中remove()方法的使用：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-JDK-5-0%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%93%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF%EF%BC%9A-foreach%E5%BE%AA%E7%8E%AF"><span class="toc-text">3. JDK 5.0新特性–增强for循环：(foreach循环)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-text">3.1 遍历集合举例：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-text">3.2. 遍历数组举例：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Collection-%E5%AD%90%E6%8E%A5%E5%8F%A3-List"><span class="toc-text">4、Collection 子接口:List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">1. 存储的数据特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A-2"><span class="toc-text">2. 常用方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81ArrayList"><span class="toc-text">3、ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81linkedList"><span class="toc-text">4、linkedList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Collection-%E5%AD%90%E6%8E%A5%E5%8F%A3-Set"><span class="toc-text">5、Collection 子接口:Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-text">1.存储的数据特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%83%E7%B4%A0%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B%EF%BC%9A-%E4%BB%A5HashSet%E4%B8%BA%E4%BE%8B"><span class="toc-text">2. 元素添加过程：(以HashSet为例)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">3. 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E9%87%8D%E5%86%99hashCode-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-text">3.1 重写hashCode()的基本方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E9%87%8D%E5%86%99equals-%E6%96%B9%E6%B3%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-text">3.2 重写equals()方法基本原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-Eclipse-IDEA%E5%B7%A5%E5%85%B7%E9%87%8ChashCode-%E9%87%8D%E5%86%99"><span class="toc-text">3.3 Eclipse&#x2F;IDEA工具里hashCode()重写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81HashSet"><span class="toc-text">4、HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81LinkedHashSet"><span class="toc-text">5、LinkedHashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81TreeSet"><span class="toc-text">6、TreeSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Map%E6%8E%A5%E5%8F%A3"><span class="toc-text">6、Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="toc-text">1. 常见实现类结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-HashMap"><span class="toc-text">1.1 HashMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-LinkedHashMap"><span class="toc-text">1.2 LinkedHashMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-TreeMap"><span class="toc-text">1.3 TreeMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-Hashtable"><span class="toc-text">1.4 Hashtable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5-Properties"><span class="toc-text">1.5 Properties</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">2. 存储结构的理解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-text">3. 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E6%B7%BB%E5%8A%A0%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">3.1添加、删除、修改操作：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">3.2元素查询的操作：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-%E5%85%83%E8%A7%86%E5%9B%BE%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">3.3 元视图操作的方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">总结：常用方法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7、Collections 工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">1.作用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A-3"><span class="toc-text">2.常用方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C"><span class="toc-text">2.1排序操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2%E6%9F%A5%E6%89%BE%E3%80%81%E6%9B%BF%E6%8D%A2"><span class="toc-text">2.2查找、替换</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-text">十二、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%B3%9B%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="toc-text">1、泛型简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%B3%9B%E5%9E%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">1、泛型概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%BC%95%E5%85%A5%E8%83%8C%E6%99%AF"><span class="toc-text">2.泛型的引入背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BC%95%E5%85%A5%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">3.引入泛型的目的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%9B%86%E5%90%88%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="toc-text">2、集合中使用泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="toc-text">3、自定义泛型结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">1. 泛型的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%9A"><span class="toc-text">2. 泛型的实例化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">3. 注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4、泛型的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">1、泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">2、泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">3、泛型通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">4、泛型方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81IO%E6%B5%81"><span class="toc-text">十三、IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">一、File类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-File%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">1. File类的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-File%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">2. File的实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">2.1 常用构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E8%B7%AF%E5%BE%84%E5%88%86%E7%B1%BB"><span class="toc-text">2.2 路径分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E8%B7%AF%E5%BE%84%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-text">2.3 路径分隔符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-File%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">3. File类的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-File%E7%B1%BB%E7%9A%84%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-text">3.1 File类的获取功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-File%E7%B1%BB%E7%9A%84%E9%87%8D%E5%91%BD%E5%90%8D%E5%8A%9F%E8%83%BD"><span class="toc-text">3.2 File类的重命名功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-File%E7%B1%BB%E7%9A%84%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD"><span class="toc-text">3.3 File类的判断功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-Flie%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD"><span class="toc-text">3.4 Flie类的创建功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-File%E7%B1%BB%E7%9A%84%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD"><span class="toc-text">3.5 File类的删除功能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-text">4. 内存解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%83%E4%B9%A0"><span class="toc-text">5. 小练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81IO%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="toc-text">二、IO流概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E8%BF%B0"><span class="toc-text">1. 简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">2. 流的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-IO%E6%B5%81%E7%9A%84%E4%BD%93%E7%B3%BB%E5%88%86%E7%B1%BB"><span class="toc-text">3. IO流的体系分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E6%80%BB%E4%BD%93%E5%88%86%E7%B1%BB"><span class="toc-text">3.1 总体分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E4%B8%AAIO%E6%B5%81%E7%BB%93%E6%9E%84"><span class="toc-text">3.2 常用的几个IO流结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-%E5%AF%B9%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">3.3 对抽象基类的说明：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%A0%87%E5%87%86%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-text">4. 输入、输出标准化过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E8%BE%93%E5%85%A5%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">4.1 输入过程：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-%E8%BE%93%E5%87%BA%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">4.2 输出过程：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%8A%82%E7%82%B9%E6%B5%81%EF%BC%88%E6%96%87%E4%BB%B6%E6%B5%81%EF%BC%89"><span class="toc-text">三、节点流（文件流）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E6%B5%81FileReader%E5%92%8CFileWriter%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1. 文件字符流FileReader和FileWriter的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5"><span class="toc-text">1.1文件的输入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-text">1.2 文件的输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-%E5%B0%8F%E7%BB%83%E4%B9%A0"><span class="toc-text">1.3 小练习</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E6%B5%81FileInputSteam%E5%92%8CFileOutputSteam%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2. 文件字节流FileInputSteam和FileOutputSteam的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B3%A8%E6%84%8F%E7%82%B9-1"><span class="toc-text">3. 注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">四、缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BC%93%E5%86%B2%E6%B5%81%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%B1%BB%EF%BC%9A"><span class="toc-text">1. 缓冲流涉及到的类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%95%E5%85%A5%E7%9B%AE%E7%9A%84%EF%BC%9A"><span class="toc-text">2. 引入目的：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-text">3. 使用说明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E4%BD%BF%E7%94%A8BufferInputStream%E5%92%8CBufferOutputStream%E5%AE%9E%E7%8E%B0%E9%9D%9E%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">3.1使用BufferInputStream和BufferOutputStream实现非文本文件的复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E4%BD%BF%E7%94%A8BufferedReader%E5%92%8CBufferedWriter%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">3.2 使用BufferedReader和BufferedWriter实现文本文件的复制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B0%8F%E7%BB%83%E4%B9%A0"><span class="toc-text">4. 小练习</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E6%B5%8B%E8%AF%95%E7%BC%93%E5%86%B2%E6%B5%81%E5%92%8C%E8%8A%82%E7%82%B9%E6%B5%81%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E9%80%9F%E5%BA%A6"><span class="toc-text">4.1测试缓冲流和节点流文件复制速度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8A%A0%E5%AF%86%E6%93%8D%E4%BD%9C"><span class="toc-text">4.2实现图片加密操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-%E7%BB%9F%E8%AE%A1%E6%96%87%E6%9C%AC%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0"><span class="toc-text">4.3 统计文本字符出现次数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">五、转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1. 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-InputStreamReader"><span class="toc-text">1.1 InputStreamReader</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-OutputStreamWriter"><span class="toc-text">1.2 OutputStreamWriter</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">2.代码示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%96%E7%A0%81%E9%9B%86"><span class="toc-text">3. 编码集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="toc-text">3.1 常见的编码表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E7%BC%96%E7%A0%81%E5%BA%94%E7%94%A8"><span class="toc-text">3.2 编码应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">六、标准输入、输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-1"><span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">2. 主要方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">3. 使用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B0%8F%E7%BB%83%E4%B9%A0-1"><span class="toc-text">4. 小练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-text">七、打印流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text">八、数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-text">九、对象流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E6%B5%81%EF%BC%9A"><span class="toc-text">1.对象流：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">2.作用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">3. 对象的序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%80%E5%B1%9E%E7%9A%84%E7%B1%BB%E9%9C%80%E8%A6%81%E6%BB%A1%E8%B6%B3%EF%BC%9A"><span class="toc-text">4.实现序列化的对象所属的类需要满足：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">5. 对象流的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.1序列化代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.2 反序列化代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E4%BB%BB%E6%84%8F%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-text">十、任意存取文件流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-2"><span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">2.使用说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">3. 使用示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%B5%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-text">十一、流的基本应用总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81NIO"><span class="toc-text">十二、NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-NIO%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">1.NIO的使用说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Path%E6%8E%A5%E5%8F%A3-%E2%80%94JDK-7-0%E6%8F%90%E4%BE%9B"><span class="toc-text">2.Path接口 —JDK 7.0提供</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1Path%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">2.1Path的说明：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-Paths%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2.2 Paths的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.3 常用方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Files%E7%B1%BB"><span class="toc-text">3.Files类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-Files%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">3.1 Files类常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-Files%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%88%A4%E6%96%AD"><span class="toc-text">3.2 Files类常用方法：用于判断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-Files%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E7%94%A8%E4%BA%8E%E6%93%8D%E4%BD%9C%E5%86%85%E5%AE%B9"><span class="toc-text">3.3 Files类常用方法：用于操作内容</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">十四、网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E8%A6%81%E7%B4%A0"><span class="toc-text">二、网络通讯要素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%9A%E8%AE%AF%E8%A6%81%E7%B4%A0%E4%B8%80%EF%BC%9AIP%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">3. 通讯要素一：IP和端口号</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-IP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">3.1 IP的理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%9A"><span class="toc-text">3.2 端口号：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-InetAddress%E7%B1%BB"><span class="toc-text">3.3 InetAddress类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-2-1%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">3.2.1实例化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-2-2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">3.2.2常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A0%E4%BA%8C%EF%BC%9A%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-text">4. 通信要素二：网络通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">4.1分层模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.2 TCP和UDP的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">4.3 TCP三次握手和四次挥手</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A5%97%E6%8E%A5%E5%AD%97Socket"><span class="toc-text">5. 套接字Socket</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">三、TCP网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8ESocke%E7%9A%84TCP%E7%BC%96%E7%A8%8B"><span class="toc-text">1.基于Socke的TCP编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E5%AE%A2%E6%88%B7%E7%AB%AFSocket%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-text">1.1客户端Socket的工作过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AFSocket%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">1.2 服务器端Socket的工作过程：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">1.3 代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">四、UDP网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E8%BF%B0-1"><span class="toc-text">1. 简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-DatagramSocket%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2. DatagramSocket类常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-DatagramSocket%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3. DatagramSocket类的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81URL%E7%BC%96%E7%A8%8B"><span class="toc-text">五、URL编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-URL%E7%B1%BB"><span class="toc-text">1. URL类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">1.1 构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E6%96%B9%E6%B3%95"><span class="toc-text">1.2 方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-text">十五、Java反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-text">一、反射的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%8D%E5%B0%84%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-text">1. 反射的简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%8D%E5%B0%84%E5%8A%A8%E6%80%81%E6%80%A7%E4%BD%93%E7%8E%B0"><span class="toc-text">2. 反射动态性体现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">3. 反射机制提供的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%9B%B8%E5%85%B3API"><span class="toc-text">4. 相关API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Class%E7%B1%BB"><span class="toc-text">二、Class类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Class%E7%AE%80%E8%BF%B0"><span class="toc-text">1. Class简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Class%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2. Class类的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">3. 获取Class实例的几种方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Class%E5%AE%9E%E4%BE%8B%E5%8F%AF%E4%BB%A5%E4%BB%A3%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">4. Class实例可以代表的结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">三、类的加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">1. 类的加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Java%E7%B1%BB%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">2. Java类编译、运行的执行的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">3. 类的加载器的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">4. 类的加载器的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8Classloader%E5%8A%A0%E8%BD%BDsrc%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">5. 使用Classloader加载src目录下的配置文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">四、反射的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">1. 创建运行时类的对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-text">1.1代码举例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E8%AF%B4%E6%98%8E"><span class="toc-text">1.2 说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="toc-text">2. 获取运行时类的完整结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%8F%AF%E4%BB%A5%E5%8F%96%E5%BE%97%EF%BC%9A"><span class="toc-text">2.1 使用反射可以取得：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.2 代码示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84"><span class="toc-text">3. 调用运行时类的指定结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">3.1 调用指定的属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-text">3.2调用指定的方法（常用）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">3.3 调用指定的构造器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">4. 动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">4.1代理设计模式的原理:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">4.2 静态代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">4.3 动态代理的特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.4 动态代理的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#4-4-1-%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">4.4.1 需要解决的两个主要问题：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-4-2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9B%B8%E5%85%B3%E7%9A%84API%EF%BC%9A"><span class="toc-text">4.4.2 动态代理相关的API：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-4-3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">4.4.3 动态代理实现步骤：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-4-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">4.4.2 代码实现：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8EAOP"><span class="toc-text">5. 动态代理与AOP</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148432/" title="MyBatis 拦截器">MyBatis 拦截器</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3346148434/" title="MyBatis 集成druid数据源">MyBatis 集成druid数据源</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1166366203/" title="SQL调优">SQL调优</a><time datetime="2024-07-16T16:00:00.000Z" title="发表于 2024-07-17 00:00:00">2024-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3109398172/" title="ContextHolder">ContextHolder</a><time datetime="2024-07-11T16:00:00.000Z" title="发表于 2024-07-12 00:00:00">2024-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2889834893/" title="SpringCloud Feign">SpringCloud Feign</a><time datetime="2024-07-01T16:00:00.000Z" title="发表于 2024-07-02 00:00:00">2024-07-02</time></div></div></div></div></div></div></main><footer id="footer" style="background: #47577e"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '2N3fEF3CzNAzKwVbFlhSTUuM-gzGzoHsz',
      appKey: '9m41Klhi8IgsrNrbyMnoCHrN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>